<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>üí°3REP Network Builder</title>
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <!-- jsPDF for PDF generation -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
        <!-- JSZip for handling .mvr files -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <style>
            :root {
                --blue: #2563eb;
                --blue-soft: #eff6ff;
                --blue-strong: #1d4ed8;
                --bg: #f3f4f6;
                --bg-dark: #020617;
                --card: #ffffff;
                --card-dark: #020617;
                --border: #e5e7eb;
                --border-soft: #d1d5db;
                --text: #111827;
                --text-soft: #6b7280;
                --text-softer: #9ca3af;
                --danger: #ef4444;
                --warn: #f59e0b;
                --safe: #10b981;
                --orange: #f97316;
                --green: #10b981;
                --font:
                    system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, "Helvetica Neue", Arial, sans-serif;
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                padding: 16px 10px 22px;
                font-family: var(--font);
                background: var(--bg);
                color: var(--text);
                display: flex;
                justify-content: center;
            }

            body.dark-theme {
                background: #020617;
                color: #e5e7eb;
            }
            body.dark-theme .card,
            body.dark-theme .pane-main,
            body.dark-theme .pane-side,
            body.dark-theme .section-card {
                background: var(--card-dark);
                border-color: #1f2937;
            }
            body.dark-theme .btn {
                background: #020617;
                border-color: #374151;
                color: #e5e7eb;
            }
            body.dark-theme .btn-primary {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                border-color: transparent;
                color: #f9fafb;
            }

            .app-shell {
                width: 100%;
                max-width: 1400px;
            }

            .card {
                background: var(--card);
                border-radius: 20px;
                border: 1px solid var(--border);
                box-shadow: 0 12px 35px rgba(15, 23, 42, 0.12);
                padding: 14px 16px 16px;
                transition: all 0.2s ease;
            }

            .card.drag-over {
                border-color: var(--blue);
                border-width: 3px;
                background: var(--blue-soft);
                box-shadow: 0 12px 45px rgba(37, 99, 235, 0.25);
            }
            body.dark-theme .card.drag-over {
                background: rgba(37, 99, 235, 0.1);
            }

            .header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
                flex-wrap: wrap;
                margin-bottom: 8px;
            }

            .brand {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .brand-text h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: 0.03em;
            }
            .brand-text span {
                font-size: 11px;
                color: var(--text-soft);
            }

            .toolbar {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                justify-content: flex-end;
                gap: 6px;
            }

            .btn {
                border-radius: 999px;
                border: 1px solid var(--border-soft);
                padding: 5px 11px;
                font-size: 11px;
                background: #f9fafb;
                color: var(--text);
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
                white-space: nowrap;
                transition: all 0.15s ease;
            }
            .btn:hover:not(:disabled) {
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }
            .btn .icon {
                font-size: 12px;
            }
            .btn-primary {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                color: #fff;
                border-color: transparent;
            }
            .btn-blue {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                color: #fff;
                border-color: transparent;
            }
            .btn-green {
                background: rgba(16, 185, 129, 0.9);
                color: #fff;
                border-color: transparent;
            }
            .btn-orange {
                background: rgba(249, 115, 22, 0.9);
                color: #fff;
                border-color: transparent;
            }
            .btn:disabled {
                opacity: 0.45;
                cursor: default;
            }

            .file-input-wrapper {
                position: relative;
                overflow: hidden;
            }
            .file-input-wrapper input[type="file"] {
                position: absolute;
                inset: 0;
                opacity: 0;
                cursor: pointer;
            }

            .file-status {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 4px 10px;
                border-radius: 999px;
                background: rgba(148, 163, 184, 0.16);
                font-size: 11px;
                border: 1px solid rgba(148, 163, 184, 0.4);
            }
            .file-status-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: var(--safe);
                box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.35);
            }

            .file-checklist {
                display: flex;
                flex-direction: column;
                gap: 4px;
                padding: 8px 10px;
                border-radius: 8px;
                background: rgba(148, 163, 184, 0.08);
                border: 1px solid rgba(148, 163, 184, 0.3);
            }
            body.dark-theme .file-checklist {
                background: rgba(148, 163, 184, 0.12);
            }

            /* Cable Routing Diagram */
            .diagram-container {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 12px;
                background: rgba(148, 163, 184, 0.03);
                border-radius: 12px;
                border: 1px solid rgba(148, 163, 184, 0.2);
                margin-top: 16px;
            }
            body.dark-theme .diagram-container {
                background: rgba(148, 163, 184, 0.08);
                border-color: #1f2937;
            }

            .diagram-canvas {
                background: var(--card);
                border-radius: 8px;
                border: 1px solid var(--border);
                position: relative;
                overflow: auto;
                min-height: 600px;
            }
            body.dark-theme .diagram-canvas {
                background: #0f172a;
                border-color: #1f2937;
            }

            svg.routing-diagram {
                display: block;
                width: 100%;
                height: auto;
            }

            .diagram-node {
                cursor: pointer;
                transition: all 0.2s ease;
            }
            .diagram-node:hover rect,
            .diagram-node:hover circle {
                filter: brightness(1.2) drop-shadow(0 0 8px rgba(37, 99, 235, 0.5));
            }

            .diagram-link {
                stroke-linecap: round;
                stroke-linejoin: round;
                fill: none;
                filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.1));
                pointer-events: stroke;
                cursor: pointer;
            }

            .diagram-link.power {
                stroke: #ef4444;
                stroke-width: 2.5;
                opacity: 0.7;
            }
            .diagram-link.data {
                stroke: #3b82f6;
                stroke-width: 2.5;
                opacity: 0.7;
            }
            .diagram-link:hover {
                stroke-width: 4;
                opacity: 1;
                filter: drop-shadow(0 0 8px currentColor);
            }

            .diagram-legend {
                display: flex;
                gap: 20px;
                padding: 10px 12px;
                background: rgba(148, 163, 184, 0.06);
                border-radius: 6px;
                font-size: 11px;
                flex-wrap: wrap;
                align-items: center;
            }
            body.dark-theme .diagram-legend {
                background: rgba(148, 163, 184, 0.1);
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .legend-box {
                width: 16px;
                height: 16px;
                border-radius: 3px;
                border: 1px solid currentColor;
            }
            .legend-box.distro {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                border-color: #1d4ed8;
            }
            .legend-box.fixture {
                background: #10b981;
                border-color: #059669;
            }
            .legend-line {
                width: 20px;
                height: 2px;
                border-radius: 1px;
                display: inline-block;
            }
            .legend-line.power {
                background: #ef4444;
            }
            .legend-line.data {
                background: #3b82f6;
            }
                border-color: rgba(148, 163, 184, 0.4);
            }

            .file-check-item {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 10px;
                color: var(--text-soft);
                transition: color 0.2s ease;
            }
            .file-check-item.loaded {
                font-weight: 500;
            }

            .check-box {
                font-size: 10px;
                font-weight: 500;
            }

            /* Color-coded checkboxes */
            #checkMVR .check-box {
                color: #dc2626; /* Red */
            }
            #checkMVR.loaded {
                color: #dc2626;
            }
            #checkMVR.loaded .check-box {
                color: #dc2626;
            }

            #checkTXT .check-box {
                color: #16a34a; /* Green */
            }
            #checkTXT.loaded {
                color: #16a34a;
            }
            #checkTXT.loaded .check-box {
                color: #16a34a;
            }

            #checkTSV .check-box {
                color: #2563eb; /* Blue */
            }
            #checkTSV.loaded {
                color: #2563eb;
            }
            #checkTSV.loaded .check-box {
                color: #2563eb;
            }

            #checkJSON .check-box {
                color: #ea580c; /* Orange */
            }
            #checkJSON.loaded {
                color: #ea580c;
            }
            #checkJSON.loaded .check-box {
                color: #ea580c;
            }

            .theme-switch {
                position: relative;
                display: inline-flex;
                align-items: center;
                cursor: pointer;
                padding: 0;
            }
            .theme-switch input {
                display: none;
            }
            .theme-slider {
                position: relative;
                width: 44px;
                height: 20px;
                background: #e5e7eb;
                border-radius: 999px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0 4px;
                font-size: 10px;
            }
            .theme-knob {
                position: absolute;
                top: 2px;
                left: 2px;
                width: 16px;
                height: 16px;
                border-radius: 999px;
                background: #ffffff;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
                transition: transform 0.16s ease;
            }
            body.dark-theme .theme-knob {
                transform: translateX(24px);
            }
            body.dark-theme .theme-slider {
                background: #111827;
                color: #e5e7eb;
            }

            .layout {
                display: grid;
                gap: 10px;
                grid-template-columns: minmax(0, 3fr) minmax(280px, 1fr);
                margin-top: 8px;
            }
            @media (max-width: 960px) {
                .layout {
                    grid-template-columns: 1fr;
                }
            }

            .pane-main {
                background: var(--card);
                border-radius: 14px;
                border: 1px solid var(--border);
                padding: 10px;
            }

            .pane-side {
                background: var(--card);
                border-radius: 14px;
                border: 1px solid var(--border);
                padding: 10px;
            }

            /* Section Cards */
            .section-card {
                background: var(--card);
                border-radius: 14px;
                border: 1px solid var(--border);
                padding: 12px;
                margin-bottom: 10px;
                transition: all 0.2s ease;
            }

            .section-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                cursor: pointer;
                user-select: none;
                padding: 4px 0;
            }
            .section-header:hover {
                color: var(--blue);
            }

            .section-title {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 14px;
                font-weight: 600;
            }

            .section-expand-icon {
                font-size: 12px;
                transition: transform 0.2s ease;
            }
            .section-card.expanded .section-expand-icon {
                transform: rotate(90deg);
            }

            .section-content {
                display: none;
                padding-top: 12px;
            }
            .section-card.expanded .section-content {
                display: block;
            }

            /* PD/DD Cards */
            .pd-dd-grid {
                display: grid;
                gap: 10px;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                margin-top: 10px;
            }

            .pd-card, .dd-card {
                background: #f9fafb;
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 12px;
                transition: all 0.15s ease;
            }
            body.dark-theme .pd-card,
            body.dark-theme .dd-card {
                background: #111827;
            }
            .pd-card:hover, .dd-card:hover {
                border-color: var(--blue);
                box-shadow: 0 2px 8px rgba(37, 99, 235, 0.15);
            }

            .pd-card-header, .dd-card-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }

            .pd-card-title, .dd-card-title {
                font-size: 13px;
                font-weight: 600;
            }

            .pd-card-actions, .dd-card-actions {
                display: flex;
                gap: 4px;
            }

            .pd-card-actions button, .dd-card-actions button {
                padding: 2px 6px;
                font-size: 10px;
            }

            .pd-card-specs, .dd-card-specs {
                font-size: 11px;
                color: var(--text-soft);
                margin-bottom: 8px;
            }

            .capacity-bar {
                height: 6px;
                background: #e5e7eb;
                border-radius: 3px;
                overflow: hidden;
                margin: 6px 0;
            }
            body.dark-theme .capacity-bar {
                background: #374151;
            }

            .capacity-fill {
                height: 100%;
                background: linear-gradient(90deg, var(--safe), var(--blue));
                transition: width 0.3s ease;
            }
            .capacity-fill.warning {
                background: linear-gradient(90deg, var(--warn), var(--orange));
            }
            .capacity-fill.danger {
                background: linear-gradient(90deg, var(--danger), #dc2626);
            }

            .phase-loads {
                display: flex;
                gap: 8px;
                font-size: 10px;
                margin-top: 6px;
            }

            .phase-load {
                flex: 1;
                text-align: center;
                padding: 4px;
                background: rgba(148, 163, 184, 0.1);
                border-radius: 4px;
            }

            /* Stats Sidebar */
            .stat-group {
                margin-bottom: 16px;
            }

            .stat-group-title {
                font-size: 12px;
                font-weight: 600;
                margin-bottom: 8px;
                color: var(--text-soft);
            }

            .stat-item {
                display: flex;
                justify-content: space-between;
                padding: 6px 0;
                font-size: 11px;
                border-bottom: 1px solid var(--border);
            }
            .stat-item:last-child {
                border-bottom: none;
            }

            .stat-label {
                color: var(--text-soft);
            }

            .stat-value {
                font-weight: 600;
            }

            /* Pill Styling */
            .pill {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 3px 8px;
                border-radius: 999px;
                background: rgba(148, 163, 184, 0.12);
                font-size: 10px;
                border: 1px solid rgba(148, 163, 184, 0.3);
                margin: 2px;
                white-space: nowrap;
            }
            body.dark-theme .pill {
                background: rgba(148, 163, 184, 0.2);
                border-color: rgba(148, 163, 184, 0.4);
            }

            .pill.volt-208 {
                border-color: var(--danger);
                border-width: 2px;
            }

            .pill.multi-position {
                border-color: var(--danger);
                border-width: 2px;
            }

            .pills-container {
                display: flex;
                flex-wrap: wrap;
                gap: 2px;
                margin-top: 6px;
                margin-bottom: 8px;
            }

            /* Circuit Layout Styles */
            .circuit-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 16px;
                margin: 16px 0;
            }

            .circuit-panel {
                background: #f9fafb;
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 12px;
                min-height: 200px;
                transition: all 0.2s ease;
            }
            body.dark-theme .circuit-panel {
                background: #111827;
            }
            .circuit-panel:hover {
                border-color: var(--blue);
                box-shadow: 0 4px 12px rgba(37, 99, 235, 0.15);
            }

            .circuit-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
                padding-bottom: 8px;
                border-bottom: 2px solid var(--border);
            }

            .circuit-number {
                font-size: 16px;
                font-weight: 700;
                color: var(--blue);
            }

            .circuit-load {
                font-size: 10px;
                color: var(--text-soft);
                font-weight: 600;
            }

            .circuit-fixtures {
                display: flex;
                flex-direction: column;
                gap: 10px;
                position: relative;
            }

            .fixture-node {
                background: white;
                border: 2px solid var(--border);
                border-radius: 8px;
                padding: 10px;
                position: relative;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
                transition: all 0.15s ease;
            }
            body.dark-theme .fixture-node {
                background: #1f2937;
            }
            .fixture-node:hover {
                border-color: var(--blue);
                transform: translateX(2px);
                box-shadow: 0 3px 8px rgba(37, 99, 235, 0.2);
            }

            .fixture-node::before {
                content: '';
                position: absolute;
                top: -12px;
                left: 50%;
                transform: translateX(-50%);
                width: 2px;
                height: 12px;
                background: var(--text-soft);
            }

            .fixture-node:first-child::before {
                background: var(--blue);
            }

            .fixture-label {
                font-size: 10px;
                font-weight: 600;
                color: var(--text);
                margin-bottom: 4px;
            }

            .fixture-details {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                font-size: 9px;
                color: var(--text-soft);
            }

            .adapter-badge {
                background: var(--warn);
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 8px;
                font-weight: 600;
                margin-top: 4px;
                display: inline-block;
            }

            .adapter-list {
                margin-top: 16px;
                padding: 12px;
                background: rgba(249, 115, 22, 0.08);
                border-radius: 8px;
                border: 1px solid var(--orange);
            }

            .adapter-list-title {
                font-size: 11px;
                font-weight: 600;
                color: var(--orange);
                margin-bottom: 8px;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .adapter-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 6px 8px;
                background: white;
                border-radius: 6px;
                margin-bottom: 4px;
                font-size: 10px;
            }
            body.dark-theme .adapter-item {
                background: #1f2937;
            }

            .adapter-item-label {
                flex: 1;
                font-weight: 500;
            }

            .adapter-item-qty {
                background: var(--blue);
                color: white;
                padding: 2px 8px;
                border-radius: 4px;
                font-size: 9px;
                font-weight: 600;
                min-width: 30px;
                text-align: center;
            }

            /* Device Selection Cards */
            .device-selector {
                margin-top: 12px;
                padding: 12px;
                background: rgba(37, 99, 235, 0.05);
                border: 2px dashed var(--blue);
                border-radius: 8px;
            }

            .device-selector-title {
                font-size: 11px;
                font-weight: 600;
                color: var(--blue);
                margin-bottom: 8px;
            }

            .device-options {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 8px;
                max-height: 300px;
                overflow-y: auto;
            }

            .device-card {
                background: white;
                border: 2px solid var(--border);
                border-radius: 8px;
                padding: 10px;
                cursor: pointer;
                transition: all 0.15s ease;
                text-align: center;
                position: relative;
            }
            body.dark-theme .device-card {
                background: #1f2937;
            }
            .device-card:hover {
                border-color: var(--blue);
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
            }
            .device-card.selected {
                border-color: var(--blue);
                background: var(--blue-soft);
                border-width: 3px;
            }
            body.dark-theme .device-card.selected {
                background: rgba(37, 99, 235, 0.2);
            }

            .device-card-icon {
                font-size: 24px;
                margin-bottom: 6px;
            }

            .device-card-label {
                font-size: 10px;
                font-weight: 600;
                color: var(--text);
                margin-bottom: 2px;
            }

            .device-card-detail {
                font-size: 8px;
                color: var(--text-soft);
            }

            .device-card.fixture {
                border-color: var(--green);
            }
            .device-card.fixture:hover {
                border-color: var(--green);
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
            }

            .device-card.adapter {
                border-color: var(--orange);
            }
            .device-card.adapter:hover {
                border-color: var(--orange);
                box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
            }

            .circuit-chain {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 12px;
                background: rgba(148, 163, 184, 0.05);
                border-radius: 8px;
                margin-top: 12px;
            }

            .chain-item {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 10px;
                background: white;
                border: 2px solid var(--border);
                border-radius: 8px;
                position: relative;
            }
            body.dark-theme .chain-item {
                background: #1f2937;
            }

            .chain-item::after {
                content: '‚Üì';
                position: absolute;
                bottom: -18px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 14px;
                color: var(--blue);
                font-weight: bold;
            }

            .chain-item:last-child::after {
                display: none;
            }

            .chain-item-icon {
                font-size: 20px;
                flex-shrink: 0;
            }

            .chain-item-details {
                flex: 1;
            }

            .chain-item-label {
                font-size: 11px;
                font-weight: 600;
                margin-bottom: 2px;
            }

            .chain-item-info {
                font-size: 9px;
                color: var(--text-soft);
            }

            .chain-item-remove {
                background: var(--danger);
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 9px;
                cursor: pointer;
                font-weight: 600;
            }

            .stat-list-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 6px 0 4px;
                border-bottom: 1px solid var(--border);
                margin-bottom: 4px;
            }

            .stat-list-title {
                font-size: 11px;
                font-weight: 600;
                color: var(--text-soft);
            }

            .stat-list-count {
                font-size: 10px;
                color: var(--text-softer);
            }

            /* Empty State */
            .empty-state {
                text-align: center;
                padding: 40px 20px;
                color: var(--text-soft);
            }

            .empty-state-icon {
                font-size: 48px;
                margin-bottom: 12px;
                opacity: 0.5;
            }

            .empty-state-text {
                font-size: 13px;
            }

            /* Add Button */
            .add-btn {
                width: 100%;
                padding: 8px;
                margin-top: 10px;
                border: 2px dashed var(--border);
                background: transparent;
                border-radius: 8px;
                color: var(--text-soft);
                cursor: pointer;
                transition: all 0.15s ease;
            }
            .add-btn:hover {
                border-color: var(--blue);
                color: var(--blue);
                background: var(--blue-soft);
            }

            /* Tabs */
            .tabs {
                display: flex;
                gap: 4px;
                border-bottom: 2px solid var(--border);
                margin-bottom: 12px;
            }

            .tab {
                padding: 8px 16px;
                font-size: 12px;
                font-weight: 600;
                background: transparent;
                border: none;
                color: var(--text-soft);
                cursor: pointer;
                border-bottom: 2px solid transparent;
                margin-bottom: -2px;
                transition: all 0.15s ease;
            }
            .tab:hover {
                color: var(--blue);
            }
            .tab.active {
                color: var(--blue);
                border-bottom-color: var(--blue);
            }

            /* Modal/Dialog */
            .modal-overlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                align-items: center;
                justify-content: center;
            }
            .modal-overlay.active {
                display: flex;
            }

            .modal {
                background: var(--card);
                border-radius: 16px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            }

            .modal-header {
                font-size: 16px;
                font-weight: 600;
                margin-bottom: 16px;
            }

            .modal-body {
                margin-bottom: 16px;
            }

            .modal-footer {
                display: flex;
                gap: 8px;
                justify-content: flex-end;
            }

            .form-group {
                margin-bottom: 12px;
            }

            .form-label {
                display: block;
                font-size: 11px;
                font-weight: 600;
                margin-bottom: 4px;
                color: var(--text-soft);
            }

            .form-input,
            .form-select {
                width: 100%;
                padding: 6px 8px;
                font-size: 12px;
                border: 1px solid var(--border);
                border-radius: 6px;
                background: #f9fafb;
            }
            body.dark-theme .form-input,
            body.dark-theme .form-select {
                background: #111827;
                color: #e5e7eb;
            }

            /* Progress Indicator */
            .progress-indicator {
                display: flex;
                gap: 8px;
                margin-bottom: 12px;
                padding: 8px;
                background: rgba(148, 163, 184, 0.08);
                border-radius: 8px;
            }

            .progress-step {
                flex: 1;
                text-align: center;
                padding: 4px;
                font-size: 10px;
                border-radius: 4px;
                background: #e5e7eb;
                color: var(--text-soft);
                cursor: pointer;
            }
            body.dark-theme .progress-step {
                background: #374151;
            }

            .progress-step.complete {
                background: var(--safe);
                color: white;
            }

            .progress-step.active {
                background: var(--blue);
                color: white;
                font-weight: 600;
            }

            .toast {
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--card);
                border: 1px solid var(--border);
                padding: 10px 20px;
                border-radius: 8px;
                font-size: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 9999;
                opacity: 0;
                transition: opacity 0.3s ease;
                pointer-events: none;
            }
            .toast.show { opacity: 1; }

            /* Mode Choice Buttons */
            .mode-choice-btn:hover {
                border-color: var(--blue) !important;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
            }
            body.dark-theme .mode-choice-btn {
                background: #111827 !important;
            }

            /* Universe Item Selection */
            .universe-item {
                padding: 6px 8px;
                border: 1px solid var(--border);
                border-radius: 6px;
                background: white;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.15s ease;
                user-select: none;
            }
            body.dark-theme .universe-item {
                background: #1f2937;
            }
            .universe-item:hover {
                border-color: var(--blue);
                background: var(--blue-soft);
            }
            .universe-item.selected {
                border-color: var(--blue);
                background: var(--blue);
                color: white;
                font-weight: 600;
            }
            .universe-item.split {
                border-left: 3px solid var(--orange);
            }

            /* Smooth Animations */
            .stat-value {
                transition: all 0.3s ease;
            }

            .capacity-fill {
                transition: width 0.3s ease, background 0.3s ease;
            }

            /* Section Status Icons */
            .section-status-icon {
                margin-left: 8px;
                font-size: 14px;
            }

            /* Over Capacity Warning */
            .dd-card.over-capacity,
            .pd-card.over-capacity {
                border-color: var(--danger);
                border-width: 2px;
                background: rgba(239, 68, 68, 0.05);
            }

            .warning-badge {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 2px 6px;
                background: var(--danger);
                color: white;
                border-radius: 999px;
                font-size: 9px;
                font-weight: 600;
            }

            .console-option:hover {
                border-color: var(--primary) !important;
                background: var(--primary-light) !important;
            }

            .console-option.selected {
                border-color: var(--primary) !important;
                border-width: 3px !important;
                background: var(--primary-light) !important;
            }

            .mode-choice-btn:hover {
                border-color: var(--primary) !important;
                background: var(--primary-light) !important;
            }

            .mode-choice-btn.selected {
                border-color: var(--primary) !important;
                border-width: 3px !important;
                background: var(--primary-light) !important;
            }

            .pd-preset-btn:hover, .dd-preset-btn:hover {
                border-color: var(--primary) !important;
                background: var(--primary-light) !important;
            }

            .pd-preset-btn.disabled, .dd-preset-btn.disabled {
                opacity: 0.5;
                pointer-events: none;
                filter: grayscale(50%);
                cursor: not-allowed;
            }
        </style>
    </head>
    <body>
        <div class="app-shell">
            <!-- Header Card -->
            <div class="card">
                <div class="header">
                    <div class="brand">
                        <div class="brand-text">
                            <h1>üí° 3REP Network Builder</h1>
                            <span>Power & Data Infrastructure Tool</span>
                        </div>
                    </div>

                    <div class="toolbar">
                        <span class="file-status" id="fileStatus">
                            <span class="file-status-dot"></span>
                            No project loaded
                        </span>

                        <div class="file-checklist" id="fileChecklist">
                            <div class="file-check-item" id="checkMVR">
                                <span class="check-box">‚òê</span> Drawing (MVR / XML)
                            </div>
                            <div class="file-check-item" id="checkTXT">
                                <span class="check-box">‚òê</span> Patch (TXT)
                            </div>
                            <div class="file-check-item" id="checkTSV">
                                <span class="check-box">‚òê</span> Inventory Database (TSV)
                            </div>
                            <div class="file-check-item" id="checkJSON">
                                <span class="check-box">‚òê</span> Export Project (JSON)
                                <button class="btn btn-sm" id="jsonDownloadBtn" onclick="downloadJSONFile()" style="display: none; margin-left: 8px; padding: 2px 8px; font-size: 10px;">
                                    <span class="icon" style="font-size: 10px;">üíæ</span> Export Project (JSON)
                                </button>
                                <div id="jsonAutoSaveMsg" style="display: none; font-size: 10px; color: var(--text-soft); margin-top: 4px; margin-left: 20px;">
                                    Auto-saved in browser. Use 'Export Project (JSON)' to download to your device.
                                </div>
                            </div>
                        </div>

                        <label class="theme-switch">
                            <input type="checkbox" id="themeToggle" />
                            <div class="theme-slider">
                                <span class="theme-icon">‚òÄÔ∏è</span>
                                <div class="theme-knob"></div>
                                <span class="theme-icon">üåô</span>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Main Toolbar -->
                <div class="toolbar" style="margin-top: 8px;">
                    <div class="file-input-wrapper">
                        <button class="btn btn-primary">
                            <span class="icon">üìÇ</span> Load Files
                        </button>
                        <input
                            type="file"
                            id="fileInput"
                            multiple
                        />
                    </div>

                    <div class="file-input-wrapper">
                        <button class="btn btn-primary">
                            <span class="icon">üìÅ</span> Load Folder
                        </button>
                        <input
                            type="file"
                            id="folderInput"
                            webkitdirectory
                            directory
                            multiple
                        />
                    </div>

                    <button class="btn" id="mergeBtn" disabled>
                        <span class="icon">üîÑ</span> Merge Update
                    </button>

                    <button class="btn btn-blue" id="saveProjectBtn" disabled>
                        <span class="icon">üíæ</span> Export Project (JSON)
                    </button>

                    <button class="btn btn-blue" id="exportGearPdfBtn" disabled>
                        <span class="icon">üìã</span> Export Gear PDF
                    </button>

                    <button class="btn btn-blue" id="exportCablePdfBtn" disabled>
                        <span class="icon">üìÑ</span> Export Cable PDF
                    </button>

                    <button class="btn" id="undoBtn" disabled>
                        <span class="icon">‚Ü©Ô∏è</span> Undo
                    </button>

                    <button class="btn" id="redoBtn" disabled>
                        <span class="icon">‚Ü™Ô∏è</span> Redo
                    </button>
                </div>
            </div>

            <!-- Main Layout -->
            <div class="layout">
                <!-- Main Content -->
                <div class="pane-main">
                    <!-- Progress Indicator -->
                    <div class="progress-indicator">
                        <div class="progress-step" id="progressBOH" onclick="openSection('boh')">1. BOH Setup</div>
                        <div class="progress-step" id="progressFOH" onclick="openSection('foh')">2. FOH Setup</div>
                        <div class="progress-step" id="progressConnections" onclick="openSection('connections')">3. Connections</div>
                        <div class="progress-step" id="progressExport" onclick="openSection('diagram')">4. Export</div>
                    </div>

                    <!-- BOH Section -->
                    <div class="section-card" id="bohSection">
                        <div class="section-header" onclick="toggleSection('boh')">
                            <div class="section-title">
                                <span class="section-expand-icon">‚ñ∂</span>
                                <span>üè≠ BOH - Back of House</span>
                            </div>
                        </div>
                        <div class="section-content">
                            <!-- Power Distributions -->
                            <div>
                                <h3 style="font-size: 13px; margin-bottom: 12px;">‚ö° Power Distributions</h3>

                                <div class="pd-dd-grid" id="pdGrid">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">‚ö°</div>
                                        <div class="empty-state-text">No power distributions yet</div>
                                    </div>
                                </div>

                                <!-- TSV Upload Prompt (shown when no TSV loaded) -->
                                <div id="pdTSVPrompt" style="margin-top: 16px; display: none;">
                                    <div style="padding: 32px; border: 2px dashed var(--border); border-radius: 12px; background: var(--bg); text-align: center;">
                                        <div style="font-size: 48px; margin-bottom: 12px;">üìã</div>
                                        <div style="font-weight: 600; font-size: 16px; margin-bottom: 8px;">Upload TSV using toolbar above</div>
                                        <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 16px;">Use the toolbar above to load inventory and unlock power distribution presets</div>
                                        <div class="file-input-wrapper" style="display: inline-block;">
                                            <button class="btn btn-primary" style="padding: 10px 20px;">
                                                <span class="icon">üìÇ</span> Upload TSV
                                            </button>
                                            <input type="file" accept=".tsv" onchange="handleTSVUpload(event)" multiple />
                                        </div>
                                    </div>
                                </div>

                                <!-- PD Preset Selection -->
                                <div id="pdPresetSelection" style="margin-top: 16px; display: none;">
                                    <div id="pdPresetHint" style="display: none; font-size: 11px; color: var(--text-soft); margin-bottom: 10px;">
                                        Load TSV to unlock preset cards. Custom is always available.
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px;">
                                        <button class="pd-preset-btn" data-preset="applied" onclick="selectPDPreset('applied')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">‚ö° Applied Distro</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">5x 120V + 1x 208V MULTs</div>
                                        </button>
                                        <button class="pd-preset-btn" data-preset="lex48" onclick="selectPDPreset('lex48')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">‚ö° Lex 48 Circuit</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">Presidential Power Rack</div>
                                        </button>
                                        <button class="pd-preset-btn" data-preset="lex15" onclick="selectPDPreset('lex15')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">‚ö° Lex 15x20amp Edison</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">2x 120V MULTs</div>
                                        </button>
                                        <button class="pd-preset-btn" data-preset="lex12" onclick="selectPDPreset('lex12')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">‚ö° Lex 12x20amp L6-20</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">2x 208V MULTs</div>
                                        </button>
                                        <button class="pd-preset-btn" data-preset="custom" onclick="selectPDPreset('custom')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">‚öôÔ∏è Custom</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">Configure manually</div>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Data Distributions -->
                            <div style="margin-top: 20px;">
                                <h3 style="font-size: 13px; margin-bottom: 12px;">üåê Data Distributions</h3>

                                <div class="pd-dd-grid" id="ddGrid">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">üåê</div>
                                        <div class="empty-state-text">No data distributions yet</div>
                                    </div>
                                </div>

                                <!-- TSV Upload Prompt for Data Distributions (shown when no TSV loaded) -->
                                <div id="ddTSVPrompt" style="margin-top: 16px; display: none;">
                                    <div style="padding: 32px; border: 2px dashed var(--border); border-radius: 12px; background: var(--bg); text-align: center;">
                                        <div style="font-size: 48px; margin-bottom: 12px;">üìã</div>
                                        <div style="font-weight: 600; font-size: 16px; margin-bottom: 8px;">Upload TSV using toolbar above</div>
                                        <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 16px;">Use the toolbar above to load inventory and unlock data distribution presets</div>
                                        <div class="file-input-wrapper" style="display: inline-block;">
                                            <button class="btn btn-primary" style="padding: 10px 20px;">
                                                <span class="icon">üìÇ</span> Upload TSV
                                            </button>
                                            <input type="file" accept=".tsv" onchange="handleTSVUpload(event)" multiple />
                                        </div>
                                    </div>
                                </div>

                                <!-- Mode Selection (shown when no mode selected) -->
                                <div id="dataModeSelection" style="margin-top: 16px; display: block;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                                        <button class="mode-choice-btn" id="mode-network" onclick="selectDataMode('network')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-size: 24px; margin-bottom: 8px;">üß†üíª</div>
                                            <div style="font-weight: 600; margin-bottom: 6px;">Network Mode</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">EtherCON via Nodes</div>
                                        </button>
                                        <button class="mode-choice-btn" id="mode-copper" onclick="selectDataMode('copper')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-size: 24px; margin-bottom: 8px;">üéõÔ∏è</div>
                                            <div style="font-weight: 600; margin-bottom: 6px;">Copper Mode</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">Direct DMX 5-pin</div>
                                        </button>
                                    </div>
                                    <div style="font-size: 11px; color: var(--text-soft);">Device presets require TSV; you can still choose a mode now.</div>
                                </div>

                                <!-- DD Device Selection -->
                                <div id="ddDeviceSelection" style="margin-top: 16px; display: block;">
                                    <div id="ddPresetHint" style="display: none; font-size: 11px; color: var(--text-soft); margin-bottom: 10px;">
                                        Load TSV to unlock device presets. Custom is always available.
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px;">
                                        <button class="dd-preset-btn" data-preset="node-netx2" onclick="selectDDDevice('node-netx2')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">üß† Chauvet Net-X II</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">8 universes, 8 outputs</div>
                                        </button>
                                        <button class="dd-preset-btn" data-preset="splitter-ds4" onclick="selectDDDevice('splitter-ds4')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">üéõÔ∏è Chauvet DJ Data Stream 4</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">1 universe, 8 outputs (Opti)</div>
                                        </button>
                                        <button class="dd-preset-btn" data-preset="custom" onclick="selectDDDevice('custom')" style="padding: 24px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">‚öôÔ∏è Custom</div>
                                            <div style="font-size: 11px; color: var(--text-soft);">Configure manually</div>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Fixture Database -->
                            <div style="margin-top: 20px;">
                                <h3 style="font-size: 13px; margin-bottom: 12px;">üí° Fixture Database</h3>

                                <div class="pd-dd-grid" id="fixtureDbGrid">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">üí°</div>
                                        <div class="empty-state-text">No custom fixtures yet</div>
                                    </div>
                                </div>

                                <!-- Add Custom Fixture Button -->
                                <div style="margin-top: 16px;">
                                    <button class="btn btn-primary" onclick="openAddFixtureModal()" style="width: 100%;">
                                        <span>+ Add Custom Fixture</span>
                                    </button>
                                    <div style="margin-top: 8px; font-size: 10px; color: var(--text-soft); text-align: center;">
                                        ${Object.keys(DEFAULT_FIXTURE_DATABASE).length} default fixtures in database
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- FOH Section -->
                    <div class="section-card" id="fohSection">
                        <div class="section-header" onclick="toggleSection('foh')">
                            <div class="section-title">
                                <span class="section-expand-icon">‚ñ∂</span>
                                <span>üéõÔ∏è FOH - Front of House</span>
                                <span class="section-progress-badge" id="fohProgress" style="display: none;"></span>
                            </div>
                        </div>
                        <div class="section-content">
                            <div class="subsection-title">Console Selection</div>

                            <!-- Upload Prompt (shown when no MVR/TXT loaded) -->
                            <div id="fohConsolePrompt" style="display: none; margin-bottom: 24px;">
                                <div style="padding: 32px; border: 2px dashed var(--border); border-radius: 12px; background: var(--bg); text-align: center;">
                                    <div id="fohConsolePromptIcon" style="font-size: 48px; margin-bottom: 12px;">üî¥üü¢</div>
                                    <div id="fohConsolePromptTitle" style="font-weight: 600; font-size: 16px; margin-bottom: 8px;">Upload files using toolbar above</div>
                                    <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 16px;">Required to configure FOH console and connections</div>
                                    <div class="file-input-wrapper" style="display: inline-block;">
                                        <button class="btn btn-primary" style="padding: 10px 20px;">
                                            <span class="icon">üìÇ</span> Upload Files
                                        </button>
                                        <input type="file" accept=".mvr,.xml,.zip,.txt" onchange="handleFileUpload(event)" multiple />
                                    </div>
                                </div>
                            </div>

                            <!-- Console Options Grid (shown when MVR/TXT loaded) -->
                            <div id="fohConsoleSelection" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-bottom: 24px;">
                                <!-- ChamSys Quick Q10 -->
                                <button class="console-option" id="console-quickq10" onclick="selectConsole('quickq10')" style="padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                    <div style="font-weight: 600; margin-bottom: 4px;">üéõÔ∏è ChamSys Quick Q10</div>
                                    <div style="font-size: 11px; color: var(--text-soft);">< 1 universe (Copper only)</div>
                                </button>

                                <!-- ChamSys Quick Q20 -->
                                <button class="console-option" id="console-quickq20" onclick="selectConsole('quickq20')" style="padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                    <div style="font-weight: 600; margin-bottom: 4px;">üéõÔ∏è ChamSys Quick Q20</div>
                                    <div style="font-size: 11px; color: var(--text-soft);">< 2 universes (Network OR Copper)</div>
                                </button>

                                <!-- RoadHog4 -->
                                <button class="console-option" id="console-roadhog4" onclick="selectConsole('roadhog4')" style="padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                    <div style="font-weight: 600; margin-bottom: 4px;">üéõÔ∏è RoadHog4</div>
                                    <div style="font-size: 11px; color: var(--text-soft);">< 8 universes Network, 4 Copper</div>
                                </button>

                                <!-- Full Boar 4 -->
                                <button class="console-option" id="console-fullboar4" onclick="selectConsole('fullboar4')" style="padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                    <div style="font-weight: 600; margin-bottom: 4px;">üéõÔ∏è Full Boar 4</div>
                                    <div style="font-size: 11px; color: var(--text-soft);">< 12 universes Network, 4 Copper</div>
                                </button>

                                <!-- Custom Console -->
                                <button class="console-option" id="console-custom" onclick="openCustomConsoleForm()" style="padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); cursor: pointer; text-align: left; transition: all 0.2s;">
                                    <div style="font-weight: 600; margin-bottom: 4px;">‚öôÔ∏è Custom Console</div>
                                    <div style="font-size: 11px; color: var(--text-soft);">Enter your own console</div>
                                </button>
                            </div>

                            <!-- Custom Console Form -->
                            <div id="customConsoleForm" style="display: none; margin-bottom: 20px; padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: var(--card);">
                                <div style="font-weight: 600; margin-bottom: 12px;">‚öôÔ∏è Custom Console Configuration</div>
                                <div style="display: grid; gap: 12px;">
                                    <div>
                                        <label style="font-size: 11px; font-weight: 500; display: block; margin-bottom: 4px;">Console Name *</label>
                                        <input type="text" id="customConsoleName" class="form-input" placeholder="e.g., MA Lighting GrandMA3" style="width: 100%;" />
                                    </div>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                        <div>
                                            <label style="font-size: 11px; font-weight: 500; display: block; margin-bottom: 4px;">Network Universes *</label>
                                            <input type="number" id="customConsoleNetwork" class="form-input" placeholder="0" min="0" value="0" style="width: 100%;" />
                                        </div>
                                        <div>
                                            <label style="font-size: 11px; font-weight: 500; display: block; margin-bottom: 4px;">Copper Universes *</label>
                                            <input type="number" id="customConsoleCopper" class="form-input" placeholder="0" min="0" value="0" style="width: 100%;" />
                                        </div>
                                    </div>
                                    <div>
                                        <label style="font-size: 11px; font-weight: 500; display: block; margin-bottom: 4px;">Notes (optional)</label>
                                        <input type="text" id="customConsoleNotes" class="form-input" placeholder="Additional notes..." style="width: 100%;" />
                                    </div>
                                    <div style="display: flex; gap: 8px; justify-content: flex-end;">
                                        <button class="btn" onclick="cancelCustomConsole()">Cancel</button>
                                        <button class="btn btn-primary" onclick="saveCustomConsole()">Save Console</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Selected Console Display -->
                            <div id="consoleDisplay" style="display: none;">
                                <div class="dd-card">
                                    <div class="dd-card-header">
                                        <div class="dd-card-title" id="consoleName">Console</div>
                                    </div>
                                    <div class="dd-card-specs" id="consoleSpecs"></div>
                                    <div id="consoleCapacity"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Connections Section -->
                    <div class="section-card" id="connectionsSection">
                        <div class="section-header" onclick="toggleSection('connections')">
                            <div class="section-title">
                                <span class="section-expand-icon">‚ñ∂</span>
                                <span>üîå Connections</span>
                            </div>
                        </div>
                        <div class="section-content">
                            <div class="tabs">
                                <button class="tab active" onclick="switchTab('power')">‚ö° Power</button>
                                <button class="tab" onclick="switchTab('data')">üåê Data</button>
                            </div>

                            <div id="powerTab">
                                <div id="powerConnectionsList"></div>
                                <div id="noPowerConnections" class="empty-state">
                                    <div class="empty-state-icon">‚ö°</div>
                                    <div class="empty-state-text">No power distributions configured yet</div>
                                    <div class="empty-state-hint">
                                        <button class="btn btn-secondary" onclick="openSection('boh')">Go to BOH ‚Üí Power Distributions</button>
                                    </div>
                                </div>
                            </div>

                            <div id="dataTab" style="display: none;">
                                <div id="dataConnectionsList"></div>
                                <div id="noDataConnections" class="empty-state">
                                    <div class="empty-state-icon">üåê</div>
                                    <div class="empty-state-text">No data distributions configured yet</div>
                                    <div class="empty-state-hint">
                                        <button class="btn btn-secondary" onclick="openSection('boh')">Go to BOH ‚Üí Data Distributions</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Cable Routing Diagram Section -->
                    <div class="section-card" id="diagramSection">
                        <div class="section-header" onclick="toggleSection('diagram')">
                            <div class="section-title">
                                <span class="section-expand-icon">‚ñ∂</span>
                                <span>üìä Cable Routing Diagram</span>
                            </div>
                        </div>
                        <div class="section-content" style="padding: 0;">
                            <div class="diagram-container">
                                <div class="diagram-legend">
                                    <div class="legend-item">
                                        <div class="legend-box distro"></div>
                                        <span>Distributions</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-box fixture"></div>
                                        <span>Fixtures</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-line power"></div>
                                        <span>Power Cable</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-line data"></div>
                                        <span>Data Cable</span>
                                    </div>
                                </div>
                                <div class="diagram-canvas" id="diagramCanvas">
                                    <svg class="routing-diagram" id="routingDiagram"></svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sidebar -->
                <div class="pane-side">
                    <!-- Global Upload Warning (shown when no MVR/TXT loaded) -->
                    <div class="stat-group" id="globalUploadPrompt" style="display: none;">
                        <div style="padding: 20px; border: 2px dashed var(--border); border-radius: 8px; background: var(--bg); text-align: center;">
                            <div id="globalPromptIcon" style="font-size: 32px; margin-bottom: 8px;">üî¥üü¢</div>
                            <div id="globalPromptTitle" style="font-weight: 600; font-size: 12px; margin-bottom: 4px;">Upload files using toolbar above</div>
                            <div style="font-size: 10px; color: var(--text-soft); margin-bottom: 12px;">Use the toolbar above to upload MVR/TXT files<br>TXT shows MULTs & Circuits; MVR shows fixture positions</div>
                            <div class="file-input-wrapper" style="display: inline-block;">
                                <button class="btn btn-primary" style="padding: 6px 12px; font-size: 10px;">
                                    <span class="icon">üìÇ</span> Upload Files
                                </button>
                                <input type="file" accept=".mvr,.xml,.zip,.txt" onchange="handleFileUpload(event)" multiple />
                            </div>
                        </div>
                    </div>

                    <div class="stat-group" id="circuitAssignmentStats" style="display: none;">
                        <div class="stat-group-title">Power Distribution</div>
                            <div class="stat-item">
                                <span class="stat-label">120V MULTs Total</span>
                                <span class="stat-value" id="stat120Total">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">120V Assigned</span>
                                <span class="stat-value" id="stat120Assigned">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">120V Unassigned</span>
                                <span class="stat-value" id="stat120Unassigned">0</span>
                            </div>
                            <div class="stat-item" style="margin-top: 8px;">
                                <span class="stat-label">208V MULTs Total</span>
                                <span class="stat-value" id="stat208Total">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">208V Assigned</span>
                                <span class="stat-value" id="stat208Assigned">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">208V Unassigned</span>
                                <span class="stat-value" id="stat208Unassigned">0</span>
                            </div>
                            <div class="stat-item" style="margin-top: 8px;">
                                <span class="stat-label">Status</span>
                                <span class="stat-value" id="statCircuitsStatus">-</span>
                            </div>
                        </div>
                    </div>

                    <div class="stat-group" id="universeAssignmentStats" style="display: none;">
                        <div class="stat-group-title">Data Distribution</div>
                        <div class="stat-item">
                            <span class="stat-label">Mode</span>
                            <span class="stat-value" id="statDataMode">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Universes</span>
                            <span class="stat-value" id="statUniversesTotal">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Assigned</span>
                            <span class="stat-value" id="statUniversesAssigned">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Unassigned</span>
                            <span class="stat-value" id="statUniversesUnassigned">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">üîÄ Split Universes</span>
                            <span class="stat-value" id="statSplitUniverses">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Status</span>
                            <span class="stat-value" id="statUniversesStatus">-</span>
                        </div>
                    </div>

                    <div class="stat-group" id="bohStats" style="display: none;">
                            <div class="stat-list-header">
                                <span class="stat-list-title">MULTs</span>
                                <span class="stat-list-count" id="statMults">0</span>
                            </div>
                            <div class="pills-container" id="multsList">
                                <!-- MULTs will be populated here -->
                            </div>

                            <div class="stat-list-header" style="margin-top: 12px;">
                                <span class="stat-list-title">Universes</span>
                                <span class="stat-list-count" id="statUniverses">0</span>
                            </div>
                            <div class="pills-container" id="universesList">
                                <!-- Universes will be populated here -->
                            </div>
                        </div>
                    </div>

                    <div class="stat-group" id="detailedStats" style="display: none;">
                        <div class="stat-group-title">Power</div>
                        <div class="stat-item">
                            <span class="stat-label">Distributions</span>
                            <span class="stat-value" id="statPDs">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Circuits</span>
                            <span class="stat-value" id="statCircuits">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Load</span>
                            <span class="stat-value" id="statLoad">0 kW</span>
                        </div>
                    </div>

                    <div class="stat-group" id="dataStats" style="display: none;">
                        <div class="stat-group-title">Data</div>
                        <div class="stat-item">
                            <span class="stat-label">Distributions</span>
                            <span class="stat-value" id="statDDs">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Ports</span>
                            <span class="stat-value" id="statPorts">0</span>
                        </div>
                    </div>

                    <div class="stat-group" id="fixtureStats" style="display: none;">
                        <div class="stat-group-title">Fixtures</div>
                        <div class="stat-item">
                            <span class="stat-label">Total Fixtures</span>
                            <span class="stat-value" id="statFixtures">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Assigned Power</span>
                            <span class="stat-value" id="statAssignedPower">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Assigned Data</span>
                            <span class="stat-value" id="statAssignedData">0</span>
                        </div>
                    </div>

                    <!-- Connection Status Checklist (shown in Connections tab) -->
                    <div class="stat-group" id="connectionStatusGroup" style="display: none;">
                        <div class="stat-list-header">
                            <span class="stat-list-title">Connection Status</span>
                            <span class="stat-list-count" id="connectionStatusCount">0%</span>
                        </div>
                        <div id="connectionStatusContent" style="margin-top: 8px; display: flex; flex-direction: column; gap: 6px; max-height: 500px; overflow-y: auto;">
                            <!-- Connection status items will be populated here -->
                        </div>
                    </div>

                    <!-- Gear List -->
                    <div class="stat-group" id="gearListGroup" style="display: none; margin-top: 20px; padding-top: 12px; border-top: 2px solid var(--border);">
                        <div class="stat-list-header">
                            <span class="stat-list-title">Cable List</span>
                            <span class="stat-list-count" id="gearListCount">0</span>
                        </div>
                        <div id="gearListContent" style="margin-top: 8px; display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">
                            <!-- Gear list items will be populated here -->
                        </div>
                    </div>

                    <!-- Last Updated -->
                    <div class="stat-group" id="lastUpdatedGroup" style="display: none; margin-top: 20px; padding-top: 12px; border-top: 2px solid var(--border);">
                        <div style="font-size: 9px; color: var(--text-softer); text-align: center;">
                            Last Updated:<br/>
                            <span id="lastUpdatedTime">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Summary Strip -->
        <div id="summaryStrip" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: var(--card); border-top: 2px solid var(--border); padding: 8px 16px; box-shadow: 0 -4px 12px rgba(0,0,0,0.1); z-index: 100;">
            <div style="max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; font-size: 11px;">
                <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                    <div><strong>PDs:</strong> <span id="stripPDs">0</span></div>
                    <div><strong>DDs:</strong> <span id="stripDDs">0</span></div>
                    <div><strong>Universes:</strong> <span id="stripUniverses">0</span></div>
                    <div><strong>MULTs:</strong> <span id="stripMults">0</span></div>
                    <div><strong>Fixtures:</strong> <span id="stripFixtures">0</span></div>
                </div>
                <div style="font-size: 10px; color: var(--text-soft);">
                    <span id="stripStatus">‚öôÔ∏è In Progress</span>
                </div>
            </div>
        </div>

        <!-- Add PD Modal -->
        <div class="modal-overlay" id="pdModal">
            <div class="modal">
                <div class="modal-header">Add Power Distribution</div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Preset Options</label>
                        <select class="form-select" id="pdPreset" onchange="handlePresetChange()">
                            <option value="">-- Select Preset or Custom --</option>
                            <option value="applied">Applied Distro (5x 120V MULTs + 1x 208V MULT + 3x L21-30)</option>
                            <option value="lex48">Lex 48 Circuit 120V/208V Presidential Power Rack</option>
                            <option value="lex15">Lex 15x20amp Edison Distro (2x 120V MULTs)</option>
                            <option value="lex12">Lex 12x20amp L6-20 208V Distro (2x 208V MULTs)</option>
                            <option value="custom">Custom Configuration</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Name *</label>
                        <input type="text" class="form-input" id="pdName" placeholder="e.g., Main Rack A" />
                    </div>
                    <div class="form-group" id="pdConfigTypeGroup" style="display: none;">
                        <label class="form-label">Configuration Type</label>
                        <select class="form-select" id="pdConfigType" onchange="handleConfigTypeChange()">
                            <option value="fixed">Fixed Circuits (separate 120V/208V)</option>
                            <option value="flexible">Flexible MULTs (configurable 120V or 208V)</option>
                        </select>
                    </div>
                    <div class="form-group" id="pdFlexMultsGroup" style="display: none;">
                        <label class="form-label">Number of Flexible MULTs (120V or 208V) *</label>
                        <input type="number" class="form-input" id="pdFlexMults" value="6" min="1" />
                        <div style="font-size: 10px; color: var(--text-soft); margin-top: 4px;">
                            Each MULT = 6 circuits. Can be configured as 120V or 208V as needed
                        </div>
                    </div>
                    <div class="form-group" id="pdCircuits120Group">
                        <label class="form-label">Number of 120V Circuits *</label>
                        <input type="number" class="form-input" id="pdCircuits120" value="0" min="0" />
                    </div>
                    <div class="form-group" id="pdCircuits208Group">
                        <label class="form-label">Number of 208V Circuits *</label>
                        <input type="number" class="form-input" id="pdCircuits208" value="0" min="0" />
                    </div>
                    <div class="form-group" id="pdNotesGroup">
                        <label class="form-label">Notes (optional)</label>
                        <input type="text" class="form-input" id="pdNotes" placeholder="Additional notes..." />
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="closePDModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="savePD()">Add PD</button>
                </div>
            </div>
        </div>

        <!-- Data Mode Selection Modal -->
        <div class="modal-overlay" id="dataModeModal">
            <div class="modal" style="max-width: 600px;">
                <div class="modal-header">Choose Data Distribution Mode</div>
                <div class="modal-body">
                    <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 20px;">
                        Select how you want to distribute data to your fixtures
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                        <button class="mode-choice-btn" onclick="selectDataMode('network')" style="padding: 24px; border: 2px solid var(--border); border-radius: 12px; background: var(--card); cursor: pointer; transition: all 0.2s ease;">
                            <div style="font-size: 32px; margin-bottom: 12px;">üß†üíª</div>
                            <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Network Mode</div>
                            <div style="font-size: 11px; color: var(--text-soft);">EtherCON distribution via Nodes</div>
                            <div style="font-size: 10px; color: var(--text-softer); margin-top: 8px;">For larger shows (4+ universes)</div>
                        </button>
                        <button class="mode-choice-btn" onclick="selectDataMode('copper')" style="padding: 24px; border: 2px solid var(--border); border-radius: 12px; background: var(--card); cursor: pointer; transition: all 0.2s ease;">
                            <div style="font-size: 32px; margin-bottom: 12px;">üéõÔ∏è</div>
                            <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Copper Mode</div>
                            <div style="font-size: 11px; color: var(--text-soft);">Direct DMX 5-pin distribution</div>
                            <div style="font-size: 10px; color: var(--text-softer); margin-top: 8px;">For smaller shows (&lt;4 universes)</div>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Universe Management Modal -->
        <div class="modal-overlay" id="universeManageModal">
            <div class="modal" style="max-width: 800px;">
                <div class="modal-header">Manage Universe Assignments</div>
                <div class="modal-body">
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: start;">
                        <!-- Source Device -->
                        <div>
                            <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;" id="sourceDeviceName">Source Device</div>
                            <div style="background: #f9fafb; border: 1px solid var(--border); border-radius: 8px; padding: 12px; min-height: 200px;">
                                <div style="font-size: 11px; color: var(--text-soft); margin-bottom: 8px;">Available Universes:</div>
                                <div id="sourceUniverseList" style="display: flex; flex-direction: column; gap: 4px;">
                                    <!-- Will be populated dynamically -->
                                </div>
                            </div>
                        </div>

                        <!-- Move Controls -->
                        <div style="display: flex; flex-direction: column; gap: 8px; padding-top: 40px;">
                            <button class="btn" onclick="moveUniverseRight()" style="font-size: 16px; padding: 8px 12px;" title="Move selected to destination">‚Üí</button>
                            <button class="btn" onclick="moveUniverseLeft()" style="font-size: 16px; padding: 8px 12px;" title="Move selected to source">‚Üê</button>
                        </div>

                        <!-- Destination Device -->
                        <div>
                            <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;" id="destDeviceName">Destination Device</div>
                            <div style="background: #f9fafb; border: 1px solid var(--border); border-radius: 8px; padding: 12px; min-height: 200px;">
                                <div style="font-size: 11px; color: var(--text-soft); margin-bottom: 8px;">
                                    Available Universes: <span id="destCapacityInfo"></span>
                                </div>
                                <div id="destUniverseList" style="display: flex; flex-direction: column; gap: 4px;">
                                    <!-- Will be populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="closeUniverseManageModal()">Done</button>
                </div>
            </div>
        </div>

        <!-- Add DD Modal (Node/Splitter) -->
        <div class="modal-overlay" id="ddModal">
            <div class="modal">
                <div class="modal-header" id="ddModalHeader">Add Data Distribution</div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Device Type</label>
                        <select class="form-select" id="ddDeviceType" onchange="handleDDDeviceTypeChange()">
                            <option value="">-- Select Device Type --</option>
                            <option value="node" id="ddNodeOption">Node (Network)</option>
                            <option value="splitter">Opti Splitter</option>
                        </select>
                    </div>
                    <div class="form-group" id="ddPresetGroup" style="display: none;">
                        <label class="form-label">Preset Options</label>
                        <select class="form-select" id="ddPreset" onchange="handleDDPresetChange()">
                            <option value="">-- Select Preset or Custom --</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Name *</label>
                        <input type="text" class="form-input" id="ddName" placeholder="e.g., FOH Node" />
                    </div>
                    <div class="form-group" id="ddUniversesGroup">
                        <label class="form-label">Universe Capacity *</label>
                        <input type="number" class="form-input" id="ddUniverses" value="8" min="1" />
                    </div>
                    <div class="form-group" id="ddOutputsGroup">
                        <label class="form-label">DMX Outputs</label>
                        <input type="number" class="form-input" id="ddOutputs" value="8" min="1" />
                    </div>
                    <div class="form-group" id="ddConnectorGroup">
                        <label class="form-label">Connector Type</label>
                        <input type="text" class="form-input" id="ddConnector" placeholder="e.g., A5, A3" />
                    </div>
                    <div class="form-group" id="ddNotesGroup">
                        <label class="form-label">Notes (optional)</label>
                        <input type="text" class="form-input" id="ddNotes" placeholder="Additional notes..." />
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="closeDDModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveDD()">Add Device</button>
                </div>
            </div>
        </div>

        <!-- Add/Edit Fixture Modal -->
        <div class="modal-overlay" id="fixtureModal">
            <div class="modal">
                <div class="modal-header" id="fixtureModalHeader">Add Custom Fixture</div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Fixture Name *</label>
                        <input type="text" class="form-input" id="fixtureName" placeholder="e.g., Chauvet Rogue R1 Spot" />
                    </div>
                    <div class="form-group">
                        <label class="form-label">Power Inlet *</label>
                        <select class="form-select" id="fixturePowerIn">
                            <option value="">-- Select Power Inlet --</option>
                            <option value="Edison">Edison</option>
                            <option value="PowerCon">PowerCon (Blue)</option>
                            <option value="L6-20">L6-20</option>
                            <option value="IEC">IEC</option>
                            <option value="Tru1">Tru1</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Power Outlet</label>
                        <select class="form-select" id="fixturePowerOut">
                            <option value="">-- No Power Thru --</option>
                            <option value="Edison">Edison</option>
                            <option value="PowerCon">PowerCon (Gray)</option>
                            <option value="L6-20">L6-20</option>
                            <option value="IEC">IEC</option>
                            <option value="Tru1">Tru1</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Voltage *</label>
                        <select class="form-select" id="fixtureVoltage">
                            <option value="">-- Select Voltage --</option>
                            <option value="120V">120V</option>
                            <option value="208V">208V</option>
                            <option value="120V/208V">120V / 208V (Auto-ranging)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Wattage *</label>
                        <input type="number" class="form-input" id="fixtureWattage" placeholder="e.g., 300" min="0" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="closeFixtureModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveFixture()">Save Fixture</button>
                </div>
            </div>
        </div>

        <!-- File Conflict / Overwrite Confirmation Modal -->
        <div class="modal-overlay" id="fileConflictModal">
            <div class="modal" style="max-width: 700px;">
                <div class="modal-header">‚ö†Ô∏è File Overwrite Detected</div>
                <div class="modal-body">
                    <div style="font-size: 13px; color: var(--text); margin-bottom: 16px;">
                        <strong id="conflictFileType">Data</strong> is already loaded. Uploading this file will replace the existing data.
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid var(--border);">
                        <div>
                            <div style="font-size: 11px; font-weight: 600; color: var(--text-soft); margin-bottom: 4px;">CURRENT FILE</div>
                            <div style="font-size: 12px; font-weight: 500;" id="conflictOldFile">file_v1.txt</div>
                        </div>
                        <div>
                            <div style="font-size: 11px; font-weight: 600; color: var(--text-soft); margin-bottom: 4px;">NEW FILE</div>
                            <div style="font-size: 12px; font-weight: 500;" id="conflictNewFile">file_v2.txt</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">üìã Change Summary</div>
                        <div id="conflictChangeLog" style="max-height: 300px; overflow-y: auto; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid var(--border); font-size: 12px; line-height: 1.6;">
                            <!-- Change log will be inserted here -->
                        </div>
                    </div>

                    <div style="padding: 12px; background: rgba(234, 88, 12, 0.1); border: 1px solid rgba(234, 88, 12, 0.3); border-radius: 8px;">
                        <div style="font-size: 11px; color: var(--text);">
                            ‚ö†Ô∏è <strong>Warning:</strong> This action cannot be undone. Your current data will be replaced.
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="cancelFileConflict()">Cancel - Keep Current</button>
                    <button class="btn btn-primary" id="smartMergeBtn" onclick="confirmSmartMerge()" style="display: none;">
                        <span>üîÑ</span> Smart Merge - Preserve Cables
                    </button>
                    <button class="btn" style="background: #ea580c; color: white;" onclick="confirmFileOverwrite()">Replace All Data</button>
                </div>
            </div>
        </div>

        <script>
            // ============================================
            // Global State
            // ============================================
            let projectData = {
                showName: "",
                fixtures: [],
                powerDistributions: [],
                dataDistributions: [],
                dataMode: null, // 'network' or 'copper'
                console: null, // Selected console object
                connections: {
                    power: [],
                    data: []
                },
                cableList: [], // {connectionId, cableType, lengths: [{length: '5ft', quantity: 1}], totalLength: 0}
                connectionStatuses: {
                    companySwitch: { connected: true, complete: true },
                    console: { connected: true, complete: true },
                    powerDistros: [], // [{id, connected, complete}]
                    nodes: [], // [{id, connected, complete}]
                    splitters: [], // [{id, connected, complete}]
                    positions: [] // [{name, powerConnected, powerComplete, dataConnected, dataComplete, mults: [...]}]
                },
                positions: [], // [{name, powerSource: 'BOH', dataSource: 'BOH'}]
                gearList: [],
                lastUpdated: null,
                activeSection: null, // 'boh', 'foh', 'connections', 'export'
                customFixtures: [], // User-added custom fixtures [{name, powerIn, powerOut, voltage, wattage}]
                fixtureTypeMap: {}, // TXT/MVR fixture type -> TSV mapping
                fixtureTypeSuggestions: {}, // Suggested TSV matches awaiting manual approval
                sourceFiles: {} // Optional: raw MVR/TXT/TSV payloads for JSON export
            };

            // Default Fixture Database - Common fixtures with power connector information
            const DEFAULT_FIXTURE_DATABASE = {
                // ETC Source Four Family
                "Source Four 19": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },
                "Source Four 26": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },
                "Source Four 36": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },
                "Source Four 50": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },
                "Source Four PAR": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },
                "Source Four Jr": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },
                "S4": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 575 },

                // ETC ColorSource Family
                "ColorSource PAR": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 180 },
                "ColorSource Linear": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 200 },
                "ColorSource Spot": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 180 },

                // Chauvet Ovation Family
                "Ovation E-260WW": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 260 },
                "Ovation E-910FC": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 200 },
                "Ovation F-165WW": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 165 },
                "Ovation F-915VW": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 240 },

                // Chauvet Rogue Family (Moving Lights)
                "Rogue R1 Spot": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 300 },
                "Rogue R2 Spot": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 470 },
                "Rogue R2 Wash": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 380 },
                "Rogue R3 Spot": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 800 },

                // Elation Artiste Family
                "Artiste Picasso": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 550 },
                "Artiste Monet": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 450 },

                // Martin MAC Family
                "MAC Aura": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 250 },
                "MAC Viper": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 1000 },

                // Ayrton Family
                "Ayrton Mistral": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 520 },
                "Ayrton Khamsin": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "208V", wattage: 700 },

                // Generic PAR Cans
                "PAR64": { powerIn: "Edison", powerOut: "Edison", voltage: "120V", wattage: 1000 },
                "PAR56": { powerIn: "Edison", powerOut: "Edison", voltage: "120V", wattage: 500 },
                "PAR38": { powerIn: "Edison", powerOut: "Edison", voltage: "120V", wattage: 150 },

                // LED PARs
                "LED PAR": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 150 },
                "LED Wash": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 200 },

                // Fresnels
                "6\" Fresnel": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 750 },
                "8\" Fresnel": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 1000 },

                // Cyc Lights
                "Cyc Light": { powerIn: "Edison", powerOut: "Edison", voltage: "120V", wattage: 1000 },
                "LED Cyc": { powerIn: "PowerCon", powerOut: "PowerCon", voltage: "120V", wattage: 300 },

                // Misc
                "Work Light": { powerIn: "Edison", powerOut: "Edison", voltage: "120V", wattage: 500 },
                "Practical": { powerIn: "Edison", powerOut: null, voltage: "120V", wattage: 100 }
            };

            // Function to look up fixture in database (fuzzy match)
            function lookupFixture(fixtureName) {
                if (!fixtureName) return null;

                const name = fixtureName.trim();

                // Check custom fixtures first (exact match)
                const customFixture = projectData.customFixtures.find(f => f.name === name);
                if (customFixture) {
                    return customFixture;
                }

                // Check custom fixtures (fuzzy match)
                const lowerName = name.toLowerCase();
                const customFuzzy = projectData.customFixtures.find(f =>
                    lowerName.includes(f.name.toLowerCase()) || f.name.toLowerCase().includes(lowerName)
                );
                if (customFuzzy) {
                    return customFuzzy;
                }

                // Exact match in default database
                if (DEFAULT_FIXTURE_DATABASE[name]) {
                    return DEFAULT_FIXTURE_DATABASE[name];
                }

                // Fuzzy match in default database
                for (const [key, value] of Object.entries(DEFAULT_FIXTURE_DATABASE)) {
                    if (lowerName.includes(key.toLowerCase()) || key.toLowerCase().includes(lowerName)) {
                        return value;
                    }
                }

                // Not found
                return null;
            }

            // Console presets
            const consolePresets = {
                quickq10: {
                    name: 'ChamSys Quick Q10',
                    manufacturer: 'ChamSys',
                    maxUniverses: {
                        network: 0,
                        copper: 1
                    },
                    outputMode: 'copper-only', // Can only do copper
                    description: '< 1 full universe (Copper only)'
                },
                quickq20: {
                    name: 'ChamSys Quick Q20',
                    manufacturer: 'ChamSys',
                    maxUniverses: {
                        network: 2,
                        copper: 2
                    },
                    outputMode: 'either', // Can do network OR copper (but not both simultaneously)
                    description: '< 2 full universes (Network OR Copper)'
                },
                roadhog4: {
                    name: 'RoadHog4',
                    manufacturer: 'High End Systems',
                    maxUniverses: {
                        network: 8,
                        copper: 4
                    },
                    outputMode: 'simultaneous', // Can do network AND copper simultaneously
                    description: '< 8 universes Network, 4 Copper'
                },
                fullboar4: {
                    name: 'Full Boar 4',
                    manufacturer: 'High End Systems',
                    maxUniverses: {
                        network: 12,
                        copper: 4
                    },
                    outputMode: 'simultaneous', // Can do network AND copper simultaneously
                    description: '< 12 universes Network, 4 Copper'
                }
            };

            // Track project changes
            function markProjectUpdated() {
                recordHistory();
                projectData.lastUpdated = new Date();
                updateLastUpdatedDisplay();
                updateBottomSummaryStrip();
                updateSectionProgress();

                // Auto-save to browser localStorage
                autoSaveProject();
            }

            function captureSnapshot() {
                return JSON.parse(JSON.stringify(projectData));
            }

            function restoreSnapshot(snapshot) {
                projectData = snapshot;
                if (projectData.lastUpdated) {
                    projectData.lastUpdated = new Date(projectData.lastUpdated);
                }
                renderPDs();
                renderDDs();
                renderCustomFixtures();
                renderConsoleDisplay();
                renderConnections();
                renderRoutingDiagram();
                updateStats();
                updateBottomSummaryStrip();
                updateSectionProgress();
                updateSidebarForSection(projectData.activeSection || 'boh');
                updateLastUpdatedDisplay();
            }

            function recordHistory() {
                if (isRestoringHistory) return;

                if (lastSnapshot) {
                    const label = `Change at ${new Date().toLocaleTimeString()}`;
                    historyStack.push({ snapshot: lastSnapshot, label: label });
                    if (historyStack.length > 50) historyStack.shift();
                    redoStack = [];
                }

                lastSnapshot = captureSnapshot();
                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                if (undoBtn && redoBtn) {
                    undoBtn.disabled = historyStack.length === 0;
                    redoBtn.disabled = redoStack.length === 0;
                }
            }

            function undo() {
                if (historyStack.length === 0) {
                    showToast('Nothing to undo');
                    return;
                }

                const entry = historyStack.pop();
                redoStack.push({ snapshot: captureSnapshot(), label: entry.label });
                isRestoringHistory = true;
                restoreSnapshot(entry.snapshot);
                isRestoringHistory = false;
                updateUndoRedoButtons();
                showToast(`Undone: ${entry.label}`);
            }

            function redo() {
                if (redoStack.length === 0) {
                    showToast('Nothing to redo');
                    return;
                }

                const entry = redoStack.pop();
                historyStack.push({ snapshot: captureSnapshot(), label: entry.label });
                isRestoringHistory = true;
                restoreSnapshot(entry.snapshot);
                isRestoringHistory = false;
                updateUndoRedoButtons();
                showToast(`Redone: ${entry.label}`);
            }

            function buildSavePayload() {
                const dataToSave = { ...projectData };
                dataToSave.sourceFiles = {
                    mvr: uploadedFiles.mvr || null,
                    txt: uploadedFiles.txt || null,
                    tsv: uploadedFiles.tsv || null
                };
                return dataToSave;
            }

            function autoSaveProject() {
                try {
                    // Create a copy of projectData including source files
                    const dataToSave = buildSavePayload();

                    // Save to localStorage
                    localStorage.setItem('network_builder_autosave', JSON.stringify(dataToSave));

                    // Update uploadedFiles to reflect auto-saved JSON
                    uploadedFiles.json = dataToSave;
                    updateFileChecklist(uploadedFiles, true);
                } catch (err) {
                    console.warn("Auto-save failed:", err);
                }
            }

            function loadAutoSavedProject() {
                try {
                    const saved = localStorage.getItem('network_builder_autosave');
                    if (saved) {
                        const data = JSON.parse(saved);
                        // Check if it has valid project data
                        if (data.fixtures && data.fixtures.length > 0) {
                            return data;
                        }
                    }
                } catch (err) {
                    console.warn("Failed to load auto-saved project:", err);
                }
                return null;
            }

            function updateLastUpdatedDisplay() {
                if (!projectData.lastUpdated) {
                    $('lastUpdatedGroup').style.display = 'none';
                    return;
                }

                $('lastUpdatedGroup').style.display = 'block';
                const now = new Date();
                const diff = now - projectData.lastUpdated;
                const seconds = Math.floor(diff / 1000);
                const minutes = Math.floor(seconds / 60);

                let timeText;
                if (seconds < 5) {
                    timeText = 'Just now';
                } else if (seconds < 60) {
                    timeText = `${seconds}s ago`;
                } else if (minutes < 60) {
                    timeText = `${minutes}m ago`;
                } else {
                    timeText = projectData.lastUpdated.toLocaleTimeString();
                }

                $('lastUpdatedTime').textContent = timeText;
            }

            function updateBottomSummaryStrip() {
                // Show strip if project has data
                const hasData = projectData.fixtures.length > 0 ||
                               projectData.powerDistributions.length > 0 ||
                               projectData.dataDistributions.length > 0;

                if (!hasData) {
                    $('summaryStrip').style.display = 'none';
                    return;
                }

                $('summaryStrip').style.display = 'block';

                // Count universes
                const universesSet = new Set();
                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        const universeAddress = fixture['Universe/Address'];
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                universesSet.add(parseInt(universePart));
                            }
                        }
                    });
                }

                // Count MULTs
                const circuits = getCircuitsFromFixtures();
                const totalMults = circuits.mults120.length + circuits.mults208.length;

                // Update strip
                animateNumber('stripPDs', projectData.powerDistributions.length);
                animateNumber('stripDDs', projectData.dataDistributions.length);
                animateNumber('stripUniverses', universesSet.size);
                animateNumber('stripMults', totalMults);
                animateNumber('stripFixtures', projectData.fixtures.length);

                // Update status
                const bohComplete = validateBOHSection();
                const fohComplete = validateFOHSection();
                let statusText = '‚öôÔ∏è In Progress';
                if (bohComplete && fohComplete) {
                    statusText = '‚úÖ Setup Complete';
                } else if (bohComplete) {
                    statusText = 'üîß BOH Complete';
                }
                $('stripStatus').textContent = statusText;
            }

            function animateNumber(elementId, targetValue) {
                const el = $(elementId);
                const currentValue = parseInt(el.textContent) || 0;

                if (currentValue === targetValue) return;

                // Simple animation - just update the value
                el.textContent = targetValue;

                // Add a pulse animation
                el.style.transform = 'scale(1.2)';
                el.style.color = 'var(--blue)';
                setTimeout(() => {
                    el.style.transform = 'scale(1)';
                    el.style.color = '';
                }, 200);
            }

            // Power Distribution Presets
            const PD_PRESETS = {
                applied: {
                    name: "Applied Distro",
                    circuits120: 30,
                    circuits208: 6,
                    notes: "3x L21-30 connectors",
                    gearItems: []
                },
                lex48: {
                    name: "Lex 48 Circuit Presidential",
                    circuits120: 48,  // Default to all 120V (user can adjust)
                    circuits208: 0,
                    notes: "48 circuits total, 6 MULTs (configurable 120V or 208V)",
                    gearItems: []
                },
                lex15: {
                    name: "Lex 15x20amp Edison Distro",
                    circuits120: 12,  // 2 MULTs √ó 6 circuits
                    circuits208: 0,
                    notes: "2x 120V MULTs",
                    gearItems: ["2x Edison to MULT FAN IN"]
                },
                lex12: {
                    name: "Lex 12x20amp L6-20 208V Distro",
                    circuits120: 0,
                    circuits208: 12,  // 2 MULTs √ó 6 circuits
                    notes: "2x 208V MULTs",
                    gearItems: ["2x L6-20 to MULT FAN IN"]
                }
            };

            // Node Presets (Network Mode)
            const NODE_PRESETS = {
                netx2: {
                    name: "Chauvet Net-X II",
                    inputType: "EtherCON",
                    universes: 8,
                    outputs: 8,
                    connector: "A5 or A3",
                    powerReq: "True1 or Edison",
                    notes: "8 universes, 8x DMX outputs"
                },
                pathport: {
                    name: "Pathport Octo",
                    inputType: "EtherCON",
                    universes: 8,
                    outputs: 8,
                    connector: "A5",
                    powerReq: "True1",
                    notes: "8 universes, 8x A5 outputs"
                },
                storm8: {
                    name: "ENTTEC Storm 8",
                    inputType: "EtherCON",
                    universes: 8,
                    outputs: 8,
                    connector: "A5",
                    powerReq: "Edison",
                    notes: "8 universes, 8x A5 outputs"
                }
            };

            // Opti Splitter Presets (Both Modes)
            const SPLITTER_PRESETS = {
                datastream4: {
                    name: "Chauvet DJ Data Stream 4",
                    universes: 1,
                    inputs: "(1) A3 or (1) A5 In",
                    outputs: "(4) A3 and (4) A5 Out",
                    connector: "A3/A5",
                    notes: "8 total outputs (4x 3-pin, 4x 5-pin)"
                },
                rdmx8_single: {
                    name: "Chauvet RDMX Splitter 8 (Single Universe)",
                    universes: 1,
                    inputs: "(1) A5 In",
                    outputs: "(8) A5 Out",
                    connector: "A5",
                    notes: "Single universe mode"
                },
                rdmx8_dual: {
                    name: "Chauvet RDMX Splitter 8 (Dual Universe)",
                    universes: 2,
                    inputs: "(2) A5 In",
                    outputs: "(4) A5 Out per universe",
                    connector: "A5",
                    notes: "Dual universe capable"
                }
            };

            let historyStack = [];
            let redoStack = [];
            let lastSnapshot = null;
            let isRestoringHistory = false;

            // ============================================
            // Persistent File Storage
            // ============================================
            const uploadedFiles = {
                mvr: null,
                txt: null,
                json: null,
                tsv: null
            };

            // Pending file conflict state
            let pendingFileConflict = null;
            let pendingMVRChanges = null; // Stores detailed fixture changes for smart merge

            // ============================================
            // File Conflict Detection & Change Log
            // ============================================
            function generateChangeLog(fileType, oldData, newData) {
                const changes = [];

                switch(fileType) {
                    case 'mvr':
                        return generateMVRChangeLog(oldData, newData);
                    case 'txt':
                        return generateTXTChangeLog(oldData, newData);
                    case 'json':
                        return generateJSONChangeLog(oldData, newData);
                    case 'tsv':
                        return generateTSVChangeLog(oldData, newData);
                    default:
                        return ['<div>Unable to generate change log for this file type.</div>'];
                }
            }

            function generateMVRChangeLog(oldData, newData) {
                const changes = [];
                const oldFixtures = oldData?.fixtures || [];
                const newFixtures = newData?.fixtures || [];

                // Create maps for comparison
                const oldMap = new Map(oldFixtures.map(f => [f.UUID || f.Position, f]));
                const newMap = new Map(newFixtures.map(f => [f.UUID || f.Position, f]));

                const addedList = [];
                const removedList = [];
                const modifiedList = [];

                // Check for removed and modified fixtures
                oldMap.forEach((oldFix, id) => {
                    if (!newMap.has(id)) {
                        removedList.push(oldFix);
                    } else {
                        const newFix = newMap.get(id);
                        // Check for meaningful changes (position, type, DMX address)
                        const posChanged = oldFix.PositionX !== newFix.PositionX ||
                                         oldFix.PositionY !== newFix.PositionY ||
                                         oldFix.PositionZ !== newFix.PositionZ;
                        const addressChanged = oldFix['Universe/Address'] !== newFix['Universe/Address'];
                        const typeChanged = oldFix['Instrument Type'] !== newFix['Instrument Type'];

                        if (posChanged || addressChanged || typeChanged) {
                            modifiedList.push({ old: oldFix, new: newFix, posChanged, addressChanged, typeChanged });
                        }
                    }
                });

                // Check for added fixtures
                newMap.forEach((newFix, id) => {
                    if (!oldMap.has(id)) {
                        addedList.push(newFix);
                    }
                });

                // Summary counts
                if (addedList.length > 0) {
                    changes.push(`<div style="color: #16a34a; font-weight: 600;">‚úÖ ${addedList.length} fixture${addedList.length !== 1 ? 's' : ''} added</div>`);
                    const preview = addedList.slice(0, 3).map(f => {
                        const name = f['Instrument Type'] || f.Position || 'Unknown';
                        const pos = f.Position ? ` (${f.Position})` : '';
                        return `<div style="color: #16a34a; font-size: 11px; padding-left: 16px;">‚Ä¢ ${name}${pos}</div>`;
                    });
                    changes.push(...preview);
                    if (addedList.length > 3) {
                        changes.push(`<div style="color: var(--text-soft); font-size: 11px; padding-left: 16px;">...and ${addedList.length - 3} more</div>`);
                    }
                }

                if (removedList.length > 0) {
                    changes.push(`<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">‚ùå ${removedList.length} fixture${removedList.length !== 1 ? 's' : ''} removed</div>`);
                    const preview = removedList.slice(0, 3).map(f => {
                        const name = f['Instrument Type'] || f.Position || 'Unknown';
                        const pos = f.Position ? ` (${f.Position})` : '';
                        return `<div style="color: #dc2626; font-size: 11px; padding-left: 16px;">‚Ä¢ ${name}${pos}</div>`;
                    });
                    changes.push(...preview);
                    if (removedList.length > 3) {
                        changes.push(`<div style="color: var(--text-soft); font-size: 11px; padding-left: 16px;">...and ${removedList.length - 3} more</div>`);
                    }
                }

                if (modifiedList.length > 0) {
                    changes.push(`<div style="color: #ea580c; font-weight: 600; margin-top: 8px;">‚ö†Ô∏è ${modifiedList.length} fixture${modifiedList.length !== 1 ? 's' : ''} modified</div>`);
                    const preview = modifiedList.slice(0, 3).map(item => {
                        const name = item.new['Instrument Type'] || item.new.Position || 'Unknown';
                        const changeTypes = [];
                        if (item.posChanged) changeTypes.push('position');
                        if (item.addressChanged) changeTypes.push('DMX address');
                        if (item.typeChanged) changeTypes.push('type');
                        return `<div style="color: #ea580c; font-size: 11px; padding-left: 16px;">‚Ä¢ ${name} (${changeTypes.join(', ')})</div>`;
                    });
                    changes.push(...preview);
                    if (modifiedList.length > 3) {
                        changes.push(`<div style="color: var(--text-soft); font-size: 11px; padding-left: 16px;">...and ${modifiedList.length - 3} more</div>`);
                    }
                }

                if (changes.length === 0) {
                    changes.push('<div style="color: var(--text-soft);">No changes detected in fixture data</div>');
                } else {
                    // Store detailed changes for smart merge
                    pendingMVRChanges = { addedList, removedList, modifiedList };
                }

                // Show filename change if applicable
                if (oldData.originalFileName !== newData.originalFileName) {
                    changes.push(`<div style="margin-top: 12px; color: var(--text-soft); font-size: 11px;">Show name: "${oldData.originalFileName}" ‚Üí "${newData.originalFileName}"</div>`);
                }

                return changes;
            }

            function generateTXTChangeLog(oldData, newData) {
                const changes = [];

                if (!oldData || !newData) {
                    return ['<div>Unable to compare TXT files</div>'];
                }

                const oldLines = oldData.lines || [];
                const newLines = newData.lines || [];

                const added = newLines.length - oldLines.length;

                if (added > 0) {
                    changes.push(`<div style="color: #16a34a;">‚ûï Added ${added} line${added !== 1 ? 's' : ''}</div>`);
                } else if (added < 0) {
                    changes.push(`<div style="color: #dc2626;">‚ûñ Removed ${Math.abs(added)} line${Math.abs(added) !== 1 ? 's' : ''}</div>`);
                }

                // Check for modified lines
                let modified = 0;
                const minLength = Math.min(oldLines.length, newLines.length);
                for (let i = 0; i < minLength; i++) {
                    if (oldLines[i] !== newLines[i]) {
                        modified++;
                    }
                }

                if (modified > 0) {
                    changes.push(`<div style="color: #ea580c;">‚úèÔ∏è Modified ${modified} line${modified !== 1 ? 's' : ''}</div>`);
                }

                if (changes.length === 0) {
                    changes.push('<div style="color: var(--text-soft);">No changes detected in patch data</div>');
                }

                return changes;
            }

            function generateJSONChangeLog(oldData, newData) {
                const changes = [];

                // Compare major sections
                const sections = [
                    { key: 'fixtures', label: 'Fixtures' },
                    { key: 'powerDistributions', label: 'Power Distributions' },
                    { key: 'dataDistributions', label: 'Data Distributions' },
                    { key: 'cableList', label: 'Cable List' },
                    { key: 'customFixtures', label: 'Custom Fixtures' }
                ];

                sections.forEach(section => {
                    const oldCount = (oldData[section.key] || []).length;
                    const newCount = (newData[section.key] || []).length;

                    if (oldCount !== newCount) {
                        const diff = newCount - oldCount;
                        if (diff > 0) {
                            changes.push(`<div style="color: #16a34a;">‚ûï ${section.label}: +${diff} item${Math.abs(diff) !== 1 ? 's' : ''}</div>`);
                        } else {
                            changes.push(`<div style="color: #dc2626;">‚ûñ ${section.label}: ${diff} item${Math.abs(diff) !== 1 ? 's' : ''}</div>`);
                        }
                    }
                });

                // Check console change
                if (oldData.console?.name !== newData.console?.name) {
                    changes.push(`<div style="color: #ea580c;">‚úèÔ∏è Console: ${oldData.console?.name || 'None'} ‚Üí ${newData.console?.name || 'None'}</div>`);
                }

                // Check data mode change
                if (oldData.dataMode !== newData.dataMode) {
                    changes.push(`<div style="color: #ea580c;">‚úèÔ∏è Data Mode: ${oldData.dataMode || 'None'} ‚Üí ${newData.dataMode || 'None'}</div>`);
                }

                if (changes.length === 0) {
                    changes.push('<div style="color: var(--text-soft);">No significant changes detected</div>');
                } else {
                    changes.unshift('<div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è This will replace your entire project state:</div>');
                }

                return changes;
            }

            function generateTSVChangeLog(oldData, newData) {
                const changes = [];

                const oldRows = (oldData?.data || []).length;
                const newRows = (newData?.data || []).length;

                const diff = newRows - oldRows;

                if (diff > 0) {
                    changes.push(`<div style="color: #16a34a;">‚ûï Added ${diff} row${Math.abs(diff) !== 1 ? 's' : ''}</div>`);
                } else if (diff < 0) {
                    changes.push(`<div style="color: #dc2626;">‚ûñ Removed ${Math.abs(diff)} row${Math.abs(diff) !== 1 ? 's' : ''}</div>`);
                }

                if (changes.length === 0) {
                    changes.push(`<div style="color: var(--text-soft);">Same number of rows (${newRows})</div>`);
                }

                changes.push('<div style="margin-top: 8px; color: var(--text-soft);">Note: Detailed inventory comparison not available</div>');

                return changes;
            }

            function showFileConflictModal(fileType, oldFileName, newFileName, oldData, newData) {
                const modal = $('fileConflictModal');
                const smartMergeBtn = $('smartMergeBtn');
                const fileTypeLabel = {
                    'mvr': 'Drawing (MVR/XML)',
                    'txt': 'Patch (TXT)',
                    'json': 'Project (JSON)',
                    'tsv': 'Inventory Database (TSV)'
                };

                $('conflictFileType').textContent = fileTypeLabel[fileType] || 'File';
                $('conflictOldFile').textContent = oldFileName;
                $('conflictNewFile').textContent = newFileName;

                // Generate and display change log
                const changeLog = generateChangeLog(fileType, oldData, newData);
                $('conflictChangeLog').innerHTML = changeLog.join('');

                // Show Smart Merge button only for MVR files with fixture data
                if (fileType === 'mvr' && pendingMVRChanges) {
                    smartMergeBtn.style.display = 'inline-flex';
                } else {
                    smartMergeBtn.style.display = 'none';
                }

                // Store pending conflict for confirmation
                pendingFileConflict = {
                    fileType: fileType,
                    newData: newData,
                    newFileName: newFileName,
                    oldData: oldData
                };

                modal.style.display = 'flex';
            }

            function cancelFileConflict() {
                const modal = $('fileConflictModal');
                modal.style.display = 'none';
                pendingFileConflict = null;
            }

            function confirmFileOverwrite() {
                const modal = $('fileConflictModal');
                modal.style.display = 'none';

                if (!pendingFileConflict) return;

                const { fileType, newData } = pendingFileConflict;

                // Apply the new data
                uploadedFiles[fileType] = newData;

                // Reload the project with new data
                if (fileType === 'json') {
                    loadLXData(newData);
                } else {
                    const mergedData = mergeFileData(uploadedFiles);
                    loadLXData(mergedData);
                }

                // Update TSV reference if applicable
                if (fileType === 'tsv') {
                    projectData.tsvReference = newData;
                    updateTSVDependentUI();
                    applyTSVMappingToFixtures(projectData.fixtures, newData);
                }

                // Update checklist
                updateFileChecklist(uploadedFiles);

                pendingFileConflict = null;
                pendingMVRChanges = null;
            }

            function confirmSmartMerge() {
                const modal = $('fileConflictModal');
                modal.style.display = 'none';

                if (!pendingFileConflict || !pendingMVRChanges) {
                    console.error('Smart merge called without pending data');
                    return;
                }

                const { newData, oldData } = pendingFileConflict;
                const { addedList, removedList, modifiedList } = pendingMVRChanges;

                console.log('Smart Merge:', {
                    added: addedList.length,
                    removed: removedList.length,
                    modified: modifiedList.length
                });

                // Create a map of existing fixtures by UUID/Position for cable lookup
                const currentFixtures = projectData.fixtures || [];
                const fixtureConnectionMap = new Map();

                // Build map of which fixtures have cable connections
                const powerConnections = projectData.connections?.power || [];
                const dataConnections = projectData.connections?.data || [];

                currentFixtures.forEach((fixture, index) => {
                    const key = fixture.UUID || fixture.Position || fixture['Fixture ID'];
                    const connections = {
                        power: powerConnections.filter(c =>
                            c.source === fixture.Position ||
                            c.destination === fixture.Position ||
                            c.sourceFixture === key ||
                            c.destinationFixture === key
                        ),
                        data: dataConnections.filter(c =>
                            c.source === fixture.Position ||
                            c.destination === fixture.Position ||
                            c.sourceFixture === key ||
                            c.destinationFixture === key
                        )
                    };

                    if (connections.power.length > 0 || connections.data.length > 0) {
                        fixtureConnectionMap.set(key, connections);
                    }
                });

                // Build merged fixture list
                const mergedFixtures = [];
                const newFixtureMap = new Map((newData.fixtures || []).map(f => [f.UUID || f.Position, f]));

                // Process each fixture from the old data
                currentFixtures.forEach(oldFixture => {
                    const key = oldFixture.UUID || oldFixture.Position || oldFixture['Fixture ID'];
                    const newFixture = newFixtureMap.get(key);

                    if (newFixture) {
                        // Fixture still exists - update with new data but preserve custom fields
                        const merged = { ...newFixture };

                        // Preserve any cable planning annotations or custom notes
                        if (oldFixture._cableNotes) merged._cableNotes = oldFixture._cableNotes;
                        if (oldFixture._powerOverride) merged._powerOverride = oldFixture._powerOverride;

                        mergedFixtures.push(merged);
                        newFixtureMap.delete(key); // Mark as processed
                    } else {
                        // Fixture was removed - keep it if it has cable connections
                        const hasConnections = fixtureConnectionMap.has(key);
                        if (hasConnections) {
                            // Mark as removed but keep for cable reference
                            oldFixture._removed = true;
                            oldFixture._removedNote = 'Fixture removed from MVR but kept for cable planning';
                            mergedFixtures.push(oldFixture);
                            console.log('Preserving removed fixture with cables:', key);
                        }
                    }
                });

                // Add any new fixtures that weren't in the old data
                newFixtureMap.forEach(newFixture => {
                    mergedFixtures.push(newFixture);
                });

                // Update the MVR data with merged fixtures
                const smartMergedData = {
                    ...newData,
                    fixtures: mergedFixtures
                };

                // Apply the smart merged data
                uploadedFiles.mvr = smartMergedData;

                // Reload the project with smart merged data
                const finalMergedData = mergeFileData(uploadedFiles);
                loadLXData(finalMergedData);

                // Update checklist
                updateFileChecklist(uploadedFiles);

                // Show success message
                console.log('Smart merge complete:', {
                    totalFixtures: mergedFixtures.length,
                    preserved: currentFixtures.length - removedList.length,
                    added: addedList.length,
                    removed: removedList.length,
                    modified: modifiedList.length
                });

                // TODO: Add toast notification
                // showToast('Smart Merge Complete', `Preserved ${currentFixtures.length - removedList.length} fixtures, added ${addedList.length} new`);

                pendingFileConflict = null;
                pendingMVRChanges = null;
            }

            // ============================================
            // DOM References
            // ============================================
            const $ = (id) => document.getElementById(id);

            const fileInput = $("fileInput");
            const folderInput = $("folderInput");
            const fileStatus = $("fileStatus");
            const themeToggle = $("themeToggle");

            const mergeBtn = $("mergeBtn");
            const saveProjectBtn = $("saveProjectBtn");
            const exportGearPdfBtn = $("exportGearPdfBtn");
            const exportCablePdfBtn = $("exportCablePdfBtn");
            const undoBtn = $("undoBtn");
            const redoBtn = $("redoBtn");

            function showToast(message, duration = 2500) {
                const toast = $('toast');
                if (!toast) return;
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), duration);
            }

            // ============================================
            // File Input & Drag-Drop
            // ============================================
            fileInput.addEventListener("change", handleFileUpload);
            folderInput.addEventListener("change", handleFileUpload);
            undoBtn.addEventListener("click", undo);
            redoBtn.addEventListener("click", redo);

            // Drag and drop support
            const dropZone = document.querySelector('.card');

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');

                const items = e.dataTransfer.items;
                const files = [];

                // Process all dropped items (files and folders)
                for (let i = 0; i < items.length; i++) {
                    const item = items[i].webkitGetAsEntry();
                    if (item) {
                        await traverseFileTree(item, files);
                    }
                }

                console.log("Dropped files:", files.length);

                // Create a mock event with the files
                const mockEvent = {
                    target: {
                        files: files
                    }
                };

                handleFileUpload(mockEvent);
            });

            async function traverseFileTree(item, files) {
                if (item.isFile) {
                    return new Promise((resolve) => {
                        item.file((file) => {
                            // Only add supported file types
                            const ext = file.name.toLowerCase().split('.').pop();
                            if (ext === 'mvr' || ext === 'xml' || ext === 'zip' ||
                                ext === 'txt' || ext === 'json' || ext === 'tsv') {
                                files.push(file);
                            }
                            resolve();
                        });
                    });
                } else if (item.isDirectory) {
                    const dirReader = item.createReader();
                    return new Promise((resolve) => {
                        dirReader.readEntries(async (entries) => {
                            for (let entry of entries) {
                                await traverseFileTree(entry, files);
                            }
                            resolve();
                        });
                    });
                }
            }

            async function handleFileUpload(e) {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                console.log("Files selected:", files.length);

                // Categorize files by extension
                const mvrFiles = [];
                const txtFiles = [];
                const jsonFiles = [];
                const tsvFiles = [];

                for (let file of files) {
                    const ext = file.name.toLowerCase().split('.').pop();
                    console.log("Processing file:", file.name, "extension:", ext);
                    if (ext === 'mvr' || ext === 'xml' || ext === 'zip') mvrFiles.push(file);
                    else if (ext === 'txt') txtFiles.push(file);
                    else if (ext === 'json') jsonFiles.push(file);
                    else if (ext === 'tsv') tsvFiles.push(file);
                }

                console.log("Categorized - MVR:", mvrFiles.length, "TXT:", txtFiles.length, "JSON:", jsonFiles.length, "TSV:", tsvFiles.length);

                // Check for conflicts before processing
                const conflicts = [];
                if (mvrFiles.length > 0 && uploadedFiles.mvr) {
                    conflicts.push({ type: 'mvr', file: mvrFiles[0], oldData: uploadedFiles.mvr });
                }
                if (txtFiles.length > 0 && uploadedFiles.txt) {
                    conflicts.push({ type: 'txt', file: txtFiles[0], oldData: uploadedFiles.txt });
                }
                if (jsonFiles.length > 0 && uploadedFiles.json) {
                    conflicts.push({ type: 'json', file: jsonFiles[0], oldData: uploadedFiles.json });
                }
                if (tsvFiles.length > 0 && uploadedFiles.tsv) {
                    conflicts.push({ type: 'tsv', file: tsvFiles[0], oldData: uploadedFiles.tsv });
                }

                // If conflicts detected, handle them one at a time
                if (conflicts.length > 0) {
                    const conflict = conflicts[0];
                    let newData;

                    try {
                        // Process the new file to compare
                        if (conflict.type === 'mvr') {
                            newData = await processMVRFile(conflict.file);
                        } else if (conflict.type === 'txt') {
                            newData = await processTXTFile(conflict.file);
                        } else if (conflict.type === 'json') {
                            newData = await processJSONFile(conflict.file);
                        } else if (conflict.type === 'tsv') {
                            newData = await processTSVFile(conflict.file);
                        }

                        // Get old filename
                        const oldFileName = conflict.oldData.originalFileName ||
                                          conflict.oldData.fileName ||
                                          'current file';

                        // Show conflict modal
                        showFileConflictModal(
                            conflict.type,
                            oldFileName,
                            conflict.file.name,
                            conflict.oldData,
                            newData
                        );

                        // Exit - user will confirm via modal
                        return;

                    } catch (error) {
                        console.error("Error processing file for conflict check:", error);
                        alert("Error processing file: " + error.message);
                        return;
                    }
                }

                let hasError = false;

                // Process MVR file (if present) and store in persistent state
                if (mvrFiles.length > 0) {
                    if (mvrFiles.length > 1) {
                        alert("Warning: Multiple MVR files detected. Using the first one.");
                    }
                    try {
                        console.log("Starting MVR processing...");
                        uploadedFiles.mvr = await processMVRFile(mvrFiles[0]);
                        console.log("MVR file processed successfully:", uploadedFiles.mvr);
                    } catch (mvrError) {
                        console.error("MVR processing error:", mvrError);
                        alert("Error processing MVR file: " + mvrError.message);
                        hasError = true;
                        updateFileChecklist(uploadedFiles);
                        return; // Stop processing if MVR fails
                    }
                }

                // Process TXT file (if present) and store in persistent state
                if (txtFiles.length > 0) {
                    if (txtFiles.length > 1) {
                        alert("Warning: Multiple TXT files detected. Using the first one.");
                    }
                    try {
                        uploadedFiles.txt = await processTXTFile(txtFiles[0]);
                        console.log("TXT file processed successfully");
                    } catch (txtError) {
                        console.error("TXT processing error:", txtError);
                        alert("Error processing TXT file: " + txtError.message);
                    }
                }

                // Process JSON file (if present) and store in persistent state
                if (jsonFiles.length > 0) {
                    if (jsonFiles.length > 1) {
                        alert("Warning: Multiple JSON files detected. Using the first one.");
                    }
                    try {
                        uploadedFiles.json = await processJSONFile(jsonFiles[0]);
                        console.log("JSON file processed successfully");
                    } catch (jsonError) {
                        console.error("JSON processing error:", jsonError);
                        alert("Error processing JSON file: " + jsonError.message);
                    }
                }

                // Process TSV file (if present) and store in persistent state
                if (tsvFiles.length > 0) {
                    if (tsvFiles.length > 1) {
                        alert("Warning: Multiple TSV files detected. Using the first one.");
                    }
                    try {
                        uploadedFiles.tsv = await processTSVFile(tsvFiles[0]);
                        console.log("TSV file processed successfully");
                    } catch (tsvError) {
                        console.error("TSV processing error:", tsvError);
                        alert("Error processing TSV file: " + tsvError.message);
                    }
                }

                // Load data if we have either JSON or MVR files
                console.log("Validation check - MVR:", !!uploadedFiles.mvr, "JSON:", !!uploadedFiles.json);

                if (uploadedFiles.json) {
                    // JSON save file is provided, restore state first
                    loadLXData(uploadedFiles.json);

                    // If MVR or TXT are also provided, merge/update the data
                    if (uploadedFiles.mvr || uploadedFiles.txt) {
                        const mergedData = mergeFileData(uploadedFiles);
                        loadLXData(mergedData);
                    }
                } else if (uploadedFiles.mvr) {
                    // No JSON, but we have MVR - combine MVR + TXT data
                    const mergedData = mergeFileData(uploadedFiles);
                    loadLXData(mergedData);
                }
                // If only TXT or TSV is uploaded, just store it and update UI
                // The user will see the prompt to upload the missing files

                // Store TSV reference (but don't embed it in project data)
                if (uploadedFiles.tsv) {
                    projectData.tsvReference = uploadedFiles.tsv;
                }

                // Update file checklist UI with persistent state
                updateFileChecklist(uploadedFiles);

                // Update TSV-dependent UI elements
                updateTSVDependentUI();

                if (uploadedFiles.tsv) {
                    applyTSVMappingToFixtures(projectData.fixtures, uploadedFiles.tsv);
                }

                // Refresh stats for partial file loads (e.g., TXT only)
                updateStats();
            }

            function handleTSVUpload(e) {
                // Delegate to main file upload handler
                handleFileUpload(e);
            }

            function updateTSVDependentUI() {
                const hasTSV = !!uploadedFiles.tsv;
                const hasMVR = !!uploadedFiles.mvr;
                const hasTXT = !!uploadedFiles.txt;
                const hasMVRandTXT = hasMVR && hasTXT;

                // Power Distribution presets (requires TSV)
                const pdTSVPrompt = $('pdTSVPrompt');
                const pdPresetSelection = $('pdPresetSelection');

                if (pdTSVPrompt && pdPresetSelection) {
                    if (hasTSV) {
                        pdTSVPrompt.style.display = 'none';
                        pdPresetSelection.style.display = 'block';
                    } else {
                        pdTSVPrompt.style.display = 'block';
                        pdPresetSelection.style.display = 'block';
                    }
                }

                if (pdPresetSelection) {
                    const presetButtons = pdPresetSelection.querySelectorAll('.pd-preset-btn');
                    const presetHint = $('pdPresetHint');
                    presetButtons.forEach((button) => {
                        const presetValue = button.dataset.preset;
                        if (!hasTSV && presetValue !== 'custom') {
                            button.classList.add('disabled');
                        } else {
                            button.classList.remove('disabled');
                        }
                    });
                    if (presetHint) {
                        presetHint.style.display = hasTSV ? 'none' : 'block';
                    }
                }

                // Data Distribution presets (requires TSV)
                const ddTSVPrompt = $('ddTSVPrompt');

                if (ddTSVPrompt) {
                    if (hasTSV) {
                        ddTSVPrompt.style.display = 'none';
                    } else {
                        ddTSVPrompt.style.display = 'block';
                    }
                }

                const ddDeviceSelection = $('ddDeviceSelection');
                if (ddDeviceSelection) {
                    const presetButtons = ddDeviceSelection.querySelectorAll('.dd-preset-btn');
                    const presetHint = $('ddPresetHint');
                    presetButtons.forEach((button) => {
                        const presetValue = button.dataset.preset;
                        if (!hasTSV && presetValue !== 'custom') {
                            button.classList.add('disabled');
                        } else {
                            button.classList.remove('disabled');
                        }
                    });
                    if (presetHint) {
                        presetHint.style.display = hasTSV ? 'none' : 'block';
                    }
                }

                // BOH Stats sidebar visibility is now controlled by updateStats()

                // FOH Console Selection (requires MVR and TXT)
                const fohConsolePrompt = $('fohConsolePrompt');
                const fohConsoleSelection = $('fohConsoleSelection');
                const fohConsolePromptIcon = $('fohConsolePromptIcon');
                const fohConsolePromptTitle = $('fohConsolePromptTitle');

                if (fohConsolePrompt && fohConsoleSelection) {
                    if (hasMVRandTXT) {
                        fohConsolePrompt.style.display = 'none';
                        fohConsoleSelection.style.display = 'grid';
                    } else {
                        fohConsolePrompt.style.display = 'block';
                        fohConsoleSelection.style.display = 'none';

                        // Update prompt based on what's missing
                        if (fohConsolePromptIcon && fohConsolePromptTitle) {
                            if (!hasMVR && !hasTXT) {
                                fohConsolePromptIcon.textContent = 'üî¥üü¢';
                                fohConsolePromptTitle.textContent = 'Upload MVR & TXT using toolbar above';
                            } else if (!hasMVR) {
                                fohConsolePromptIcon.textContent = 'üî¥';
                                fohConsolePromptTitle.textContent = 'Upload MVR using toolbar above';
                            } else if (!hasTXT) {
                                fohConsolePromptIcon.textContent = 'üü¢';
                                fohConsolePromptTitle.textContent = 'Upload TXT using toolbar above';
                            }
                        }
                    }
                }
            }

            function updateFileChecklist(fileData, isAutoSave = false) {
                console.log("updateFileChecklist called with:", fileData);

                const checkMVR = $("checkMVR");
                const checkTXT = $("checkTXT");
                const checkTSV = $("checkTSV");
                const checkJSON = $("checkJSON");
                const jsonDownloadBtn = $("jsonDownloadBtn");
                const jsonAutoSaveMsg = $("jsonAutoSaveMsg");

                // Check if all required elements exist
                if (!checkMVR || !checkTXT || !checkTSV || !checkJSON) {
                    console.error("Checklist elements not found");
                    return;
                }

                console.log("Has MVR:", !!fileData.mvr);
                console.log("Has TXT:", !!fileData.txt);
                console.log("Has TSV:", !!fileData.tsv);
                console.log("Has JSON:", !!fileData.json);

                // Update MVR checkbox
                const mvrCheckbox = checkMVR.querySelector(".check-box");
                if (fileData.mvr && fileData.mvr.fixtures) {
                    checkMVR.classList.add("loaded");
                    if (mvrCheckbox) mvrCheckbox.textContent = "‚òë";
                    console.log("MVR checkbox checked");
                } else {
                    checkMVR.classList.remove("loaded");
                    if (mvrCheckbox) mvrCheckbox.textContent = "‚òê";
                    console.log("MVR checkbox unchecked");
                }

                // Update TXT checkbox
                const txtCheckbox = checkTXT.querySelector(".check-box");
                if (fileData.txt && fileData.txt.fixtures) {
                    checkTXT.classList.add("loaded");
                    if (txtCheckbox) txtCheckbox.textContent = "‚òë";
                    console.log("TXT checkbox checked");
                } else {
                    checkTXT.classList.remove("loaded");
                    if (txtCheckbox) txtCheckbox.textContent = "‚òê";
                    console.log("TXT checkbox unchecked");
                }

                // Update TSV checkbox
                const tsvCheckbox = checkTSV.querySelector(".check-box");
                if (fileData.tsv) {
                    checkTSV.classList.add("loaded");
                    if (tsvCheckbox) tsvCheckbox.textContent = "‚òë";
                    console.log("TSV checkbox checked");
                } else {
                    checkTSV.classList.remove("loaded");
                    if (tsvCheckbox) tsvCheckbox.textContent = "‚òê";
                    console.log("TSV checkbox unchecked");
                }

                // Update JSON checkbox
                const jsonCheckbox = checkJSON.querySelector(".check-box");
                if (fileData.json) {
                    checkJSON.classList.add("loaded");
                    if (jsonCheckbox) jsonCheckbox.textContent = "‚òë";
                    if (jsonDownloadBtn) jsonDownloadBtn.style.display = "inline-block";
                    if (jsonAutoSaveMsg) {
                        jsonAutoSaveMsg.style.display = isAutoSave ? "block" : "none";
                    }
                    console.log("JSON checkbox checked");
                } else {
                    checkJSON.classList.remove("loaded");
                    if (jsonCheckbox) jsonCheckbox.textContent = "‚òê";
                    if (jsonDownloadBtn) jsonDownloadBtn.style.display = "none";
                    if (jsonAutoSaveMsg) jsonAutoSaveMsg.style.display = "none";
                    console.log("JSON checkbox unchecked");
                }
            }

            async function processMVRFile(file) {
                const ext = file.name.toLowerCase().split('.').pop();
                let xmlText;

                if (ext === 'xml') {
                    // Direct XML file - read it directly
                    console.log("Processing direct XML file");
                    xmlText = await file.text();
                } else {
                    // MVR file (ZIP archive) - extract GeneralSceneDescription.xml
                    console.log("Processing MVR (ZIP) file");
                    const arrayBuffer = await file.arrayBuffer();

                    // Open the .mvr file as a ZIP archive
                    const zip = await JSZip.loadAsync(arrayBuffer);

                    // Locate GeneralSceneDescription.xml
                    const xmlFile = zip.file("GeneralSceneDescription.xml");
                    if (!xmlFile) {
                        throw new Error("GeneralSceneDescription.xml not found in MVR file");
                    }

                    // Extract the XML content
                    xmlText = await xmlFile.async("text");
                }

                // Parse XML and convert to expected format
                return parseXMLToLXData(xmlText, file.name);
            }

            async function processTXTFile(file) {
                const text = await file.text();
                const lines = text.split('\n').filter(line => line.trim());

                if (lines.length === 0) {
                    return {
                        fileName: file.name,
                        fixtures: []
                    };
                }

                // First line should be headers
                const headers = lines[0].split('\t');
                const fixtures = [];

                // Parse each data line (skip header)
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split('\t');
                    const fixture = {};

                    // Map each column to its header
                    headers.forEach((header, index) => {
                        fixture[header.trim()] = values[index] ? values[index].trim() : '';
                    });

                    fixtures.push(fixture);
                }

                return {
                    fileName: file.name,
                    fixtures: fixtures
                };
            }

            async function processJSONFile(file) {
                const text = await file.text();
                try {
                    return JSON.parse(text);
                } catch (err) {
                    throw new Error("Invalid JSON save file: " + err.message);
                }
            }

            async function processTSVFile(file) {
                const text = await file.text();
                const lines = text.split('\n');
                const data = [];
                let headers = [];

                // Parse TSV format
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const columns = line.split('\t');
                    if (i === 0) {
                        // First line might be headers
                        headers = columns.map(header => header.trim());
                    } else {
                        data.push(columns);
                    }
                }

                const items = data.map(row => {
                    const item = {};
                    headers.forEach((header, index) => {
                        item[header] = row[index] ? row[index].trim() : '';
                    });
                    return item;
                });

                return {
                    fileName: file.name,
                    headers: headers,
                    data: data,
                    items: items,
                    // Don't store raw text to keep it external
                };
            }

            function normalizeMatchString(value) {
                if (!value) return '';
                return value
                    .toLowerCase()
                    .replace(/[^a-z0-9\\s]/g, ' ')
                    .replace(/\\s+/g, ' ')
                    .trim();
            }

            function tokenizeMatchString(value) {
                const normalized = normalizeMatchString(value);
                if (!normalized) return [];
                return normalized.split(' ').filter(Boolean);
            }

            function scoreFixtureMatch(txtName, tsvItem) {
                const nameTokens = new Set(tokenizeMatchString(txtName));
                const tsvName = tsvItem?.Name || '';
                const tsvManufacturer = tsvItem?.Manufacturer || '';
                const tsvVariant = tsvItem?.Variant || '';
                const tsvTokens = new Set([
                    ...tokenizeMatchString(tsvName),
                    ...tokenizeMatchString(tsvManufacturer),
                    ...tokenizeMatchString(tsvVariant)
                ]);

                if (nameTokens.size === 0 || tsvTokens.size === 0) return 0;

                let overlap = 0;
                nameTokens.forEach(token => {
                    if (tsvTokens.has(token)) overlap += 1;
                });

                const overlapScore = overlap / Math.max(nameTokens.size, 1);
                const manufacturerBonus = tsvManufacturer &&
                    tokenizeMatchString(txtName).includes(normalizeMatchString(tsvManufacturer))
                    ? 0.15
                    : 0;

                return Math.min(1, overlapScore + manufacturerBonus);
            }

            function getFixtureTypeKey(fixture) {
                return fixture['Instrument Type'] ||
                    fixture['Fixture Type'] ||
                    fixture['Device Type'] ||
                    '';
            }

            function applyTSVMappingToFixtures(fixtures, tsvData) {
                if (!Array.isArray(fixtures) || !tsvData || !Array.isArray(tsvData.items)) return;

                const mapping = projectData.fixtureTypeMap || {};
                const unmatched = new Set();
                const suggestions = projectData.fixtureTypeSuggestions || {};

                fixtures.forEach(fixture => {
                    const fixtureType = getFixtureTypeKey(fixture);
                    if (!fixtureType) return;

                    const mapped = mapping[fixtureType];
                    if (mapped) {
                        fixture.tsvMatch = mapped;
                        return;
                    }

                    let best = null;
                    let bestScore = 0;
                    let secondBest = 0;
                    const ranked = [];

                    tsvData.items.forEach(item => {
                        const score = scoreFixtureMatch(fixtureType, item);
                        if (score > 0) {
                            ranked.push({ item, score });
                        }
                        if (score > bestScore) {
                            secondBest = bestScore;
                            bestScore = score;
                            best = item;
                        } else if (score > secondBest) {
                            secondBest = score;
                        }
                    });

                    if (best && bestScore >= 0.5 && (bestScore - secondBest) >= 0.1) {
                        const mappedEntry = {
                            DeviceID: best.DeviceID || '',
                            Name: best.Name || '',
                            Manufacturer: best.Manufacturer || '',
                            Variant: best.Variant || '',
                            DeviceType: best.DeviceType || ''
                        };
                        mapping[fixtureType] = mappedEntry;
                        fixture.tsvMatch = mappedEntry;
                    } else if (best && bestScore >= 0.2) {
                        ranked.sort((a, b) => b.score - a.score);
                        suggestions[fixtureType] = ranked.slice(0, 3).map(entry => ({
                            score: Number(entry.score.toFixed(2)),
                            DeviceID: entry.item.DeviceID || '',
                            Name: entry.item.Name || '',
                            Manufacturer: entry.item.Manufacturer || '',
                            Variant: entry.item.Variant || '',
                            DeviceType: entry.item.DeviceType || ''
                        }));
                        unmatched.add(fixtureType);
                    } else {
                        unmatched.add(fixtureType);
                    }
                });

                projectData.fixtureTypeMap = mapping;
                projectData.fixtureTypeSuggestions = suggestions;
                projectData.unmappedFixtureTypes = Array.from(unmatched);
            }

            function mergeFileData(fileData) {
                let mergedData = {};

                // Start with MVR data if available
                if (fileData.mvr) {
                    mergedData = { ...fileData.mvr };
                }

                // Intelligently merge TXT data with MVR data
                if (fileData.txt && fileData.txt.fixtures && fileData.mvr && fileData.mvr.fixtures) {
                    const mvrFixtures = fileData.mvr.fixtures;
                    const txtFixtures = fileData.txt.fixtures;

                    // Create a merged fixtures array
                    const mergedFixtures = [];

                    // Build lookup maps for efficient matching
                    const txtByPosition = new Map();
                    const txtByFixtureId = new Map();
                    const txtByUID = new Map();

                    txtFixtures.forEach(txtFix => {
                        const uidValue = txtFix.__UID || txtFix.UID || txtFix.UUID;
                        if (uidValue) {
                            txtByUID.set(String(uidValue).trim(), txtFix);
                        }
                        if (txtFix.Position) {
                            txtByPosition.set(txtFix.Position.trim().toLowerCase(), txtFix);
                        }
                        if (txtFix["Fixture ID"]) {
                            txtByFixtureId.set(txtFix["Fixture ID"].trim(), txtFix);
                        }
                    });

                    // Merge each MVR fixture with matching TXT fixture
                    mvrFixtures.forEach(mvrFix => {
                        let txtMatch = null;
                        const mvrUID = mvrFix.UUID || mvrFix.__UID || mvrFix.UID;

                        // Try to match by UID first
                        if (mvrUID) {
                            txtMatch = txtByUID.get(String(mvrUID).trim());
                        }

                        // If no match by UID, try Position
                        if (!txtMatch && mvrFix.Position) {
                            txtMatch = txtByPosition.get(mvrFix.Position.trim().toLowerCase());
                        }

                        // If no match by Position, try Fixture ID
                        if (!txtMatch && mvrFix["Fixture ID"]) {
                            txtMatch = txtByFixtureId.get(mvrFix["Fixture ID"].trim());
                        }

                        // Merge the data - TXT data takes precedence for overlapping fields
                        const merged = txtMatch ? { ...mvrFix, ...txtMatch } : { ...mvrFix };
                        mergedFixtures.push(merged);
                    });

                    // Add any TXT fixtures that didn't match an MVR fixture
                    txtFixtures.forEach(txtFix => {
                        const uidMatch = (txtFix.__UID || txtFix.UID || txtFix.UUID) &&
                            mvrFixtures.some(m => {
                                const mvrUID = m.UUID || m.__UID || m.UID;
                                return mvrUID && String(mvrUID).trim() === String(txtFix.__UID || txtFix.UID || txtFix.UUID).trim();
                            });
                        const positionMatch = txtFix.Position &&
                            mvrFixtures.some(m => m.Position &&
                                m.Position.trim().toLowerCase() === txtFix.Position.trim().toLowerCase());
                        const idMatch = txtFix["Fixture ID"] &&
                            mvrFixtures.some(m => m["Fixture ID"] &&
                                m["Fixture ID"].trim() === txtFix["Fixture ID"].trim());

                        if (!uidMatch && !positionMatch && !idMatch) {
                            mergedFixtures.push({ ...txtFix });
                        }
                    });

                    mergedData.fixtures = mergedFixtures;
                } else if (fileData.txt && fileData.txt.fixtures) {
                    // Only TXT data available
                    mergedData.fixtures = fileData.txt.fixtures;
                    if (fileData.txt.fileName) {
                        mergedData.originalFileName = fileData.txt.fileName.replace('.txt', '');
                    }
                }

                // If JSON was provided, it takes precedence for existing fields
                if (fileData.json) {
                    mergedData = { ...mergedData, ...fileData.json };
                }

                return mergedData;
            }

            function parseXMLToLXData(xmlText, fileName) {
                // Parse XML string to DOM
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                // Check for parsing errors
                const parseError = xmlDoc.querySelector("parsererror");
                if (parseError) {
                    throw new Error("XML parsing failed: " + parseError.textContent);
                }

                // Extract fixtures from XML - search for SceneObject elements
                const fixtures = [];
                const sceneObjects = xmlDoc.querySelectorAll("SceneObject");

                sceneObjects.forEach((sceneObject) => {
                    const name = sceneObject.getAttribute("name") || "";
                    const uuid = sceneObject.getAttribute("uuid") || "";

                    // Get fixture type from GDTFSpec
                    const gdtfSpec = sceneObject.querySelector("GDTFSpec");
                    let fixtureTypeName = "";
                    if (gdtfSpec) {
                        fixtureTypeName = gdtfSpec.textContent || gdtfSpec.getAttribute("name") || "";
                    }

                    // Get addresses (DMX universe/address)
                    const addresses = sceneObject.querySelector("Addresses");
                    let universeAddress = "";
                    if (addresses) {
                        const address = addresses.querySelector("Address");
                        if (address) {
                            const universe = address.getAttribute("Universe") || "1";
                            const dmxAddress = address.textContent || "1";
                            universeAddress = `${universe}/${dmxAddress}`;
                        }
                    }

                    // Get position data from Matrix element
                    const matrix = sceneObject.querySelector("Matrix");
                    let positionData = "";
                    let posX = "0", posY = "0", posZ = "0";
                    if (matrix) {
                        // Matrix format: {u1,u2,u3,u4}{v1,v2,v3,v4}{w1,w2,w3,w4}{x,y,z,1}
                        // We want the translation components (x, y, z) from the last row
                        const matrixText = matrix.textContent || "";
                        const matrixMatch = matrixText.match(/\{([^}]+)\}\{([^}]+)\}\{([^}]+)\}\{([^}]+)\}/);
                        if (matrixMatch && matrixMatch[4]) {
                            const translation = matrixMatch[4].split(',');
                            posX = translation[0] || "0";
                            posY = translation[1] || "0";
                            posZ = translation[2] || "0";
                            positionData = `${posX},${posY},${posZ}`;
                        }
                    }

                    // Get custom ID/channel/fixture ID
                    const customId = sceneObject.querySelector("CustomId")?.textContent || "";
                    const channelId = sceneObject.querySelector("ChannelId")?.textContent || "";
                    const fixtureId = sceneObject.querySelector("FixtureID")?.textContent || "";

                    // Get circuit information
                    const circuitName = sceneObject.querySelector("CircuitName")?.textContent ||
                                       sceneObject.querySelector("Circuit")?.textContent || "-";
                    const circuitNumber = sceneObject.querySelector("CircuitNumber")?.textContent ||
                                         sceneObject.querySelector("Circuit")?.getAttribute("number") || "";

                    // Get wattage if available
                    const wattage = sceneObject.querySelector("Wattage")?.textContent ||
                                   sceneObject.querySelector("Power")?.textContent || "";

                    // Get purpose/function
                    const purpose = sceneObject.querySelector("Purpose")?.textContent ||
                                   sceneObject.querySelector("Function")?.textContent || "";

                    // Create fixture object matching expected format
                    const fixture = {
                        "Instrument Type": fixtureTypeName,
                        "Fixture Type": fixtureTypeName,
                        "Position": name,
                        "Fixture ID": fixtureId || customId || "",
                        "Channel": channelId || "",
                        "Universe/Address": universeAddress,
                        "Circuit Name": circuitName,
                        "Circuit Number": circuitNumber,
                        "Wattage": wattage,
                        "Purpose": purpose,
                        "UUID": uuid,
                        "PositionX": posX,
                        "PositionY": posY,
                        "PositionZ": posZ,
                        "Custom Data": positionData
                    };

                    fixtures.push(fixture);
                });

                // Return data in the format expected by loadLXData
                return {
                    originalFileName: fileName.replace('.mvr', ''),
                    fixtures: fixtures
                };
            }

            function loadLXData(data) {
                // Import fixtures and headers from LX Data Entry Tool
                projectData.showName = data.originalFileName || "Untitled Show";
                projectData.fixtures = data.fixtures || [];

                if (data.sourceFiles) {
                    uploadedFiles.mvr = data.sourceFiles.mvr || uploadedFiles.mvr;
                    uploadedFiles.txt = data.sourceFiles.txt || uploadedFiles.txt;
                    uploadedFiles.tsv = data.sourceFiles.tsv || uploadedFiles.tsv;
                }

                // Parse unique MULTs from Circuit Name
                const multNamesSet = new Set();
                const universesSet = new Set();

                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        // Skip null/undefined fixtures
                        if (!fixture) return;

                        // Count unique MULT names
                        const circuitName = fixture['Circuit Name'];
                        if (circuitName && circuitName !== '-' && circuitName.trim() !== '') {
                            multNamesSet.add(circuitName);
                        }

                        // Count unique universes
                        const universeAddress = fixture['Universe/Address'];
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                universesSet.add(parseInt(universePart));
                            }
                        }
                    });
                }

                const totalUniverses = universesSet.size;

                // Update UI
                fileStatus.innerHTML = `
                    <span class="file-status-dot"></span>
                    ${projectData.showName} (${projectData.fixtures.length} fixtures, ${multNamesSet.size} MULTs, ${totalUniverses} universes)
                `;

                // Enable buttons
                mergeBtn.disabled = false;
                saveProjectBtn.disabled = false;
                exportGearPdfBtn.disabled = false;
                exportCablePdfBtn.disabled = false;

                // Apply TSV mapping when inventory is available
                if (uploadedFiles.tsv) {
                    applyTSVMappingToFixtures(projectData.fixtures, uploadedFiles.tsv);
                }

                // Recompute assignments and refresh BOH cards after fixture changes
                autoAssignCircuits();
                autoAssignUniverses();
                renderPDs();
                renderDDs();
                renderConnections();
                updateStats();

                updateFileChecklist(uploadedFiles, true);
                updateTSVDependentUI();

                // Open BOH section
                openSection('boh');

                console.log("Loaded LX data:", projectData);
                console.log("Detected MULTs:", Array.from(multNamesSet).sort());
                console.log("Detected universes:", Array.from(universesSet).sort((a, b) => a - b));

                // Check if we need to show data mode selection
                if (totalUniverses >= 4) {
                    // Auto-select Network Mode for 4+ universes
                    selectDataMode('network');
                } else if (totalUniverses > 0 && !projectData.dataMode) {
                    // Show inline mode selection for < 4 universes
                    const dataModeSelection = $('dataModeSelection');
                    const addDDBtn = $('addDDBtn');
                    if (dataModeSelection) dataModeSelection.style.display = 'block';
                    if (addDDBtn) addDDBtn.style.display = 'none';
                }
            }

            // ============================================
            // Section Management with Guided Flow
            // ============================================
            function toggleSection(sectionName) {
                const section = $(`${sectionName}Section`);
                const wasExpanded = section.classList.contains('expanded');

                // Close all sections first (guided flow - only one open at a time)
                closeAllSections();

                // If it wasn't expanded, expand it now
                if (!wasExpanded) {
                    section.classList.add('expanded');
                    projectData.activeSection = sectionName;
                    updateSectionProgress();
                    updateSidebarForSection(sectionName);

                    // Render connections when connections section is opened
                    if (sectionName === 'connections') {
                        renderConnections();
                    }

                    // Render diagram when diagram section is opened
                    if (sectionName === 'diagram') {
                        renderRoutingDiagram();
                    }
                } else {
                    projectData.activeSection = null;
                }

                markProjectUpdated();
            }

            function openSection(sectionName) {
                // Close all other sections
                closeAllSections();

                // Open the requested section
                const section = $(`${sectionName}Section`);
                section.classList.add('expanded');
                projectData.activeSection = sectionName;

                updateSectionProgress();
                updateSidebarForSection(sectionName);
                markProjectUpdated();
            }

            function closeAllSections() {
                document.querySelectorAll('.section-card').forEach(card => {
                    card.classList.remove('expanded');
                });
            }

            function updateSectionProgress() {
                // Update progress indicators at top
                const bohComplete = validateBOHSection();
                const fohComplete = validateFOHSection();
                const connectionsComplete = validateConnectionsSection();

                // Update progress steps
                updateProgressStep('progressBOH', 'boh', bohComplete);
                updateProgressStep('progressFOH', 'foh', fohComplete);
                updateProgressStep('progressConnections', 'connections', connectionsComplete);
                updateProgressStep('progressExport', 'export', bohComplete && fohComplete);

                // Update section headers with status icons
                updateSectionHeader('boh', bohComplete);
                updateSectionHeader('foh', fohComplete);
                updateSectionHeader('connections', connectionsComplete);
            }

            function updateProgressStep(elementId, sectionName, isComplete) {
                const el = $(elementId);
                el.classList.remove('active', 'complete');

                if (isComplete) {
                    el.classList.add('complete');
                } else if (projectData.activeSection === sectionName) {
                    el.classList.add('active');
                }
            }

            function updateSectionHeader(sectionName, isComplete) {
                const section = $(`${sectionName}Section`);
                const header = section.querySelector('.section-title');

                // Remove existing status icons
                const existingIcon = header.querySelector('.section-status-icon');
                if (existingIcon) existingIcon.remove();

                // Add status icon
                const icon = document.createElement('span');
                icon.className = 'section-status-icon';
                if (isComplete) {
                    icon.textContent = '‚úÖ';
                } else if (projectData.activeSection === sectionName) {
                    icon.textContent = '‚öôÔ∏è';
                }
                header.appendChild(icon);
            }

            // Validation functions for each section
            function validateBOHSection() {
                // BOH is complete if we have at least one PD or DD configured
                return projectData.powerDistributions.length > 0 || projectData.dataDistributions.length > 0;
            }

            function validateFOHSection() {
                // FOH is complete if a console is selected
                return projectData.console !== null && projectData.console !== undefined;
            }

            function validateConnectionsSection() {
                // Connections section is informational - mark complete if BOH is complete
                return validateBOHSection();
            }

            // ============================================
            // Connections Rendering
            // ============================================
            function renderConnections() {
                renderPowerConnections();
                renderDataConnections();
            }

            function renderPowerConnections() {
                const connectionsList = $('powerConnectionsList');
                const noConnections = $('noPowerConnections');

                if (!projectData.fixtures || projectData.fixtures.length === 0) {
                    connectionsList.innerHTML = '';
                    noConnections.style.display = 'flex';
                    noConnections.querySelector('.empty-state-text').textContent = 'No fixture data loaded';
                    noConnections.querySelector('.empty-state-hint').textContent = 'Load an LX file to see power connections';
                    return;
                }

                if (!projectData.powerDistributions || projectData.powerDistributions.length === 0) {
                    connectionsList.innerHTML = '';
                    noConnections.style.display = 'flex';
                    noConnections.querySelector('.empty-state-text').textContent = 'No power distributions configured';
                    noConnections.querySelector('.empty-state-hint').textContent = 'Add power distributions in BOH section';
                    return;
                }

                noConnections.style.display = 'none';

                // Build position map: position -> {circuits: [], universes: [], powerSource: 'BOH'|position, dataSource: 'BOH'|position}
                const positionMap = new Map();

                projectData.fixtures.forEach(fixture => {
                    const position = fixture['Position'];
                    const circuitName = fixture['Circuit Name'];
                    const universeAddress = fixture['Universe/Address'];

                    if (position && position !== '-' && position.trim() !== '') {
                        const pos = position.trim();
                        if (!positionMap.has(pos)) {
                            positionMap.set(pos, {
                                circuits: new Set(),
                                universes: new Set(),
                                powerSource: 'BOH', // Default to BOH
                                dataSource: 'BOH'   // Default to BOH
                            });
                        }

                        const posData = positionMap.get(pos);

                        // Add circuit
                        if (circuitName && circuitName !== '-' && circuitName.trim() !== '') {
                            posData.circuits.add(circuitName.trim());
                        }

                        // Add universe
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                const universeNum = parseInt(universePart);
                                if (!isNaN(universeNum)) {
                                    posData.universes.add(universeNum);
                                }
                            }
                        }
                    }
                });

                // Get circuit to PD mapping
                const circuitToPD = new Map();
                projectData.powerDistributions.forEach(pd => {
                    if (pd.assignedCircuits) {
                        pd.assignedCircuits.forEach(circuit => {
                            circuitToPD.set(circuit.name, pd);
                        });
                    }
                });

                // Group connections by type
                const connections = {
                    feeders: [],
                    distroChain: [],
                    mults: [],
                    fanouts: []
                };

                // 1. Company Switch to First Power Distro (Feeder)
                if (projectData.powerDistributions.length > 0) {
                    const firstPD = projectData.powerDistributions[0];
                    connections.feeders.push({
                        from: 'Company Switch',
                        to: firstPD.name,
                        cable: 'Feeder Cable',
                        options: ['#1', '#2', '1/0', '2/0', '3/0', '4/0'],
                        voltage: firstPD.isFlexible ? '120V/208V' : `${firstPD.circuits120 > 0 ? '120V' : ''}${firstPD.circuits120 > 0 && firstPD.circuits208 > 0 ? '/' : ''}${firstPD.circuits208 > 0 ? '208V' : ''}`,
                        icon: 'üîå'
                    });
                }

                // 2. Power Distro to Power Distro (daisy chain)
                for (let i = 0; i < projectData.powerDistributions.length - 1; i++) {
                    const currentPD = projectData.powerDistributions[i];
                    const nextPD = projectData.powerDistributions[i + 1];

                    connections.distroChain.push({
                        from: currentPD.name,
                        to: nextPD.name,
                        cable: 'Feeder Thru',
                        cableType: 'Same as input feeder',
                        voltage: 'Passthrough',
                        icon: '‚ö°'
                    });
                }

                // 3. Power Distro to Positions (MULTs)
                positionMap.forEach((posData, position) => {
                    posData.circuits.forEach(circuitName => {
                        const pd = circuitToPD.get(circuitName);
                        const voltage = /\*208|208V/i.test(circuitName) ? 208 : 120;

                        const sourceLocation = posData.powerSource === 'BOH' ? (pd ? pd.name : 'BOH') : posData.powerSource;

                        // Get fixtures on this circuit
                        const circuitFixtures = projectData.fixtures.filter(f =>
                            f['Position'] === position &&
                            f['Circuit Name'] === circuitName
                        );

                        connections.mults.push({
                            from: sourceLocation,
                            to: position,
                            cable: `MULT: ${circuitName}`,
                            cableType: 'Soca SPX19',
                            voltage: `${voltage}V`,
                            icon: 'üîã',
                            position: position,
                            circuitName: circuitName,
                            fixtures: circuitFixtures
                        });
                    });
                });

                // 4. Position Fan Outs (at each position)
                positionMap.forEach((posData, position) => {
                    const voltages = new Set();
                    posData.circuits.forEach(circuitName => {
                        const voltage = /\*208|208V/i.test(circuitName) ? 208 : 120;
                        voltages.add(voltage);
                    });

                    voltages.forEach(voltage => {
                        connections.fanouts.push({
                            from: position,
                            to: `Fixtures at ${position}`,
                            cable: `${voltage}V Fan Out`,
                            voltage: `${voltage}V`,
                            options: voltage === 120
                                ? ['Edison Fan Out', 'Tru 1 Fan Out', 'Power Con Fan Out', 'GP Fan Out']
                                : ['L6-20 Fan Out', 'Tru 1 Fan Out', 'Power Con Fan Out', 'GP Fan Out'],
                            icon: 'üéØ'
                        });
                    });
                });

                // Render connections with collapsible sections
                let html = '<div style="display: flex; flex-direction: column; gap: 16px;">';

                // Power Distros Section
                const totalPowerSections = (connections.feeders.length > 0 ? 1 : 0) +
                                          (connections.distroChain.length > 0 ? 1 : 0);
                if (totalPowerSections > 0) {
                    html += renderCollapsibleSection('powerDistros', '‚ö° Power Distros', totalPowerSections, true, () => {
                        let content = '';

                        // Feeders
                        if (connections.feeders.length > 0) {
                            connections.feeders.forEach(conn => {
                                content += renderConnectionCard(conn);
                            });
                        }

                        // Distro Chain
                        if (connections.distroChain.length > 0) {
                            connections.distroChain.forEach(conn => {
                                content += renderConnectionCard(conn);
                            });
                        }

                        return content;
                    });
                }

                // MULTs to Positions Section
                if (connections.mults.length > 0) {
                    html += renderCollapsibleSection('mults', 'üîã MULTs to Positions', connections.mults.length, true, () => {
                        let content = '';
                        const multsByPosition = new Map();
                        connections.mults.forEach(mult => {
                            if (!multsByPosition.has(mult.position)) {
                                multsByPosition.set(mult.position, []);
                            }
                            multsByPosition.get(mult.position).push(mult);
                        });

                        multsByPosition.forEach((mults, position) => {
                            mults.forEach(conn => {
                                content += renderConnectionCard(conn);
                            });
                        });
                        return content;
                    });
                }

                // Fan Outs Section
                if (connections.fanouts.length > 0) {
                    html += renderCollapsibleSection('fanouts', 'üéØ Fan Outs', connections.fanouts.length, false, () => {
                        let content = '';
                        connections.fanouts.forEach(fanout => {
                            content += renderConnectionCard(fanout);
                        });
                        return content;
                    });
                }

                // Fixture Circuiting Section - Shows circuits with daisy-chained fixtures
                if (connections.mults.length > 0) {
                    html += renderFixtureCircuitingSection(connections, positionMap);
                }

                html += '</div>';
                connectionsList.innerHTML = html;
            }

            // Power connector types with voltage compatibility
            const POWER_CONNECTORS = {
                '120V': ['Edison', 'IEC', 'PowerCon', 'Tru1'],
                '208V': ['L6-20', 'PowerCon', 'Tru1']
            };

            // Generate adapter name between two connector types
            function getAdapterName(fromConnector, toConnector, voltage) {
                if (fromConnector === toConnector) return null;
                return `${fromConnector} (F) to ${toConnector} (M)`;
            }

            // Determine the power inlet and outlet connectors for a device
            function getDeviceConnectors(item, voltage) {
                if (item.type === 'fixture') {
                    const fixtureName = item.fixtureData['Instrument Type'] || item.fixtureData['Device Type'] || 'Unknown';

                    // Look up fixture in database
                    const fixtureInfo = lookupFixture(fixtureName);

                    if (fixtureInfo) {
                        // Use database info
                        return {
                            inlet: fixtureInfo.powerIn,
                            outlet: fixtureInfo.powerOut
                        };
                    } else {
                        // Fallback to heuristics if not in database
                        const fixtureType = fixtureName.toLowerCase();

                        if (voltage === '120V') {
                            if (fixtureType.includes('source four') || fixtureType.includes('s4')) {
                                return { inlet: 'Edison', outlet: null }; // No power thru
                            } else if (fixtureType.includes('led') || fixtureType.includes('moving') || fixtureType.includes('wash')) {
                                return { inlet: 'PowerCon', outlet: 'PowerCon' };
                            } else {
                                return { inlet: 'Edison', outlet: 'Edison' };
                            }
                        } else { // 208V
                            if (fixtureType.includes('led') || fixtureType.includes('moving') || fixtureType.includes('wash')) {
                                return { inlet: 'PowerCon', outlet: 'PowerCon' };
                            } else {
                                return { inlet: 'L6-20', outlet: 'L6-20' };
                            }
                        }
                    }
                } else if (item.type === 'extension') {
                    // Extensions maintain the same connector
                    return { inlet: item.connector, outlet: item.connector };
                } else if (item.type === 'splitter') {
                    // Splitters maintain the same connector but have multiple outputs
                    return { inlet: item.connector, outlet: item.connector };
                } else if (item.type === 'coupler') {
                    // Couplers maintain the same connector
                    return { inlet: item.connector, outlet: item.connector };
                }

                return { inlet: 'Edison', outlet: 'Edison' }; // Default
            }

            // Generate the required cable between two connectors
            function getCableNeeded(fromConnector, toConnector, voltage) {
                if (fromConnector === toConnector) {
                    // Same connector type - need extension cable
                    if (fromConnector === 'Edison') {
                        return { type: 'cable', label: 'Edison Cable', connector: 'Edison' };
                    } else if (fromConnector === 'L6-20') {
                        return { type: 'cable', label: 'L6-20 Cable', connector: 'L6-20' };
                    } else if (fromConnector === 'PowerCon') {
                        return { type: 'cable', label: 'PowerCon Cable', connector: 'PowerCon' };
                    } else if (fromConnector === 'IEC') {
                        return { type: 'cable', label: 'IEC Cable', connector: 'IEC' };
                    } else if (fromConnector === 'Tru1') {
                        return { type: 'cable', label: 'Tru1 Cable', connector: 'Tru1' };
                    }
                } else {
                    // Different connector types - need adapter cable
                    return {
                        type: 'adapter',
                        label: `${fromConnector} to ${toConnector}`,
                        connector: toConnector
                    };
                }

                return null;
            }

            // Auto-circuit algorithm: assign daisy-chain connections for fixtures on a circuit
            function autoCircuitFixtures(fixtures, fanoutConnector, voltage) {
                const circuitPlan = [];
                const adaptersNeeded = [];

                if (!fixtures || fixtures.length === 0) return { circuitPlan, adaptersNeeded };

                // Sort fixtures by channel (optional - for consistent ordering)
                const sortedFixtures = [...fixtures].sort((a, b) => {
                    const chA = parseInt(a['Channel']) || 0;
                    const chB = parseInt(b['Channel']) || 0;
                    return chA - chB;
                });

                let currentConnector = fanoutConnector;

                sortedFixtures.forEach((fixture, idx) => {
                    // Determine fixture power inlet and outlet
                    const fixtureType = fixture['Instrument Type'] || fixture['Device Type'] || 'Unknown';

                    // Guess power connector based on fixture type and voltage
                    // This is a simplified heuristic - in reality would need fixture database
                    let powerIn, powerOut;
                    if (voltage === '120V') {
                        if (fixtureType.toLowerCase().includes('source four')) {
                            powerIn = 'Edison';
                            powerOut = null; // No power thru
                        } else if (fixtureType.toLowerCase().includes('led') || fixtureType.toLowerCase().includes('moving')) {
                            powerIn = 'PowerCon';
                            powerOut = 'PowerCon';
                        } else {
                            powerIn = 'Edison';
                            powerOut = 'Edison';
                        }
                    } else { // 208V
                        if (fixtureType.toLowerCase().includes('led') || fixtureType.toLowerCase().includes('moving')) {
                            powerIn = 'PowerCon';
                            powerOut = 'PowerCon';
                        } else {
                            powerIn = 'L6-20';
                            powerOut = 'L6-20';
                        }
                    }

                    // Determine if adapter is needed
                    const adapter = getAdapterName(currentConnector, powerIn, voltage);
                    if (adapter) {
                        adaptersNeeded.push(adapter);
                    }

                    circuitPlan.push({
                        fixture: fixture,
                        powerIn: powerIn,
                        powerOut: powerOut,
                        adapter: adapter,
                        isLast: idx === sortedFixtures.length - 1
                    });

                    // Update current connector for next fixture
                    currentConnector = powerOut || powerIn; // If no power out, this is end of chain
                });

                return { circuitPlan, adaptersNeeded };
            }

            // Render the Fixture Circuiting section with collapsible mult panels
            function renderFixtureCircuitingSection(connections, positionMap) {
                // Group mults by position
                const multsByPosition = new Map();
                connections.mults.forEach(mult => {
                    if (!multsByPosition.has(mult.position)) {
                        multsByPosition.set(mult.position, []);
                    }
                    multsByPosition.get(mult.position).push(mult);
                });

                let sectionsHtml = '';

                // Create a section for each position (mult)
                multsByPosition.forEach((mults, position) => {
                    // Get circuits for this position
                    const circuitsByNumber = new Map();

                    mults.forEach(mult => {
                        // Get fixtures for this mult
                        const multFixtures = mult.fixtures || [];

                        // Group fixtures by circuit number
                        multFixtures.forEach(fixture => {
                            const circuitNum = fixture['Circuit Number'] || '1';
                            if (!circuitsByNumber.has(circuitNum)) {
                                circuitsByNumber.set(circuitNum, []);
                            }
                            circuitsByNumber.get(circuitNum).push(fixture);
                        });
                    });

                    if (circuitsByNumber.size > 0) {
                        const multName = mults[0].circuitName || position;
                        const voltage = mults[0].voltage || '120V';

                        sectionsHtml += renderCollapsibleSection(
                            `circuit_${position.replace(/\s+/g, '_')}`,
                            `‚ö° Mult (${multName}) Circuiting at ${position}`,
                            circuitsByNumber.size,
                            false,
                            () => {
                                return renderCircuitGrid(circuitsByNumber, voltage, position, multName);
                            }
                        );
                    }
                });

                return sectionsHtml;
            }

            // Initialize circuit chains data structure in projectData
            if (!projectData.circuitChains) {
                projectData.circuitChains = {};
            }

            // Get adapter/extension options based on connector type
            function getAdapterOptions(connectorType, voltage) {
                const options = [];

                if (connectorType === 'Edison') {
                    // Extension cables
                    ['5', '10', '25', '50', '100'].forEach(length => {
                        options.push({
                            type: 'extension',
                            label: `Edison Extension ${length}'`,
                            icon: 'üîå',
                            detail: `${length}' cable`,
                            connector: 'Edison'
                        });
                    });
                    // Splitters/Taps
                    options.push({
                        type: 'splitter',
                        label: 'Cube Tap',
                        icon: 'üî≤',
                        detail: '3-way',
                        outputs: 3,
                        connector: 'Edison'
                    });
                    options.push({
                        type: 'splitter',
                        label: 'Tri Tap',
                        icon: '‚ñº',
                        detail: '3-way',
                        outputs: 3,
                        connector: 'Edison'
                    });
                    options.push({
                        type: 'splitter',
                        label: 'E-String',
                        icon: '‚ûñ',
                        detail: 'Multiple outlets',
                        outputs: 6,
                        connector: 'Edison'
                    });
                } else if (connectorType === 'L6-20') {
                    // Extension cables
                    ['5', '10', '25', '50', '100'].forEach(length => {
                        options.push({
                            type: 'extension',
                            label: `L6-20 Extension ${length}'`,
                            icon: 'üîå',
                            detail: `${length}' cable`,
                            connector: 'L6-20'
                        });
                    });
                    // 2-fer
                    options.push({
                        type: 'splitter',
                        label: 'L6-20 2-fer',
                        icon: '‚Üó',
                        detail: '2-way split',
                        outputs: 2,
                        connector: 'L6-20'
                    });
                } else if (connectorType === 'IEC') {
                    options.push({
                        type: 'extension',
                        label: 'IEC M to F',
                        icon: 'üîå',
                        detail: 'Extension',
                        connector: 'IEC'
                    });
                } else if (connectorType === 'Tru1') {
                    options.push({
                        type: 'extension',
                        label: 'Tru1 M to F',
                        icon: 'üîå',
                        detail: 'Extension',
                        connector: 'Tru1'
                    });
                } else if (connectorType === 'PowerCon') {
                    options.push({
                        type: 'extension',
                        label: 'PowerCon Blue to Gray',
                        icon: 'üîå',
                        detail: 'Extension',
                        connector: 'PowerCon'
                    });
                    options.push({
                        type: 'coupler',
                        label: 'PowerCon Coupler',
                        icon: '‚ö°',
                        detail: 'Extend further',
                        connector: 'PowerCon'
                    });
                }

                return options;
            }

            // Render the 6-circuit grid layout with interactive device selection
            function renderCircuitGrid(circuitsByNumber, voltage, position, multName) {
                const chainId = `${position}_${multName}`.replace(/\s+/g, '_');

                // Initialize chain data if not exists
                if (!projectData.circuitChains[chainId]) {
                    projectData.circuitChains[chainId] = {};
                    for (let i = 1; i <= 6; i++) {
                        projectData.circuitChains[chainId][i] = [];
                    }
                }

                // Store voltage for this chain (needed for cable determination)
                if (!projectData.circuitChainVoltages) {
                    projectData.circuitChainVoltages = {};
                }
                projectData.circuitChainVoltages[chainId] = voltage;

                // Get fan out connector type from selected fan out cable (we'll need to track this)
                const fanoutConnector = voltage === '120V' ? 'Edison' : 'L6-20';

                let gridHtml = '<div class="circuit-grid">';

                // Render all 6 circuits
                for (let circuitNum = 1; circuitNum <= 6; circuitNum++) {
                    const fixtures = circuitsByNumber.get(String(circuitNum)) || [];
                    const chain = projectData.circuitChains[chainId][circuitNum] || [];

                    // Calculate total load
                    const totalWatts = fixtures.reduce((sum, f) => sum + (parseInt(f['Wattage']) || 0), 0);
                    const totalAmps = voltage === '120V' ? (totalWatts / 120).toFixed(1) : (totalWatts / 208).toFixed(1);

                    gridHtml += `
                        <div class="circuit-panel">
                            <div class="circuit-header">
                                <div class="circuit-number">Circuit ${circuitNum}</div>
                                <div class="circuit-load">${totalAmps}A / ${totalWatts}W</div>
                            </div>

                            <!-- Circuit Chain Display -->
                            <div class="circuit-chain" id="chain_${chainId}_${circuitNum}">
                                ${renderCircuitChain(chain, chainId, circuitNum, fanoutConnector, voltage)}
                            </div>

                            <!-- Device Selector -->
                            ${renderDeviceSelector(fixtures, chain, fanoutConnector, voltage, chainId, circuitNum)}
                        </div>
                    `;
                }

                gridHtml += '</div>';

                // Add cable summary at the bottom
                gridHtml += renderCableSummary(chainId, circuitsByNumber, fanoutConnector, voltage);

                return gridHtml;
            }

            // Render summary of all cables needed for this mult
            function renderCableSummary(chainId, circuitsByNumber, fanoutConnector, voltage) {
                const cableCounts = new Map();

                // Process all 6 circuits
                for (let circuitNum = 1; circuitNum <= 6; circuitNum++) {
                    const chain = projectData.circuitChains[chainId]?.[circuitNum] || [];
                    let currentConnector = fanoutConnector;

                    chain.forEach(item => {
                        const deviceConnectors = getDeviceConnectors(item, voltage);
                        const cable = getCableNeeded(currentConnector, deviceConnectors.inlet, voltage);

                        if (cable) {
                            const cableKey = cable.label;
                            cableCounts.set(cableKey, (cableCounts.get(cableKey) || 0) + 1);
                        }

                        currentConnector = deviceConnectors.outlet || deviceConnectors.inlet;
                    });
                }

                if (cableCounts.size === 0) {
                    return '';
                }

                let summaryHtml = `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(37, 99, 235, 0.05); border: 2px solid var(--blue); border-radius: 8px;">
                        <div style="font-size: 12px; font-weight: 600; color: var(--blue); margin-bottom: 8px;">
                            üìã Cable Requirements Summary
                        </div>
                        <div style="display: grid; gap: 4px;">
                `;

                Array.from(cableCounts.entries()).sort((a, b) => a[0].localeCompare(b[0])).forEach(([cable, count]) => {
                    summaryHtml += `
                        <div style="display: flex; justify-content: space-between; padding: 6px 8px; background: white; border-radius: 4px; font-size: 10px;">
                            <span style="font-weight: 500;">${cable}</span>
                            <span style="background: var(--blue); color: white; padding: 2px 8px; border-radius: 4px; font-weight: 600;">${count}x</span>
                        </div>
                    `;
                });

                summaryHtml += `
                        </div>
                    </div>
                `;

                return summaryHtml;
            }

            // Render the current chain for a circuit with auto-inserted cables
            function renderCircuitChain(chain, chainId, circuitNum, fanoutConnector, voltage) {
                if (chain.length === 0) {
                    return '<div style="text-align: center; color: var(--text-softer); font-size: 10px; padding: 12px;">No devices connected yet</div>';
                }

                let html = '';
                let currentConnector = fanoutConnector;

                chain.forEach((item, idx) => {
                    // Determine this device's connectors
                    const deviceConnectors = getDeviceConnectors(item, voltage);

                    // Determine if we need a cable before this device
                    const cable = getCableNeeded(currentConnector, deviceConnectors.inlet, voltage);

                    // Render cable if needed
                    if (cable) {
                        html += `
                            <div class="chain-item" style="background: rgba(249, 115, 22, 0.08); border-color: var(--orange);">
                                <div class="chain-item-icon">üîå</div>
                                <div class="chain-item-details">
                                    <div class="chain-item-label">${cable.label}</div>
                                    <div class="chain-item-info">Auto-assigned</div>
                                </div>
                                <div style="font-size: 9px; color: var(--orange); font-weight: 600;">AUTO</div>
                            </div>
                        `;
                    }

                    // Render the device
                    const icon = item.type === 'fixture' ? 'üí°' :
                                 item.type === 'extension' ? 'üîå' :
                                 item.type === 'splitter' ? '‚Üó' :
                                 item.type === 'coupler' ? '‚ö°' : 'üîß';

                    // Check if fixture is in database
                    let databaseBadge = '';
                    if (item.type === 'fixture') {
                        const fixtureName = item.fixtureData['Instrument Type'] || item.fixtureData['Device Type'] || 'Unknown';
                        const fixtureInfo = lookupFixture(fixtureName);
                        if (fixtureInfo) {
                            databaseBadge = '<div style="font-size: 8px; color: var(--safe); font-weight: 600;">‚úì DB</div>';
                        } else {
                            databaseBadge = '<div style="font-size: 8px; color: var(--warn); font-weight: 600;">‚ö† GUESS</div>';
                        }
                    }

                    html += `
                        <div class="chain-item">
                            <div class="chain-item-icon">${icon}</div>
                            <div class="chain-item-details">
                                <div class="chain-item-label">${item.label}</div>
                                <div class="chain-item-info">${item.detail || ''}</div>
                                ${deviceConnectors.inlet ? `<div style="font-size: 8px; color: var(--text-softer); margin-top: 2px;">In: ${deviceConnectors.inlet}${deviceConnectors.outlet ? ` | Out: ${deviceConnectors.outlet}` : ' | No Thru'}</div>` : ''}
                            </div>
                            ${databaseBadge}
                            <button class="chain-item-remove" onclick="removeChainItem('${chainId}', ${circuitNum}, ${idx})">Remove</button>
                        </div>
                    `;

                    // Update current connector for next iteration
                    currentConnector = deviceConnectors.outlet || deviceConnectors.inlet;
                });

                return html;
            }

            // Render device selector with fixture and adapter options
            function renderDeviceSelector(fixtures, chain, currentConnector, voltage, chainId, circuitNum) {
                const unusedFixtures = fixtures.filter(f => {
                    return !chain.some(item => item.type === 'fixture' && item.fixtureId === f['Channel']);
                });

                const adapterOptions = getAdapterOptions(currentConnector, voltage);

                return `
                    <div class="device-selector">
                        <div class="device-selector-title">Add to Circuit ${circuitNum}:</div>
                        <div class="device-options">
                            ${unusedFixtures.map((fixture, idx) => {
                                const fixtureType = fixture['Instrument Type'] || fixture['Device Type'] || 'Unknown';
                                const channel = fixture['Channel'] || '?';
                                const universeAddress = fixture['Universe/Address'] || `${fixture['Universe'] || '?'}/${fixture['Address'] || '?'}`;
                                const watts = fixture['Wattage'] || '0';

                                return `
                                    <div class="device-card fixture" onclick="addDeviceToChain('${chainId}', ${circuitNum}, 'fixture', ${JSON.stringify(fixture).replace(/"/g, '&quot;')})">
                                        <div class="device-card-icon">üí°</div>
                                        <div class="device-card-label">${fixtureType}</div>
                                        <div class="device-card-detail">Ch ${channel} ‚Ä¢ ${watts}W</div>
                                    </div>
                                `;
                            }).join('')}

                            ${adapterOptions.map(option => `
                                <div class="device-card adapter" onclick="addDeviceToChain('${chainId}', ${circuitNum}, '${option.type}', ${JSON.stringify(option).replace(/"/g, '&quot;')})">
                                    <div class="device-card-icon">${option.icon}</div>
                                    <div class="device-card-label">${option.label}</div>
                                    <div class="device-card-detail">${option.detail}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // Chain management functions
            function addDeviceToChain(chainId, circuitNum, type, data) {
                // Parse data if it's a string (from onclick attribute)
                const deviceData = typeof data === 'string' ? JSON.parse(data.replace(/&quot;/g, '"')) : data;

                // Initialize chain if needed
                if (!projectData.circuitChains[chainId]) {
                    projectData.circuitChains[chainId] = {};
                }
                if (!projectData.circuitChains[chainId][circuitNum]) {
                    projectData.circuitChains[chainId][circuitNum] = [];
                }

                const chain = projectData.circuitChains[chainId][circuitNum];

                // Create chain item
                let chainItem;
                if (type === 'fixture') {
                    const fixtureType = deviceData['Instrument Type'] || deviceData['Device Type'] || 'Unknown';
                    const channel = deviceData['Channel'] || '?';
                    const universeAddress = deviceData['Universe/Address'] || `${deviceData['Universe'] || '?'}/${deviceData['Address'] || '?'}`;

                    chainItem = {
                        type: 'fixture',
                        label: fixtureType,
                        detail: `Ch ${channel} ‚Ä¢ ${universeAddress}`,
                        fixtureId: deviceData['Channel'],
                        fixtureData: deviceData
                    };
                } else {
                    chainItem = {
                        type: deviceData.type,
                        label: deviceData.label,
                        detail: deviceData.detail,
                        connector: deviceData.connector,
                        outputs: deviceData.outputs || 1
                    };
                }

                // Add to chain
                chain.push(chainItem);

                // Re-render connections to update UI
                renderConnections();
            }

            function removeChainItem(chainId, circuitNum, itemIndex) {
                if (!projectData.circuitChains[chainId] || !projectData.circuitChains[chainId][circuitNum]) return;

                const chain = projectData.circuitChains[chainId][circuitNum];
                chain.splice(itemIndex, 1);

                // Re-render connections to update UI
                renderConnections();
            }

            function renderCollapsibleSection(id, title, count, defaultOpen, contentGenerator) {
                const content = contentGenerator();

                // Check if this section was previously open (preserve state during re-renders)
                const previousContent = $(`${id}_content`);
                const wasOpen = previousContent ? (previousContent.style.display !== 'none') : defaultOpen;
                const isOpen = wasOpen;

                return `
                    <div style="border: 2px solid var(--border); border-radius: 8px; overflow: hidden;">
                        <div style="background: var(--card); padding: 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                             onclick="toggleConnectionSection('${id}')">
                            <div style="font-weight: 600; font-size: 13px; color: var(--text-primary);">
                                <span id="${id}_arrow">${isOpen ? '‚ñº' : '‚ñ∂'}</span> ${title}
                            </div>
                            <div style="font-size: 11px; color: var(--text-soft); font-weight: 600;">
                                ${count} item${count !== 1 ? 's' : ''}
                            </div>
                        </div>
                        <div id="${id}_content" style="display: ${isOpen ? 'flex' : 'none'}; flex-direction: column; gap: 8px; padding: 12px; background: var(--bg);">
                            ${content}
                        </div>
                    </div>
                `;
            }

            function toggleConnectionSection(sectionId) {
                const content = $(`${sectionId}_content`);
                const arrow = $(`${sectionId}_arrow`);
                const isVisible = content.style.display !== 'none';

                // Auto-minimize all other sections when expanding a new one
                if (!isVisible) {
                    // Find all section content divs by attribute selector
                    const allContentDivs = document.querySelectorAll('[id$="_content"]');
                    allContentDivs.forEach(otherContent => {
                        const otherId = otherContent.id.replace('_content', '');
                        const otherArrow = $(`${otherId}_arrow`);
                        if (otherId !== sectionId) {
                            otherContent.style.display = 'none';
                            if (otherArrow) otherArrow.textContent = '‚ñ∂';
                        }
                    });
                }

                content.style.display = isVisible ? 'none' : 'flex';
                arrow.textContent = isVisible ? '‚ñ∂' : '‚ñº';
            }

            // Cable length options (in feet)
            const CABLE_LENGTHS = ['5', '10', '15', '25', '50', '100'];

            // Cable management functions
            function getCableEntry(connectionId) {
                return projectData.cableList.find(c => c.connectionId === connectionId);
            }

            function addOrUpdateCable(connectionId, cableType, from, to, cable) {
                let entry = getCableEntry(connectionId);
                if (!entry) {
                    entry = {
                        connectionId: connectionId,
                        cableType: cableType,
                        from: from,
                        to: to,
                        cable: cable,
                        lengths: [],
                        totalLength: 0
                    };
                    projectData.cableList.push(entry);
                } else {
                    entry.cableType = cableType;
                }
                markProjectUpdated();
                renderGearList();
            }

            function updateCableLength(connectionId, length, delta) {
                const entry = getCableEntry(connectionId);
                if (!entry) return;

                let lengthEntry = entry.lengths.find(l => l.length === length);
                if (!lengthEntry) {
                    if (delta > 0) {
                        lengthEntry = { length: length, quantity: 0 };
                        entry.lengths.push(lengthEntry);
                    } else {
                        return; // Can't reduce non-existent entry
                    }
                }

                lengthEntry.quantity += delta;
                if (lengthEntry.quantity <= 0) {
                    entry.lengths = entry.lengths.filter(l => l.length !== length);
                }

                // Recalculate total length
                entry.totalLength = entry.lengths.reduce((sum, l) => {
                    return sum + (parseInt(l.length) * l.quantity);
                }, 0);

                markProjectUpdated();
                renderConnections();
                renderGearList();
                if (projectData.activeSection === 'connections') {
                    renderConnectionStatus();
                }
            }

            function renderConnectionCard(conn) {
                // Generate unique connection ID
                const connectionId = `${conn.from}_${conn.to}_${conn.cable}`.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');

                // Get cable entry if it exists
                const cableEntry = getCableEntry(connectionId);

                // Determine if this connection has cable type options
                const hasOptions = conn.options && conn.options.length > 0;
                const selectedCableType = cableEntry ? cableEntry.cableType : (conn.cableType || (hasOptions ? null : null));

                let optionsHtml = '';
                let lengthsHtml = '';

                // Cable type selection (if multiple options)
                if (hasOptions) {
                    optionsHtml = `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
                            <div style="font-size: 10px; font-weight: 600; color: var(--text-soft); margin-bottom: 6px;">Select Cable Type:</div>
                            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                                ${conn.options.map((option, idx) => {
                                    // Use data attributes to avoid issues with special characters in onclick
                                    const btnId = `${connectionId}_opt${idx}`;
                                    return `
                                        <button class="btn ${selectedCableType === option ? 'selected' : ''}"
                                                id="${btnId}"
                                                data-connection-id="${connectionId}"
                                                data-cable-type="${option}"
                                                data-from="${conn.from}"
                                                data-to="${conn.to}"
                                                data-cable="${conn.cable}"
                                                style="font-size: 10px; padding: 6px 10px; ${selectedCableType === option ? 'background: var(--blue); color: white; border-color: var(--blue);' : ''}">
                                            ${option}
                                        </button>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                    // After rendering, attach event listeners
                    setTimeout(() => {
                        conn.options.forEach((option, idx) => {
                            const btnId = `${connectionId}_opt${idx}`;
                            const btn = document.getElementById(btnId);
                            if (btn && !btn.hasAttribute('data-listener-attached')) {
                                btn.setAttribute('data-listener-attached', 'true');
                                btn.addEventListener('click', function() {
                                    const connId = this.getAttribute('data-connection-id');
                                    const cableType = this.getAttribute('data-cable-type');
                                    const from = this.getAttribute('data-from');
                                    const to = this.getAttribute('data-to');
                                    const cable = this.getAttribute('data-cable');
                                    selectCableType(connId, cableType, from, to, cable);
                                });
                            }
                        });
                    }, 0);
                } else if (conn.cableType) {
                    // Single cable type - auto-select it
                    if (!cableEntry) {
                        addOrUpdateCable(connectionId, conn.cableType, conn.from, conn.to, conn.cable);
                    }
                }

                // Length selection (if cable type is selected or only one option)
                // Skip length selection for fan outs (they're adapters, not cables)
                const isFanOut = conn.cable && conn.cable.includes('Fan Out');
                if (!isFanOut && (selectedCableType || (!hasOptions && conn.cableType))) {
                    const displayType = selectedCableType || conn.cableType;
                    const lengths = cableEntry ? cableEntry.lengths : [];
                    const totalLength = cableEntry ? cableEntry.totalLength : 0;

                    lengthsHtml = `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-size: 10px; font-weight: 600; color: var(--text-soft);">Cable Lengths:</div>
                                ${totalLength > 0 ? `<div style="font-size: 10px; color: var(--blue); font-weight: 600;">Total: ${totalLength}ft</div>` : ''}
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                ${CABLE_LENGTHS.map(length => {
                                    const lengthData = lengths.find(l => l.length === length);
                                    const qty = lengthData ? lengthData.quantity : 0;
                                    return `
                                        <div style="display: flex; align-items: center; gap: 4px; padding: 4px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg);">
                                            <button class="btn" onclick="updateCableLength('${connectionId}', '${length}', -1)"
                                                    style="font-size: 10px; padding: 2px 6px; min-width: 20px;">‚àí</button>
                                            <div style="flex: 1; text-align: center; font-size: 10px;">
                                                <div style="font-weight: 600;">${length}ft</div>
                                                ${qty > 0 ? `<div style="font-size: 9px; color: var(--blue);">√ó${qty}</div>` : `<div style="font-size: 9px; color: var(--text-soft);">0</div>`}
                                            </div>
                                            <button class="btn" onclick="updateCableLength('${connectionId}', '${length}', 1)"
                                                    style="font-size: 10px; padding: 2px 6px; min-width: 20px;">+</button>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                } else if (isFanOut && selectedCableType) {
                    // For fan outs, just show a confirmation that the adapter type is selected
                    lengthsHtml = `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
                            <div style="font-size: 10px; color: var(--green); font-weight: 600;">‚úì Adapter selected</div>
                        </div>
                    `;
                }

                // Fixture breakdown (for MULTs with fixtures)
                let fixturesHtml = '';
                if (conn.fixtures && conn.fixtures.length > 0) {
                    // Group fixtures by circuit number (1-6)
                    const fixturesByCircuit = {};
                    conn.fixtures.forEach(fixture => {
                        // Circuit number would be in the fixture data if available, otherwise show all together
                        const circuitNum = fixture['Circuit Number'] || '1'; // Default to 1 if not specified
                        if (!fixturesByCircuit[circuitNum]) {
                            fixturesByCircuit[circuitNum] = [];
                        }
                        fixturesByCircuit[circuitNum].push(fixture);
                    });

                    fixturesHtml = `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
                            <div style="font-size: 10px; font-weight: 600; color: var(--text-soft); margin-bottom: 6px; cursor: pointer;" onclick="toggleFixtureBreakdown('${connectionId}')">
                                <span>‚ñ∂ Fixtures (${conn.fixtures.length}) - Click to configure daisy chain</span>
                            </div>
                            <div id="fixtureBreakdown_${connectionId}" style="display: none; margin-top: 8px;">
                                ${Object.keys(fixturesByCircuit).sort().map(circuitNum => {
                                    const fixtures = fixturesByCircuit[circuitNum];
                                    return `
                                        <div style="margin-bottom: 12px; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg);">
                                            <div style="font-size: 10px; font-weight: 600; color: var(--text-soft); margin-bottom: 8px;">
                                                Circuit ${circuitNum} ‚Ä¢ ${fixtures.length} fixture${fixtures.length !== 1 ? 's' : ''}
                                            </div>
                                            ${renderFixtureChain(fixtures, connectionId, circuitNum, conn.voltage)}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                return `
                    <div style="padding: 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--card);">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="font-size: 20px;">${conn.icon}</div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; margin-bottom: 4px; font-size: 12px;">
                                    ${conn.from} ‚Üí ${conn.to}
                                </div>
                                <div style="font-size: 10px; color: var(--text-soft);">
                                    ${conn.cable}${conn.voltage ? ` ‚Ä¢ ${conn.voltage}` : ''}${selectedCableType ? ` ‚Ä¢ ${selectedCableType}` : (conn.cableType ? ` ‚Ä¢ ${conn.cableType}` : '')}
                                </div>
                            </div>
                        </div>
                        ${optionsHtml}
                        ${lengthsHtml}
                        ${fixturesHtml}
                    </div>
                `;
            }

            function toggleFixtureBreakdown(connectionId) {
                const breakdown = $(`fixtureBreakdown_${connectionId}`);
                const isVisible = breakdown.style.display !== 'none';
                breakdown.style.display = isVisible ? 'none' : 'block';

                // Update arrow direction
                const fixtureCount = event.target.textContent.match(/\d+/)[0];
                event.target.innerHTML = isVisible
                    ? `‚ñ∂ Fixtures (${fixtureCount}) - Click to configure daisy chain`
                    : `‚ñº Fixtures (${fixtureCount}) - Click to configure daisy chain`;
            }

            // Render fixture daisy chain for a circuit
            function renderFixtureChain(fixtures, connectionId, circuitNum, voltage) {
                if (!fixtures || fixtures.length === 0) return '';

                // Parse voltage to determine connector type options
                const voltageNum = parseInt(voltage);

                let html = '<div style="display: flex; flex-direction: column; gap: 6px;">';

                fixtures.forEach((fixture, idx) => {
                    const channelName = fixture['Channel Name'] || fixture['Unit #'] || 'Unknown';
                    const fixtureType = fixture['Type'] || '';
                    const wattage = fixture['Wattage'] || '';
                    const universeAddress = fixture['Universe/Address'] || '';

                    // Get universe number for data cable type
                    const universeNum = universeAddress ? parseInt(universeAddress.split('/')[0]) : null;
                    let dataCableType = 'A5'; // Default to 5-pin

                    // Check if this universe is on a splitter (would use A3)
                    if (universeNum && projectData.dataDistributions) {
                        const onSplitter = projectData.dataDistributions.some(dd =>
                            dd.deviceType === 'splitter' &&
                            (dd.assignedUniverses?.includes(universeNum) ||
                             dd.splitUniverses?.some(s => s.universe === universeNum))
                        );
                        if (onSplitter) dataCableType = 'A3';
                    }

                    // Check if network mode and on node (would use EtherCON)
                    if (projectData.dataMode === 'network' && universeNum && projectData.dataDistributions) {
                        const onNode = projectData.dataDistributions.some(dd =>
                            dd.deviceType === 'node' && dd.assignedUniverses?.includes(universeNum)
                        );
                        if (onNode) dataCableType = 'EtherCON';
                    }

                    const fixtureId = `${connectionId}_circuit${circuitNum}_fixture${idx}`;

                    html += `
                        <div style="padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--card);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 6px;">
                                <div>
                                    <div style="font-size: 10px; font-weight: 600;">${idx + 1}. ${channelName}</div>
                                    ${fixtureType ? `<div style="font-size: 9px; color: var(--text-soft);">${fixtureType}${wattage ? ` ‚Ä¢ ${wattage}W` : ''}</div>` : ''}
                                </div>
                                ${universeAddress ? `<div style="font-size: 9px; color: var(--blue); font-weight: 600;">Uni ${universeAddress}</div>` : ''}
                            </div>

                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px;">
                                <!-- Power Connector -->
                                <div style="border: 1px solid var(--border); border-radius: 4px; padding: 6px; background: var(--bg);">
                                    <div style="font-size: 8px; color: var(--text-soft); margin-bottom: 4px;">‚ö° Power In</div>
                                    <select id="${fixtureId}_power_in" onchange="updateFixtureConnection('${fixtureId}', 'power_in')"
                                            style="width: 100%; font-size: 9px; padding: 2px;">
                                        <option value="">Select...</option>
                                        <option value="Edison">Edison</option>
                                        <option value="Tru1">Tru1</option>
                                        <option value="PowerCon">PowerCon</option>
                                        <option value="GP">GP</option>
                                        <option value="L6-20">L6-20</option>
                                    </select>
                                    <div style="font-size: 8px; color: var(--text-softer); margin-top: 2px;">${voltage}</div>
                                </div>

                                <!-- Data Connector -->
                                <div style="border: 1px solid var(--border); border-radius: 4px; padding: 6px; background: var(--bg);">
                                    <div style="font-size: 8px; color: var(--text-soft); margin-bottom: 4px;">üì° Data In</div>
                                    <select id="${fixtureId}_data_in" onchange="updateFixtureConnection('${fixtureId}', 'data_in')"
                                            style="width: 100%; font-size: 9px; padding: 2px;">
                                        <option value="">Select...</option>
                                        <option value="A5" ${dataCableType === 'A5' ? 'selected' : ''}>5-pin XLR (A5)</option>
                                        <option value="A3" ${dataCableType === 'A3' ? 'selected' : ''}>3-pin XLR (A3)</option>
                                        <option value="EtherCON" ${dataCableType === 'EtherCON' ? 'selected' : ''}>EtherCON</option>
                                        <option value="RJ45">RJ45</option>
                                    </select>
                                </div>

                                <!-- Power Out (if not last) -->
                                ${idx < fixtures.length - 1 ? `
                                <div style="border: 1px solid var(--border); border-radius: 4px; padding: 6px; background: var(--bg);">
                                    <div style="font-size: 8px; color: var(--text-soft); margin-bottom: 4px;">‚ö° Power Out</div>
                                    <select id="${fixtureId}_power_out" onchange="updateFixtureConnection('${fixtureId}', 'power_out')"
                                            style="width: 100%; font-size: 9px; padding: 2px;">
                                        <option value="">None</option>
                                        <option value="Edison">Edison</option>
                                        <option value="Tru1">Tru1</option>
                                        <option value="PowerCon">PowerCon</option>
                                        <option value="GP">GP</option>
                                        <option value="L6-20">L6-20</option>
                                    </select>
                                </div>

                                <!-- Data Out (if not last) -->
                                <div style="border: 1px solid var(--border); border-radius: 4px; padding: 6px; background: var(--bg);">
                                    <div style="font-size: 8px; color: var(--text-soft); margin-bottom: 4px;">üì° Data Out</div>
                                    <select id="${fixtureId}_data_out" onchange="updateFixtureConnection('${fixtureId}', 'data_out')"
                                            style="width: 100%; font-size: 9px; padding: 2px;">
                                        <option value="">None</option>
                                        <option value="A5">5-pin XLR (A5)</option>
                                        <option value="A3">3-pin XLR (A3)</option>
                                        <option value="EtherCON">EtherCON</option>
                                        <option value="RJ45">RJ45</option>
                                    </select>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    `;

                    // Add connector arrow between fixtures
                    if (idx < fixtures.length - 1) {
                        html += `
                            <div style="text-align: center; color: var(--text-soft); font-size: 11px; margin: 2px 0;">
                                ‚Üì Daisy Chain ‚Üì
                            </div>
                        `;
                    }
                });

                html += '</div>';
                return html;
            }

            function updateFixtureConnection(fixtureId, connectionType) {
                // Store fixture connection data
                const element = $(`${fixtureId}_${connectionType}`);
                if (!element) return;

                const value = element.value;

                // TODO: Store this in projectData for later cable list generation
                // For now, just mark project as updated
                markProjectUpdated();

                console.log(`Fixture ${fixtureId}: ${connectionType} = ${value}`);
            }

            function selectCableType(connectionId, cableType, from, to, cable) {
                addOrUpdateCable(connectionId, cableType, from, to, cable);
                renderConnections();
            }

            // ============================================
            // Connection Status Checklist
            // ============================================
            function renderConnectionStatus() {
                const statusContent = $('connectionStatusContent');
                const statusCount = $('connectionStatusCount');

                // Calculate completion status for each type
                const statuses = calculateConnectionStatuses();

                // Calculate overall percentage
                const totalItems = statuses.totalItems;
                const completedItems = statuses.completedItems;
                const percentage = totalItems > 0 ? Math.round((completedItems / totalItems) * 100) : 0;
                statusCount.textContent = `${percentage}%`;

                // Build status HTML
                let html = '';

                // Company Switch (always complete)
                html += renderStatusItem('‚úÖ', 'Company Switch', 'Power Source', true, true);

                // Console (always complete if selected)
                const consoleComplete = projectData.console !== null;
                html += renderStatusItem(consoleComplete ? '‚úÖ' : '‚¨ú', 'Console', 'Data Source', consoleComplete, consoleComplete);

                // Power Distros
                statuses.powerDistros.forEach(pd => {
                    html += renderStatusItem(pd.complete ? '‚úÖ' : '‚¨ú', pd.name, `Power: ${pd.connected ? 'Connected' : 'Not Connected'}`, pd.connected, pd.complete);
                });

                // Nodes
                statuses.nodes.forEach(node => {
                    html += renderStatusItem(node.complete ? '‚úÖ' : '‚¨ú', node.name, `Data: ${node.connected ? 'Connected' : 'Not Connected'}`, node.connected, node.complete);
                });

                // Splitters
                statuses.splitters.forEach(splitter => {
                    html += renderStatusItem(splitter.complete ? '‚úÖ' : '‚¨ú', splitter.name, `Data: ${splitter.connected ? 'Connected' : 'Not Connected'}`, splitter.connected, splitter.complete);
                });

                // Positions (grouped)
                if (statuses.positions.length > 0) {
                    const completedPositions = statuses.positions.filter(p => p.powerComplete && p.dataComplete).length;
                    const positionSummary = `${completedPositions}/${statuses.positions.length} complete`;
                    html += renderStatusItem(completedPositions === statuses.positions.length ? '‚úÖ' : '‚¨ú', 'Positions', positionSummary, true, completedPositions === statuses.positions.length, true);

                    // Individual positions (collapsible)
                    html += '<div id="positionDetailsList" style="display: none; margin-left: 16px; border-left: 2px solid var(--border); padding-left: 8px;">';
                    statuses.positions.forEach(pos => {
                        const posComplete = pos.powerComplete && pos.dataComplete;
                        const posConnected = pos.powerConnected && pos.dataConnected;
                        html += renderStatusItem(posComplete ? '‚úÖ' : '‚¨ú', pos.name, `P:${pos.powerComplete?'‚úì':'‚úó'} D:${pos.dataComplete?'‚úì':'‚úó'}`, posConnected, posComplete);
                    });
                    html += '</div>';
                }

                statusContent.innerHTML = html;
            }

            function renderStatusItem(icon, title, subtitle, connected, complete, expandable = false) {
                const bgColor = complete ? 'rgba(0, 200, 0, 0.1)' : (connected ? 'rgba(255, 200, 0, 0.1)' : 'var(--bg)');
                const borderColor = complete ? 'rgba(0, 200, 0, 0.3)' : (connected ? 'rgba(255, 200, 0, 0.3)' : 'var(--border)');

                return `
                    <div style="padding: 8px; border: 1px solid ${borderColor}; border-radius: 6px; background: ${bgColor}; ${expandable ? 'cursor: pointer;' : ''}"
                         ${expandable ? 'onclick="togglePositionDetails()"' : ''}>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="font-size: 14px;">${icon}</div>
                            <div style="flex: 1;">
                                <div style="font-size: 11px; font-weight: 600;">${title}</div>
                                <div style="font-size: 9px; color: var(--text-soft);">${subtitle}</div>
                            </div>
                            ${expandable ? '<div style="font-size: 10px; color: var(--text-soft);">‚ñº</div>' : ''}
                        </div>
                    </div>
                `;
            }

            function togglePositionDetails() {
                const detailsList = $('positionDetailsList');
                const isVisible = detailsList.style.display !== 'none';
                detailsList.style.display = isVisible ? 'none' : 'block';
            }

            function calculateConnectionStatuses() {
                let totalItems = 2; // Company Switch + Console (always counted)
                let completedItems = 2; // Always complete

                const powerDistros = [];
                const nodes = [];
                const splitters = [];
                const positions = [];

                // Check Power Distros
                if (projectData.powerDistributions) {
                    projectData.powerDistributions.forEach(pd => {
                        totalItems++;
                        const connectionId = `Company_Switch_${pd.name}_Feeder_Cable`.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const cable = getCableEntry(connectionId);
                        const connected = cable && cable.cableType;
                        const complete = cable && cable.lengths && cable.lengths.length > 0;
                        if (complete) completedItems++;

                        powerDistros.push({
                            id: pd.id,
                            name: pd.name,
                            connected: connected,
                            complete: complete
                        });
                    });
                }

                // Check Nodes
                const nodeDevices = projectData.dataDistributions ? projectData.dataDistributions.filter(dd => dd.deviceType === 'node') : [];
                nodeDevices.forEach(node => {
                    totalItems++;
                    if (projectData.console) {
                        const connectionId = `${projectData.console.name}_${node.name}_EtherCON`.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const cable = getCableEntry(connectionId);
                        const connected = cable && cable.cableType;
                        const complete = cable && cable.lengths && cable.lengths.length > 0;
                        if (complete) completedItems++;

                        nodes.push({
                            id: node.id,
                            name: node.name,
                            connected: connected,
                            complete: complete
                        });
                    }
                });

                // Check Splitters
                const splitterDevices = projectData.dataDistributions ? projectData.dataDistributions.filter(dd => dd.deviceType === 'splitter') : [];
                splitterDevices.forEach(splitter => {
                    totalItems++;
                    if (projectData.console) {
                        const sourceDevice = projectData.dataMode === 'copper' ? projectData.console.name : (nodeDevices.length > 0 ? nodeDevices[0].name : '');
                        const connectionId = `${sourceDevice}_${splitter.name}_DMX_Cable`.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const cable = getCableEntry(connectionId);
                        const connected = cable && cable.cableType;
                        const complete = cable && cable.lengths && cable.lengths.length > 0;
                        if (complete) completedItems++;

                        splitters.push({
                            id: splitter.id,
                            name: splitter.name,
                            connected: connected,
                            complete: complete
                        });
                    }
                });

                // Check Positions
                const positionMap = new Map();
                if (projectData.fixtures) {
                    projectData.fixtures.forEach(fixture => {
                        const position = fixture['Position'];
                        if (position && position !== '-' && position.trim() !== '') {
                            const pos = position.trim();
                            if (!positionMap.has(pos)) {
                                positionMap.set(pos, { circuits: new Set(), universes: new Set() });
                            }
                            const circuitName = fixture['Circuit Name'];
                            if (circuitName && circuitName !== '-' && circuitName.trim() !== '') {
                                positionMap.get(pos).circuits.add(circuitName.trim());
                            }
                            const universeAddress = fixture['Universe/Address'];
                            if (universeAddress) {
                                const universePart = universeAddress.split('/')[0];
                                const universeNum = parseInt(universePart);
                                if (!isNaN(universeNum)) {
                                    positionMap.get(pos).universes.add(universeNum);
                                }
                            }
                        }
                    });

                    positionMap.forEach((posData, posName) => {
                        totalItems++; // Count each position

                        let powerConnected = false;
                        let powerComplete = false;
                        let dataConnected = false;
                        let dataComplete = false;

                        // Check power (MULTs)
                        if (posData.circuits.size > 0) {
                            let multsComplete = 0;
                            let multsConnected = 0;
                            posData.circuits.forEach(circuitName => {
                                const multConnectionId = `BOH_${posName}_MULT_${circuitName}`.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const multCable = getCableEntry(multConnectionId);
                                if (multCable && multCable.cableType) multsConnected++;
                                if (multCable && multCable.lengths && multCable.lengths.length > 0) multsComplete++;
                            });
                            powerConnected = multsConnected > 0;
                            powerComplete = multsComplete === posData.circuits.size;
                        }

                        // Check data (universes)
                        if (posData.universes.size > 0) {
                            let universesComplete = 0;
                            let universesConnected = 0;
                            posData.universes.forEach(universeNum => {
                                const dataConnectionId = `BOH_${posName}_Universe_${universeNum}`.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const dataCable = getCableEntry(dataConnectionId);
                                if (dataCable && dataCable.cableType) universesConnected++;
                                if (dataCable && dataCable.lengths && dataCable.lengths.length > 0) universesComplete++;
                            });
                            dataConnected = universesConnected > 0;
                            dataComplete = universesComplete === posData.universes.size;
                        }

                        if (powerComplete && dataComplete) completedItems++;

                        positions.push({
                            name: posName,
                            powerConnected: powerConnected,
                            powerComplete: powerComplete,
                            dataConnected: dataConnected,
                            dataComplete: dataComplete
                        });
                    });
                }

                return {
                    totalItems: totalItems,
                    completedItems: completedItems,
                    powerDistros: powerDistros,
                    nodes: nodes,
                    splitters: splitters,
                    positions: positions
                };
            }

            function renderGearList() {
                const gearListGroup = $('gearListGroup');
                const gearListContent = $('gearListContent');
                const gearListCount = $('gearListCount');

                // Filter to only show cables with lengths selected
                const cablesWithLengths = projectData.cableList.filter(cable => cable.lengths && cable.lengths.length > 0);

                if (cablesWithLengths.length === 0) {
                    gearListGroup.style.display = 'none';
                    return;
                }

                gearListGroup.style.display = 'block';

                // Group cables by type for summary
                const cablesByType = new Map();
                cablesWithLengths.forEach(cable => {
                    cable.lengths.forEach(lengthEntry => {
                        const key = `${cable.cableType} - ${lengthEntry.length}ft`;
                        if (!cablesByType.has(key)) {
                            cablesByType.set(key, {
                                cableType: cable.cableType,
                                length: lengthEntry.length,
                                quantity: 0,
                                connections: []
                            });
                        }
                        const entry = cablesByType.get(key);
                        entry.quantity += lengthEntry.quantity;
                        entry.connections.push({
                            from: cable.from,
                            to: cable.to,
                            qty: lengthEntry.quantity
                        });
                    });
                });

                // Calculate total items
                let totalItems = 0;
                cablesByType.forEach(entry => {
                    totalItems += entry.quantity;
                });
                gearListCount.textContent = totalItems;

                // Render list
                let html = '';
                const sortedEntries = Array.from(cablesByType.entries()).sort((a, b) => {
                    // Sort by cable type, then by length
                    if (a[1].cableType !== b[1].cableType) {
                        return a[1].cableType.localeCompare(b[1].cableType);
                    }
                    return parseInt(a[1].length) - parseInt(b[1].length);
                });

                sortedEntries.forEach(([key, entry]) => {
                    const connectionsText = entry.connections.length > 3
                        ? `${entry.connections.length} connections`
                        : entry.connections.map(c => `${c.from}‚Üí${c.to}${c.qty > 1 ? ` (√ó${c.qty})` : ''}`).join(', ');

                    html += `
                        <div style="padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <div style="font-size: 11px; font-weight: 600;">${entry.cableType}</div>
                                <div style="font-size: 11px; font-weight: 600; color: var(--blue);">√ó${entry.quantity}</div>
                            </div>
                            <div style="font-size: 10px; color: var(--text-soft);">
                                ${entry.length}ft
                            </div>
                            <div style="font-size: 9px; color: var(--text-softer); margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${connectionsText}">
                                ${connectionsText}
                            </div>
                        </div>
                    `;
                });

                gearListContent.innerHTML = html;
            }

            function renderDataConnections() {
                const connectionsList = $('dataConnectionsList');
                const noConnections = $('noDataConnections');

                if (!projectData.fixtures || projectData.fixtures.length === 0) {
                    connectionsList.innerHTML = '';
                    noConnections.style.display = 'flex';
                    noConnections.querySelector('.empty-state-text').textContent = 'No fixture data loaded';
                    noConnections.querySelector('.empty-state-hint').textContent = 'Load an LX file to see data connections';
                    return;
                }

                if (!projectData.console) {
                    connectionsList.innerHTML = '';
                    noConnections.style.display = 'flex';
                    noConnections.querySelector('.empty-state-text').textContent = 'No console selected';
                    noConnections.querySelector('.empty-state-hint').textContent = 'Select console in FOH section';
                    return;
                }

                if (!projectData.dataMode) {
                    connectionsList.innerHTML = '';
                    noConnections.style.display = 'flex';
                    noConnections.querySelector('.empty-state-text').textContent = 'No data mode selected';
                    noConnections.querySelector('.empty-state-hint').textContent = 'Select Network or Copper mode in BOH section';
                    return;
                }

                if (!projectData.dataDistributions || projectData.dataDistributions.length === 0) {
                    connectionsList.innerHTML = '';
                    noConnections.style.display = 'flex';
                    noConnections.querySelector('.empty-state-text').textContent = 'No data distributions configured';
                    noConnections.querySelector('.empty-state-hint').textContent = 'Add data distributions in BOH section';
                    return;
                }

                noConnections.style.display = 'none';

                // Build position map with universes
                const positionMap = new Map();

                projectData.fixtures.forEach(fixture => {
                    const position = fixture['Position'];
                    const universeAddress = fixture['Universe/Address'];

                    if (position && position !== '-' && position.trim() !== '') {
                        const pos = position.trim();
                        if (!positionMap.has(pos)) {
                            positionMap.set(pos, {
                                universes: new Set(),
                                dataSource: 'BOH' // Default to BOH
                            });
                        }

                        const posData = positionMap.get(pos);

                        // Add universe
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                const universeNum = parseInt(universePart);
                                if (!isNaN(universeNum)) {
                                    posData.universes.add(universeNum);
                                }
                            }
                        }
                    }
                });

                // Get universe to DD mapping
                const universeToDDs = new Map(); // universe -> {node, splitter}
                projectData.dataDistributions.forEach(dd => {
                    if (dd.assignedUniverses) {
                        dd.assignedUniverses.forEach(universeNum => {
                            if (!universeToDDs.has(universeNum)) {
                                universeToDDs.set(universeNum, { node: null, splitter: null });
                            }
                            const ddInfo = universeToDDs.get(universeNum);
                            if (dd.deviceType === 'node') {
                                ddInfo.node = dd;
                            } else if (dd.deviceType === 'splitter') {
                                ddInfo.splitter = dd;
                            }
                        });
                    }
                    // Also check split universes for splitters
                    if (dd.splitUniverses && dd.deviceType === 'splitter') {
                        dd.splitUniverses.forEach(splitInfo => {
                            if (!universeToDDs.has(splitInfo.universe)) {
                                universeToDDs.set(splitInfo.universe, { node: null, splitter: null });
                            }
                            universeToDDs.get(splitInfo.universe).splitter = dd;
                        });
                    }
                });

                // Group connections by type
                const connections = {
                    consoleToNodes: [],
                    consoleToSplitters: [],
                    nodesToSplitters: [],
                    dataToPositions: []
                };

                const nodes = projectData.dataDistributions.filter(dd => dd.deviceType === 'node');
                const splitters = projectData.dataDistributions.filter(dd => dd.deviceType === 'splitter');

                // 1. Console to Nodes (network mode)
                if (projectData.dataMode === 'network' && nodes.length > 0) {
                    nodes.forEach(node => {
                        connections.consoleToNodes.push({
                            from: projectData.console.name,
                            to: node.name,
                            cable: 'EtherCON',
                            cableType: 'Cat5e/Cat6',
                            info: `${node.universes} universe capacity`,
                            icon: 'üß†'
                        });
                    });
                }

                // 2. Console to Splitters (copper mode only)
                if (projectData.dataMode === 'copper' && splitters.length > 0) {
                    splitters.forEach(splitter => {
                        connections.consoleToSplitters.push({
                            from: projectData.console.name,
                            to: splitter.name,
                            cable: 'DMX Cable',
                            cableType: '5-pin XLR (A5)',
                            info: `${splitter.universes} universe(s)`,
                            icon: 'üéõÔ∏è'
                        });
                    });
                }

                // 3. Nodes to Splitters (network mode - for split universes)
                if (projectData.dataMode === 'network' && splitters.length > 0) {
                    splitters.forEach(splitter => {
                        // Find if this splitter has split universes assigned
                        if (splitter.splitUniverses && splitter.splitUniverses.length > 0) {
                            // Simplified: assume first node feeds splitters
                            const sourceNode = nodes.length > 0 ? nodes[0] : null;
                            if (sourceNode) {
                                connections.nodesToSplitters.push({
                                    from: sourceNode.name,
                                    to: splitter.name,
                                    cable: 'DMX Cable',
                                    cableType: '5-pin XLR (A5)',
                                    info: `Split universe replication`,
                                    icon: 'üîÄ'
                                });
                            }
                        }
                    });
                }

                // 4. Data Distributions to Positions
                positionMap.forEach((posData, position) => {
                    posData.universes.forEach(universeNum => {
                        const ddInfo = universeToDDs.get(universeNum);

                        let sourceDevice = null;
                        let cableType = '';

                        if (projectData.dataMode === 'network') {
                            // Network mode: check if it's on a splitter (split) or node
                            if (ddInfo && ddInfo.splitter) {
                                sourceDevice = ddInfo.splitter;
                                cableType = '3-pin XLR (A3)';
                            } else if (ddInfo && ddInfo.node) {
                                sourceDevice = ddInfo.node;
                                cableType = '5-pin XLR (A5)';
                            }
                        } else if (projectData.dataMode === 'copper') {
                            // Copper mode: should be from splitter
                            if (ddInfo && ddInfo.splitter) {
                                sourceDevice = ddInfo.splitter;
                                cableType = '3-pin XLR (A3)';
                            }
                        }

                        if (sourceDevice) {
                            const sourceLocation = posData.dataSource === 'BOH' ? sourceDevice.name : posData.dataSource;

                            connections.dataToPositions.push({
                                from: sourceLocation,
                                to: position,
                                cable: `Universe ${universeNum}`,
                                cableType: cableType,
                                icon: 'üì°',
                                position: position,
                                universe: universeNum
                            });
                        }
                    });
                });

                // Render connections with collapsible sections
                let html = '<div style="display: flex; flex-direction: column; gap: 16px;">';

                // Console Section (always show if console exists)
                if (projectData.console) {
                    html += renderCollapsibleSection('dataConsole', 'üíª Console', 1, true, () => {
                        return `
                            <div style="padding: 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--card);">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <div style="font-size: 20px;">‚úÖ</div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; margin-bottom: 4px; font-size: 12px;">
                                            ${projectData.console.name}
                                        </div>
                                        <div style="font-size: 10px; color: var(--text-soft);">
                                            Data Source ‚Ä¢ ${projectData.console.maxUniverses.network} Network, ${projectData.console.maxUniverses.copper} Copper
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                }

                // Nodes Section
                if (connections.consoleToNodes.length > 0) {
                    html += renderCollapsibleSection('dataNodes', 'üß† Nodes', connections.consoleToNodes.length, true, () => {
                        let content = '';
                        connections.consoleToNodes.forEach(conn => {
                            content += renderConnectionCard(conn);
                        });
                        return content;
                    });
                }

                // Splitters Section
                const totalSplitters = connections.consoleToSplitters.length + connections.nodesToSplitters.length;
                if (totalSplitters > 0) {
                    html += renderCollapsibleSection('dataSplitters', 'üéõÔ∏è Splitters', totalSplitters, true, () => {
                        let content = '';

                        // Console to Splitters (copper mode)
                        connections.consoleToSplitters.forEach(conn => {
                            content += renderConnectionCard(conn);
                        });

                        // Nodes to Splitters (network mode with split universes)
                        connections.nodesToSplitters.forEach(conn => {
                            content += renderConnectionCard(conn);
                        });

                        return content;
                    });
                }

                // Home Runs to Positions Section
                if (connections.dataToPositions.length > 0) {
                    html += renderCollapsibleSection('dataHomeRuns', 'üì° Home Runs to Positions', connections.dataToPositions.length, false, () => {
                        let content = '';
                        const dataByPosition = new Map();
                        connections.dataToPositions.forEach(conn => {
                            if (!dataByPosition.has(conn.position)) {
                                dataByPosition.set(conn.position, []);
                            }
                            dataByPosition.get(conn.position).push(conn);
                        });

                        dataByPosition.forEach((conns, position) => {
                            conns.forEach(conn => {
                                content += renderConnectionCard(conn);
                            });
                        });
                        return content;
                    });
                }

                html += '</div>';
                connectionsList.innerHTML = html;
            }

            function updateSidebarForSection(sectionName) {
                // Show/hide relevant stat groups based on active section
                if (sectionName === 'connections') {
                    // Connections tab: hide all distribution stats, show only connection status and gear list
                    $('circuitAssignmentStats').style.display = 'none';
                    $('bohStats').style.display = 'none';
                    $('universeAssignmentStats').style.display = 'none';
                    $('connectionStatusGroup').style.display = 'block';
                    $('gearListGroup').style.display = projectData.cableList.filter(c => c.lengths && c.lengths.length > 0).length > 0 ? 'block' : 'none';
                    renderConnectionStatus();
                } else if (sectionName === 'boh') {
                    // BOH: Show circuit assignment, BOH stats, and universe assignment if data mode selected
                    $('circuitAssignmentStats').style.display = 'block';
                    $('bohStats').style.display = 'block';
                    $('connectionStatusGroup').style.display = 'none';
                    if (projectData.dataMode) {
                        $('universeAssignmentStats').style.display = 'block';
                    }
                } else if (sectionName === 'foh') {
                    // FOH: Show relevant stats
                    $('circuitAssignmentStats').style.display = 'block';
                    $('universeAssignmentStats').style.display = projectData.dataMode ? 'block' : 'none';
                    $('connectionStatusGroup').style.display = 'none';
                } else {
                    // Default view
                    $('circuitAssignmentStats').style.display = 'block';
                    $('bohStats').style.display = 'block';
                    $('universeAssignmentStats').style.display = projectData.dataMode ? 'block' : 'none';
                    $('connectionStatusGroup').style.display = 'none';
                }
            }

            // ============================================
            // Tab Management
            // ============================================
            function switchTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                event.target.classList.add('active');

                // Show/hide content
                if (tabName === 'power') {
                    $('powerTab').style.display = 'block';
                    $('dataTab').style.display = 'none';
                } else {
                    $('powerTab').style.display = 'none';
                    $('dataTab').style.display = 'block';
                }
            }

            // ============================================
            // Power Distribution (PD) Management
            // ============================================
            function showPDPresets() {
                $('pdPresetSelection').style.display = 'block';
                $('addPDBtn').style.display = 'none';
            }

            function hidePDPresets() {
                $('pdPresetSelection').style.display = 'none';
                $('addPDBtn').style.display = 'inline-flex';
            }

            function selectPDPreset(presetValue) {
                // Check if TSV inventory is loaded
                if (!uploadedFiles.tsv && presetValue !== 'custom') {
                    alert("‚ö†Ô∏è Upload TSV of inventory\n\nNo inventory database loaded. Please upload a TSV file with your inventory data.");
                    return;
                }

                // Open modal with preset selected (keep presets visible)
                $('pdModal').classList.add('active');
                if (presetValue === 'custom') {
                    $('pdPreset').value = '';
                } else {
                    $('pdPreset').value = presetValue;
                }
                handlePresetChange();
            }

            function addPD() {
                $('pdModal').classList.add('active');
                // Reset form
                $('pdPreset').value = '';
                $('pdName').value = '';
                $('pdCircuits120').value = '0';
                $('pdCircuits208').value = '0';
                $('pdNotes').value = '';
            }

            function closePDModal() {
                $('pdModal').classList.remove('active');
                // Keep presets visible
            }

            function handlePresetChange() {
                const presetValue = $('pdPreset').value;

                // Show/hide config type selector for custom
                const isCustom = presetValue === 'custom';
                const isPresidential = presetValue === 'lex48';

                $('pdConfigTypeGroup').style.display = isCustom ? 'block' : 'none';

                if (!presetValue) {
                    // Reset to empty
                    $('pdName').value = '';
                    $('pdCircuits120').value = '0';
                    $('pdCircuits208').value = '0';
                    $('pdFlexMults').value = '6';
                    $('pdNotes').value = '';
                    $('pdConfigType').value = 'fixed';
                    $('pdFlexMultsGroup').style.display = 'none';
                    $('pdCircuits120Group').style.display = 'block';
                    $('pdCircuits208Group').style.display = 'block';
                    return;
                }

                if (isCustom) {
                    // Clear for custom entry
                    $('pdName').value = '';
                    $('pdCircuits120').value = '0';
                    $('pdCircuits208').value = '0';
                    $('pdFlexMults').value = '6';
                    $('pdNotes').value = '';
                    $('pdConfigType').value = 'fixed';
                    // Default to fixed circuits for custom
                    $('pdFlexMultsGroup').style.display = 'none';
                    $('pdCircuits120Group').style.display = 'block';
                    $('pdCircuits208Group').style.display = 'block';
                    return;
                }

                if (isPresidential) {
                    // Presidential always uses flexible
                    $('pdFlexMultsGroup').style.display = 'block';
                    $('pdCircuits120Group').style.display = 'none';
                    $('pdCircuits208Group').style.display = 'none';
                    $('pdFlexMults').value = '6';
                }

                // Load preset values
                const preset = PD_PRESETS[presetValue];
                if (preset) {
                    $('pdName').value = preset.name;
                    if (!isPresidential) {
                        $('pdFlexMultsGroup').style.display = 'none';
                        $('pdCircuits120Group').style.display = 'block';
                        $('pdCircuits208Group').style.display = 'block';
                        $('pdCircuits120').value = preset.circuits120;
                        $('pdCircuits208').value = preset.circuits208;
                    }
                    $('pdNotes').value = preset.notes;
                }
            }

            function handleConfigTypeChange() {
                const configType = $('pdConfigType').value;
                const isFlexible = configType === 'flexible';

                $('pdFlexMultsGroup').style.display = isFlexible ? 'block' : 'none';
                $('pdCircuits120Group').style.display = isFlexible ? 'none' : 'block';
                $('pdCircuits208Group').style.display = isFlexible ? 'none' : 'block';

                if (isFlexible) {
                    $('pdFlexMults').value = $('pdFlexMults').value || '6';
                }
            }

            function savePD() {
                const name = $('pdName').value.trim();
                const presetValue = $('pdPreset').value;
                const isCustom = presetValue === 'custom';

                // Determine if flexible based on preset or custom config type
                let isFlexible;
                if (presetValue === 'lex48') {
                    isFlexible = true;
                } else if (isCustom) {
                    isFlexible = $('pdConfigType').value === 'flexible';
                } else {
                    isFlexible = false;
                }

                let circuits120, circuits208, flexMults;

                if (isFlexible) {
                    flexMults = parseInt($('pdFlexMults').value) || 6;
                    circuits120 = 0;  // Not used for flexible
                    circuits208 = 0;  // Not used for flexible
                } else {
                    circuits120 = parseInt($('pdCircuits120').value) || 0;
                    circuits208 = parseInt($('pdCircuits208').value) || 0;
                    flexMults = 0;
                }

                const notes = $('pdNotes').value.trim();

                // Validation
                if (!name) {
                    alert('Name is required');
                    return;
                }
                if (!isFlexible && circuits120 === 0 && circuits208 === 0) {
                    alert('At least one circuit type (120V or 208V) must be greater than 0');
                    return;
                }
                if (isFlexible && flexMults === 0) {
                    alert('Number of flexible MULTs must be greater than 0');
                    return;
                }

                const pd = {
                    id: `PD-${Date.now()}`,
                    name: name,
                    circuits120: circuits120,
                    circuits208: circuits208,
                    flexMults: flexMults,
                    notes: notes,
                    preset: presetValue || 'custom',
                    assignedCircuits: [],
                    gearItems: [],
                    isFlexible: isFlexible
                };

                // Add gear items if from preset
                if (presetValue && PD_PRESETS[presetValue]) {
                    pd.gearItems = [...PD_PRESETS[presetValue].gearItems];
                    // Add to project gear list
                    pd.gearItems.forEach(item => {
                        if (!projectData.gearList.includes(item)) {
                            projectData.gearList.push(item);
                        }
                    });
                }

                projectData.powerDistributions.push(pd);
                closePDModal();

                // Auto-assign circuits
                autoAssignCircuits();

                renderPDs();
                renderDDs();
                renderCustomFixtures();
                renderConnections();
                updateStats();
                markProjectUpdated();
            }

            function renderPDs() {
                const grid = $('pdGrid');

                if (projectData.powerDistributions.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">‚ö°</div>
                            <div class="empty-state-text">No power distributions yet</div>
                        </div>
                    `;
                    return;
                }

                grid.innerHTML = projectData.powerDistributions.map(pd => {
                    const assigned120 = pd.assignedCircuits ? pd.assignedCircuits.filter(c => c.voltage === 120) : [];
                    const assigned208 = pd.assignedCircuits ? pd.assignedCircuits.filter(c => c.voltage === 208) : [];

                    let capacityDisplay = '';
                    let assignedDisplay = '';
                    let isOverCapacity = false;
                    let warningBadge = '';

                    if (pd.isFlexible) {
                        // Presidential: Show combined capacity (flexMults total)
                        const totalAssigned = assigned120.length + assigned208.length;
                        const maxMults = pd.flexMults || 6;
                        const usagePct = (totalAssigned / maxMults) * 100;
                        isOverCapacity = totalAssigned > maxMults;

                        capacityDisplay = `
                            <div style="font-size: 10px; margin-top: 6px;">Total: ${totalAssigned}/${maxMults} MULTs (${usagePct.toFixed(0)}%)</div>
                            <div class="capacity-bar">
                                <div class="capacity-fill ${usagePct > 90 ? 'danger' : usagePct > 75 ? 'warning' : ''}" style="width: ${usagePct}%"></div>
                            </div>
                        `;

                        if (assigned120.length > 0 || assigned208.length > 0) {
                            assignedDisplay = '<div style="margin-top: 8px; font-size: 10px;">';
                            assignedDisplay += '<div style="font-weight: 600; margin-bottom: 4px;">Assigned MULTs:</div>';
                            if (assigned120.length > 0) {
                                assignedDisplay += `<div style="margin-bottom: 2px;"><strong>120V (${assigned120.length}):</strong> ${assigned120.map(c => c.multName).join(', ')}</div>`;
                            }
                            if (assigned208.length > 0) {
                                assignedDisplay += `<div><strong>208V (${assigned208.length}):</strong> ${assigned208.map(c => c.multName).join(', ')}</div>`;
                            }
                            assignedDisplay += '</div>';
                        }
                    } else {
                        // Fixed distros: Show separate 120V and 208V capacity
                        const maxMults120 = Math.floor(pd.circuits120 / 6);
                        const maxMults208 = Math.floor(pd.circuits208 / 6);
                        const usage120Pct = maxMults120 > 0 ? (assigned120.length / maxMults120) * 100 : 0;
                        const usage208Pct = maxMults208 > 0 ? (assigned208.length / maxMults208) * 100 : 0;
                        isOverCapacity = (assigned120.length > maxMults120) || (assigned208.length > maxMults208);

                        if (pd.circuits120 > 0) {
                            capacityDisplay += `
                                <div style="font-size: 10px; margin-top: 6px;">120V: ${assigned120.length}/${maxMults120} MULTs (${usage120Pct.toFixed(0)}%)</div>
                                <div class="capacity-bar">
                                    <div class="capacity-fill ${usage120Pct > 90 ? 'danger' : usage120Pct > 75 ? 'warning' : ''}" style="width: ${usage120Pct}%"></div>
                                </div>
                            `;
                        }
                        if (pd.circuits208 > 0) {
                            capacityDisplay += `
                                <div style="font-size: 10px; margin-top: 6px;">208V: ${assigned208.length}/${maxMults208} MULTs (${usage208Pct.toFixed(0)}%)</div>
                                <div class="capacity-bar">
                                    <div class="capacity-fill ${usage208Pct > 90 ? 'danger' : usage208Pct > 75 ? 'warning' : ''}" style="width: ${usage208Pct}%"></div>
                                </div>
                            `;
                        }

                        if (assigned120.length > 0 || assigned208.length > 0) {
                            assignedDisplay = '<div style="margin-top: 8px; font-size: 10px;">';
                            assignedDisplay += '<div style="font-weight: 600; margin-bottom: 4px;">Assigned MULTs:</div>';
                            if (assigned120.length > 0) {
                                assignedDisplay += `<div style="margin-bottom: 2px;"><strong>120V (${assigned120.length}/${maxMults120}):</strong> ${assigned120.map(c => c.multName).join(', ')}</div>`;
                            }
                            if (assigned208.length > 0) {
                                assignedDisplay += `<div><strong>208V (${assigned208.length}/${maxMults208}):</strong> ${assigned208.map(c => c.multName).join(', ')}</div>`;
                            }
                            assignedDisplay += '</div>';
                        }
                    }

                    // Add warning badge if over capacity
                    if (isOverCapacity) {
                        warningBadge = '<span class="warning-badge">‚ö†Ô∏è OVER CAPACITY</span>';
                    }

                    return `
                        <div class="pd-card ${isOverCapacity ? 'over-capacity' : ''}">
                            <div class="pd-card-header">
                                <div class="pd-card-title">${pd.name} ${warningBadge}</div>
                                <div class="pd-card-actions">
                                    <button class="btn" onclick="editPD('${pd.id}')">Edit</button>
                                    <button class="btn" onclick="deletePD('${pd.id}')">√ó</button>
                                </div>
                            </div>
                            <div class="pd-card-specs">
                                ${pd.isFlexible ? `${pd.flexMults || 6} MULTs (configurable 120V/208V)` : ''}
                                ${!pd.isFlexible && pd.circuits120 > 0 ? `${pd.circuits120} √ó 120V circuits` : ''}
                                ${!pd.isFlexible && pd.circuits120 > 0 && pd.circuits208 > 0 ? ' ‚Ä¢ ' : ''}
                                ${!pd.isFlexible && pd.circuits208 > 0 ? `${pd.circuits208} √ó 208V circuits` : ''}
                            </div>
                            ${pd.notes ? `<div style="font-size: 10px; color: var(--text-soft); margin-top: 4px;">${pd.notes}</div>` : ''}
                            ${capacityDisplay}
                            ${assignedDisplay}
                        </div>
                    `;
                }).join('');
            }

            function deletePD(id) {
                if (!confirm('Delete this power distribution?')) return;

                // Remove gear items from project gear list
                const pdToDelete = projectData.powerDistributions.find(pd => pd.id === id);
                if (pdToDelete && pdToDelete.gearItems) {
                    pdToDelete.gearItems.forEach(item => {
                        const index = projectData.gearList.indexOf(item);
                        if (index > -1) {
                            projectData.gearList.splice(index, 1);
                        }
                    });
                }

                projectData.powerDistributions = projectData.powerDistributions.filter(pd => pd.id !== id);

                // Reassign circuits
                autoAssignCircuits();

                renderPDs();
                renderConnections();
                updateStats();
                markProjectUpdated();
            }

            function editPD(id) {
                // TODO: Implement edit functionality
                alert('Edit functionality coming soon!');
            }

            // ============================================
            // Circuit Analysis & Auto-Assignment
            // ============================================
            function getCircuitsFromFixtures() {
                const circuits = {
                    mults120: [],
                    mults208: []
                };

                if (!projectData.fixtures || projectData.fixtures.length === 0) {
                    return circuits;
                }

                // Collect unique circuit names (MULTs)
                const multMap = new Map(); // multName -> voltage

                projectData.fixtures.forEach(fixture => {
                    const circuitName = fixture['Circuit Name'];
                    if (circuitName && circuitName !== '-' && circuitName.trim() !== '') {
                        const trimmed = circuitName.trim();

                        // Detect voltage from circuit name
                        const is208V = /\*208|208V/i.test(trimmed);

                        if (!multMap.has(trimmed)) {
                            multMap.set(trimmed, is208V ? 208 : 120);
                        }
                    }
                });

                // Convert to arrays and sort alphabetically
                multMap.forEach((voltage, multName) => {
                    if (voltage === 208) {
                        circuits.mults208.push(multName);
                    } else {
                        circuits.mults120.push(multName);
                    }
                });

                circuits.mults120.sort();
                circuits.mults208.sort();

                return circuits;
            }

            function autoAssignCircuits() {
                // Get all circuits from fixtures
                const circuits = getCircuitsFromFixtures();

                // Clear existing assignments
                projectData.powerDistributions.forEach(pd => {
                    pd.assignedCircuits = [];
                });

                // Track assigned circuits
                const assigned = new Set();

                // Assign 208V circuits first
                circuits.mults208.forEach(multName => {
                    if (assigned.has(multName)) return;

                    // Find PD with available 208V capacity
                    for (let pd of projectData.powerDistributions) {
                        let available208;

                        if (pd.isFlexible) {
                            // Presidential: flexMults total that can be either 120V or 208V
                            const totalAssigned = pd.assignedCircuits.length;
                            const maxMults = pd.flexMults || 6;
                            available208 = maxMults - totalAssigned;
                        } else {
                            // Fixed distros: separate 120V and 208V pools
                            const assigned208 = pd.assignedCircuits.filter(c => c.voltage === 208).length;
                            available208 = Math.floor(pd.circuits208 / 6) - assigned208;
                        }

                        if (available208 > 0) {
                            pd.assignedCircuits.push({
                                multName: multName,
                                voltage: 208
                            });
                            assigned.add(multName);
                            break;
                        }
                    }
                });

                // Then assign 120V circuits
                circuits.mults120.forEach(multName => {
                    if (assigned.has(multName)) return;

                    // Find PD with available 120V capacity
                    for (let pd of projectData.powerDistributions) {
                        let available120;

                        if (pd.isFlexible) {
                            // Presidential: flexMults total that can be either 120V or 208V
                            const totalAssigned = pd.assignedCircuits.length;
                            const maxMults = pd.flexMults || 6;
                            available120 = maxMults - totalAssigned;
                        } else {
                            // Fixed distros: separate 120V and 208V pools
                            const assigned120 = pd.assignedCircuits.filter(c => c.voltage === 120).length;
                            available120 = Math.floor(pd.circuits120 / 6) - assigned120;
                        }

                        if (available120 > 0) {
                            pd.assignedCircuits.push({
                                multName: multName,
                                voltage: 120
                            });
                            assigned.add(multName);
                            break;
                        }
                    }
                });
            }

            // ============================================
            // Data Mode Selection
            // ============================================
            function selectDataMode(mode) {
                projectData.dataMode = mode;

                console.log(`Data mode set to: ${mode}`);

                // Update selected state on buttons
                document.querySelectorAll('.mode-choice-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
                const selectedBtn = $(`mode-${mode}`);
                if (selectedBtn) {
                    selectedBtn.classList.add('selected');
                }

                // Show device selection
                $('ddDeviceSelection').style.display = 'block';

                // Update UI to reflect mode
                updateDataModeUI();
                renderConsoleDisplay(); // Update console capacity based on mode
                renderConnections();
                updateStats();
                markProjectUpdated();
            }

            function updateDataModeUI() {
                // Update "Add Data Distribution" button behavior based on mode
                // In network mode: show Node option
                // In copper mode: hide Node option
                const nodeOption = $('ddNodeOption');
                if (projectData.dataMode === 'copper') {
                    nodeOption.style.display = 'none';
                } else {
                    nodeOption.style.display = 'block';
                }

                // Show/hide mode selection and device selection based on whether mode is selected
                if (projectData.dataMode) {
                    // Mode is selected - keep mode selection visible but show device selection
                    $('dataModeSelection').style.display = 'block';
                    $('ddDeviceSelection').style.display = 'block';

                    // Update selected state
                    document.querySelectorAll('.mode-choice-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    const selectedBtn = $(`mode-${projectData.dataMode}`);
                    if (selectedBtn) {
                        selectedBtn.classList.add('selected');
                    }
                } else {
                    // No mode selected - keep mode selection and device selection visible
                    $('dataModeSelection').style.display = 'block';
                    $('ddDeviceSelection').style.display = 'block';
                }
            }

            // ============================================
            // Data Distribution (DD) Management
            // ============================================
            function showDDDevices() {
                $('ddDeviceSelection').style.display = 'block';
                $('addDDBtn').style.display = 'none';
            }

            function hideDDDevices() {
                $('ddDeviceSelection').style.display = 'none';
                $('addDDBtn').style.display = 'inline-flex';
            }

            function selectDDDevice(devicePreset) {
                // Check if TSV inventory is loaded
                if (!uploadedFiles.tsv && devicePreset !== 'custom') {
                    alert("‚ö†Ô∏è Upload TSV of inventory\n\nNo inventory database loaded. Please upload a TSV file with your inventory data.");
                    return;
                }

                // Open modal with device preset selected (keep device selection visible)
                $('ddModal').classList.add('active');
                if (devicePreset === 'custom') {
                    $('ddPreset').value = 'custom';
                    $('ddDeviceType').value = '';
                    $('ddName').value = '';
                    $('ddUniverses').value = '1';
                    $('ddOutputs').value = '4';
                    $('ddConnector').value = 'A3';
                    $('ddNotes').value = '';
                    handleDDDeviceTypeChange();
                    return;
                }

                if (devicePreset === 'node-netx2') {
                    $('ddDeviceType').value = 'node';
                    $('ddName').value = 'Chauvet Net-X II';
                    $('ddUniverses').value = '8';
                    $('ddOutputs').value = '8';
                    $('ddConnector').value = 'A5 or A3';
                    $('ddNotes').value = '8 universes, 8x DMX outputs';
                    handleDDDeviceTypeChange();
                    $('ddPreset').value = 'netx2';
                    handleDDPresetChange();
                } else if (devicePreset === 'splitter-ds4') {
                    $('ddDeviceType').value = 'splitter';
                    $('ddName').value = 'Chauvet DJ Data Stream 4';
                    $('ddUniverses').value = '1';
                    $('ddOutputs').value = '1';
                    $('ddConnector').value = 'A3/A5';
                    $('ddNotes').value = '8 total outputs (4x 3-pin, 4x 5-pin)';
                    handleDDDeviceTypeChange();
                    $('ddPreset').value = 'datastream4';
                    handleDDPresetChange();
                } else if (devicePreset === 'custom') {
                    // Reset form for custom
                    $('ddDeviceType').value = '';
                    $('ddPreset').value = '';
                    $('ddName').value = '';
                    $('ddUniverses').value = '8';
                    $('ddOutputs').value = '8';
                    $('ddConnector').value = '';
                    $('ddNotes').value = '';
                    $('ddPresetGroup').style.display = 'none';
                }

                updateDataModeUI();
            }

            function addDD() {
                $('ddModal').classList.add('active');
                // Reset form
                $('ddDeviceType').value = '';
                $('ddPreset').value = '';
                $('ddName').value = '';
                $('ddUniverses').value = '8';
                $('ddOutputs').value = '8';
                $('ddConnector').value = '';
                $('ddNotes').value = '';
                $('ddPresetGroup').style.display = 'none';

                // Update device type options based on mode
                updateDataModeUI();
            }

            function closeDDModal() {
                $('ddModal').classList.remove('active');
                // Keep device selection visible
            }

            function handleDDDeviceTypeChange() {
                const deviceType = $('ddDeviceType').value;
                const presetGroup = $('ddPresetGroup');
                const presetSelect = $('ddPreset');

                if (!deviceType) {
                    presetGroup.style.display = 'none';
                    return;
                }

                // Show preset group and populate options
                presetGroup.style.display = 'block';
                presetSelect.innerHTML = '<option value="">-- Select Preset or Custom --</option>';

                if (deviceType === 'node') {
                    // Populate node presets
                    Object.entries(NODE_PRESETS).forEach(([key, preset]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = preset.name;
                        presetSelect.appendChild(option);
                    });
                } else if (deviceType === 'splitter') {
                    // Populate splitter presets
                    Object.entries(SPLITTER_PRESETS).forEach(([key, preset]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = preset.name;
                        presetSelect.appendChild(option);
                    });
                }

                // Add custom option
                const customOption = document.createElement('option');
                customOption.value = 'custom';
                customOption.textContent = 'Custom Configuration';
                presetSelect.appendChild(customOption);
            }

            function handleDDPresetChange() {
                const deviceType = $('ddDeviceType').value;
                const presetValue = $('ddPreset').value;

                if (!presetValue || presetValue === 'custom') {
                    // Clear for custom entry
                    $('ddName').value = '';
                    $('ddUniverses').value = deviceType === 'splitter' ? '1' : '8';
                    $('ddOutputs').value = deviceType === 'splitter' ? '4' : '8';
                    $('ddConnector').value = '';
                    $('ddNotes').value = '';
                    return;
                }

                // Load preset values
                const presets = deviceType === 'node' ? NODE_PRESETS : SPLITTER_PRESETS;
                const preset = presets[presetValue];

                if (preset) {
                    $('ddName').value = preset.name;
                    $('ddUniverses').value = preset.universes;
                    $('ddOutputs').value = preset.outputs || preset.universes;
                    $('ddConnector').value = preset.connector;
                    $('ddNotes').value = preset.notes;
                }
            }

            function saveDD() {
                const deviceType = $('ddDeviceType').value;
                const name = $('ddName').value.trim();
                const universes = parseInt($('ddUniverses').value) || 1;
                const outputs = parseInt($('ddOutputs').value) || 1;
                const connector = $('ddConnector').value.trim();
                const notes = $('ddNotes').value.trim();
                const presetValue = $('ddPreset').value;

                // Validation
                if (!deviceType) {
                    alert('Please select a device type');
                    return;
                }
                if (!name) {
                    alert('Name is required');
                    return;
                }

                const dd = {
                    id: `DD-${Date.now()}`,
                    name: name,
                    deviceType: deviceType, // 'node' or 'splitter'
                    universes: universes,
                    outputs: outputs,
                    connector: connector,
                    notes: notes,
                    preset: presetValue || 'custom',
                    assignedUniverses: [] // Will store universe numbers assigned to this device
                };

                projectData.dataDistributions.push(dd);
                closeDDModal();

                // Auto-assign universes
                autoAssignUniverses();

                renderDDs();
                renderConnections();
                updateStats();
                markProjectUpdated();
            }

            // ============================================
            // Fixture Database Management
            // ============================================
            let editingFixtureIndex = null;

            function openAddFixtureModal() {
                editingFixtureIndex = null;
                $('fixtureModalHeader').textContent = 'Add Custom Fixture';
                $('fixtureName').value = '';
                $('fixturePowerIn').value = '';
                $('fixturePowerOut').value = '';
                $('fixtureVoltage').value = '';
                $('fixtureWattage').value = '';
                $('fixtureModal').classList.add('active');
            }

            function openEditFixtureModal(index) {
                editingFixtureIndex = index;
                const fixture = projectData.customFixtures[index];
                $('fixtureModalHeader').textContent = 'Edit Custom Fixture';
                $('fixtureName').value = fixture.name;
                $('fixturePowerIn').value = fixture.powerIn;
                $('fixturePowerOut').value = fixture.powerOut || '';
                $('fixtureVoltage').value = fixture.voltage;
                $('fixtureWattage').value = fixture.wattage;
                $('fixtureModal').classList.add('active');
            }

            function closeFixtureModal() {
                $('fixtureModal').classList.remove('active');
                editingFixtureIndex = null;
            }

            function saveFixture() {
                const name = $('fixtureName').value.trim();
                const powerIn = $('fixturePowerIn').value;
                const powerOut = $('fixturePowerOut').value || null;
                const voltage = $('fixtureVoltage').value;
                const wattage = parseInt($('fixtureWattage').value) || 0;

                if (!name || !powerIn || !voltage || wattage === 0) {
                    alert('Please fill in all required fields (Name, Power Inlet, Voltage, Wattage)');
                    return;
                }

                const fixtureData = {
                    name,
                    powerIn,
                    powerOut,
                    voltage,
                    wattage
                };

                if (editingFixtureIndex !== null) {
                    // Editing existing fixture
                    projectData.customFixtures[editingFixtureIndex] = fixtureData;
                } else {
                    // Adding new fixture
                    projectData.customFixtures.push(fixtureData);
                }

                closeFixtureModal();
                renderCustomFixtures();
                renderConnections(); // Re-render to update any fixture references
                markProjectUpdated();
            }

            function deleteCustomFixture(index) {
                const fixture = projectData.customFixtures[index];
                if (confirm(`Delete fixture "${fixture.name}"?`)) {
                    projectData.customFixtures.splice(index, 1);
                    renderCustomFixtures();
                    renderConnections();
                    markProjectUpdated();
                }
            }

            function renderCustomFixtures() {
                const grid = $('fixtureDbGrid');
                if (!grid) return;

                if (projectData.customFixtures.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üí°</div>
                            <div class="empty-state-text">No custom fixtures yet</div>
                        </div>
                    `;
                    return;
                }

                let html = '';
                projectData.customFixtures.forEach((fixture, idx) => {
                    const powerThru = fixture.powerOut ? `Out: ${fixture.powerOut}` : 'No Thru';
                    html += `
                        <div class="pd-card">
                            <div class="pd-card-header">
                                <div class="pd-card-title">üí° ${fixture.name}</div>
                                <div class="pd-card-actions">
                                    <button class="btn" onclick="openEditFixtureModal(${idx})">Edit</button>
                                    <button class="btn" onclick="deleteCustomFixture(${idx})" style="color: var(--danger);">Delete</button>
                                </div>
                            </div>
                            <div class="pd-card-specs">
                                <div>In: ${fixture.powerIn} | ${powerThru}</div>
                                <div>${fixture.voltage} ‚Ä¢ ${fixture.wattage}W</div>
                            </div>
                        </div>
                    `;
                });

                grid.innerHTML = html;
            }

            // Detect split universes (universes serving multiple positions)
            function detectSplitUniverses() {
                const universePositionMap = new Map(); // universe -> Set of positions

                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        const universeAddress = fixture['Universe/Address'];
                        const position = fixture['Position'];

                        if (universeAddress && position && position !== '-' && position.trim() !== '') {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                const universeNum = parseInt(universePart);
                                if (!isNaN(universeNum)) {
                                    if (!universePositionMap.has(universeNum)) {
                                        universePositionMap.set(universeNum, new Set());
                                    }
                                    universePositionMap.get(universeNum).add(position.trim());
                                }
                            }
                        }
                    });
                }

                // Return universes that serve 2+ positions (split universes)
                const splitUniverses = [];
                universePositionMap.forEach((positions, universeNum) => {
                    if (positions.size >= 2) {
                        splitUniverses.push({
                            universe: universeNum,
                            positions: Array.from(positions).sort(),
                            positionCount: positions.size
                        });
                    }
                });

                return splitUniverses.sort((a, b) => a.universe - b.universe);
            }

            // Auto-assign universes to devices
            function autoAssignUniverses() {
                // Get all universes from fixtures
                const universesSet = new Set();
                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        const universeAddress = fixture['Universe/Address'];
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                universesSet.add(parseInt(universePart));
                            }
                        }
                    });
                }

                const allUniverses = Array.from(universesSet).sort((a, b) => a - b);

                // Detect split universes
                const splitUniverses = detectSplitUniverses();
                const splitUniverseNums = new Set(splitUniverses.map(su => su.universe));

                // Clear existing assignments
                projectData.dataDistributions.forEach(dd => {
                    dd.assignedUniverses = [];
                    dd.splitUniverses = [];
                });

                // Track assigned universes
                const assigned = new Set();

                // Separate splitters and nodes
                const splitters = projectData.dataDistributions.filter(dd => dd.deviceType === 'splitter');
                const nodes = projectData.dataDistributions.filter(dd => dd.deviceType === 'node');

                // STEP 1: Assign all universes to Nodes first (base assignment only)
                allUniverses.forEach(universeNum => {
                    // Find node with available capacity
                    for (let dd of nodes) {
                        // Node capacity = outputs (each universe uses 1 output)
                        // Split universes only use extra output if NOT handled by a splitter
                        const baseUniverses = dd.assignedUniverses.length;
                        const splitOutputs = dd.splitUniverses ? dd.splitUniverses.length : 0;
                        const totalOutputsUsed = baseUniverses + splitOutputs;
                        const availableCapacity = dd.outputs - totalOutputsUsed;

                        if (availableCapacity > 0) {
                            dd.assignedUniverses.push(universeNum);
                            assigned.add(universeNum);
                            break;
                        }
                    }
                });

                // STEP 2: Try to assign split universes to Opti Splitters for replication
                // If successful, splitter handles the split (node doesn't need extra output)
                // If not, node handles the split (needs extra output)
                splitUniverses.forEach(splitInfo => {
                    const universeNum = splitInfo.universe;
                    let assignedToSplitter = false;

                    // Try to assign to a splitter for downstream replication
                    for (let dd of splitters) {
                        const availableCapacity = dd.universes - dd.assignedUniverses.length;

                        if (availableCapacity > 0) {
                            // Add to splitter's list (splitter receives from node and replicates)
                            if (!dd.assignedUniverses.includes(universeNum)) {
                                dd.assignedUniverses.push(universeNum);
                            }

                            // Track as split universe on splitter
                            if (!dd.splitUniverses) dd.splitUniverses = [];
                            if (!dd.splitUniverses.some(su => su.universe === universeNum)) {
                                dd.splitUniverses.push(splitInfo);
                            }

                            assignedToSplitter = true;
                            break;
                        }
                    }

                    // If NOT assigned to a splitter, the node must handle the split (needs extra output)
                    if (!assignedToSplitter) {
                        // Find which node has this universe and mark it as needing split handling
                        for (let dd of nodes) {
                            if (dd.assignedUniverses.includes(universeNum)) {
                                if (!dd.splitUniverses) dd.splitUniverses = [];
                                if (!dd.splitUniverses.some(su => su.universe === universeNum)) {
                                    dd.splitUniverses.push(splitInfo);
                                }
                                break;
                            }
                        }
                    }
                });
            }

            function renderDDs() {
                const grid = $('ddGrid');

                if (projectData.dataDistributions.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üåê</div>
                            <div class="empty-state-text">No data distributions yet</div>
                        </div>
                    `;
                    return;
                }

                // Count devices by type to determine if we should show manage buttons
                const nodes = projectData.dataDistributions.filter(d => d.deviceType === 'node');
                const splitters = projectData.dataDistributions.filter(d => d.deviceType === 'splitter');
                const hasMultipleNodes = nodes.length >= 2;
                const hasNodeAndSplitter = nodes.length >= 1 && splitters.length >= 1;

                grid.innerHTML = projectData.dataDistributions.map((dd, index) => {
                    const assignedCount = dd.assignedUniverses ? dd.assignedUniverses.length : 0;
                    const splitCount = dd.splitUniverses ? dd.splitUniverses.length : 0;

                    const deviceIcon = dd.deviceType === 'node' ? 'üß†' : 'üéõÔ∏è';
                    const deviceTypeLabel = dd.deviceType === 'node' ? 'Node' : 'Opti Splitter';

                    // Calculate capacity differently for Nodes vs Splitters
                    let capacityDisplay = '';
                    let usagePct = 0;

                    if (dd.deviceType === 'node') {
                        // Nodes: track output port usage (universes + split outputs)
                        const totalOutputsUsed = assignedCount + splitCount;
                        usagePct = dd.outputs > 0 ? (totalOutputsUsed / dd.outputs) * 100 : 0;
                        const barClass = usagePct > 90 ? 'danger' : usagePct > 75 ? 'warning' : '';

                        capacityDisplay = `
                            <div style="font-size: 10px; margin-top: 6px;">
                                Output Usage: ${totalOutputsUsed}/${dd.outputs} Ports (${usagePct.toFixed(0)}%)
                                ${splitCount > 0 ? `<span style="color: var(--text-soft);"> ‚Ä¢ ${assignedCount} base + ${splitCount} split</span>` : ''}
                            </div>
                            <div class="capacity-bar">
                                <div class="capacity-fill ${barClass}" style="width: ${usagePct}%"></div>
                            </div>
                        `;
                    } else {
                        // Splitters: just track universe capacity
                        usagePct = dd.universes > 0 ? (assignedCount / dd.universes) * 100 : 0;
                        const barClass = usagePct > 90 ? 'danger' : usagePct > 75 ? 'warning' : '';

                        capacityDisplay = `
                            <div style="font-size: 10px; margin-top: 6px;">Capacity: ${assignedCount}/${dd.universes} Universe${dd.universes > 1 ? 's' : ''} (${usagePct.toFixed(0)}%)</div>
                            <div class="capacity-bar">
                                <div class="capacity-fill ${barClass}" style="width: ${usagePct}%"></div>
                            </div>
                        `;
                    }

                    // Build assigned universes display
                    let assignedDisplay = '';
                    if (assignedCount > 0) {
                        assignedDisplay = `
                            <div style="margin-top: 8px; font-size: 10px;">
                                <div style="font-weight: 600; margin-bottom: 4px;">Assigned Universes:</div>
                                <div>${dd.assignedUniverses.join(', ')}</div>
                            </div>
                        `;
                    }

                    // Build split universes display
                    let splitDisplay = '';
                    if (splitCount > 0) {
                        const splitDetails = dd.splitUniverses.map(su => {
                            return `Universe ${su.universe} (${su.positionCount} positions: ${su.positions.join(', ')})`;
                        }).join('<br/>');

                        const splitLabel = dd.deviceType === 'node'
                            ? 'üîÄ Handling Split Universes (needs extra outputs):'
                            : 'üîÄ Replicating Split Universes:';

                        splitDisplay = `
                            <div style="margin-top: 8px; font-size: 10px; border-top: 1px solid var(--border); padding-top: 8px;">
                                <div style="font-weight: 600; margin-bottom: 4px; color: var(--orange);">
                                    ${splitLabel} (${splitCount})
                                </div>
                                <div style="line-height: 1.4;">${splitDetails}</div>
                            </div>
                        `;
                    }

                    // Build manage buttons section
                    let manageButtons = '';
                    if (dd.deviceType === 'node') {
                        // Node-to-Node universe management
                        if (hasMultipleNodes) {
                            const otherNodes = nodes.filter(n => n.id !== dd.id);
                            manageButtons += `
                                <div style="margin-top: 8px; border-top: 1px solid var(--border); padding-top: 8px;">
                                    <div style="font-size: 10px; font-weight: 600; margin-bottom: 4px;">Manage Universes:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            `;
                            otherNodes.forEach(otherNode => {
                                manageButtons += `<button class="btn" style="font-size: 10px; padding: 4px 8px;" onclick="openUniverseManage('${dd.id}', '${otherNode.id}', 'universe')">‚áÑ ${otherNode.name}</button>`;
                            });
                            manageButtons += `</div></div>`;
                        }

                        // Node-to-Splitter split universe management
                        if (hasNodeAndSplitter && splitCount > 0) {
                            manageButtons += `
                                <div style="margin-top: 8px; border-top: 1px solid var(--border); padding-top: 8px;">
                                    <div style="font-size: 10px; font-weight: 600; margin-bottom: 4px;">Manage Split Universes:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            `;
                            splitters.forEach(splitter => {
                                manageButtons += `<button class="btn" style="font-size: 10px; padding: 4px 8px;" onclick="openUniverseManage('${dd.id}', '${splitter.id}', 'split')">üîÄ ${splitter.name}</button>`;
                            });
                            manageButtons += `</div></div>`;
                        }
                    } else if (dd.deviceType === 'splitter') {
                        // Splitter-to-Node split universe management (reverse direction)
                        if (hasNodeAndSplitter && nodes.length > 0) {
                            manageButtons += `
                                <div style="margin-top: 8px; border-top: 1px solid var(--border); padding-top: 8px;">
                                    <div style="font-size: 10px; font-weight: 600; margin-bottom: 4px;">Manage Split Universes:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            `;
                            nodes.forEach(node => {
                                if (node.splitUniverses && node.splitUniverses.length > 0) {
                                    manageButtons += `<button class="btn" style="font-size: 10px; padding: 4px 8px;" onclick="openUniverseManage('${node.id}', '${dd.id}', 'split')">üîÄ ${node.name}</button>`;
                                }
                            });
                            manageButtons += `</div></div>`;
                        }
                    }

                    return `
                        <div class="dd-card">
                            <div class="dd-card-header">
                                <div class="dd-card-title">${deviceIcon} ${dd.name}</div>
                                <div class="dd-card-actions">
                                    <button class="btn" onclick="editDD('${dd.id}')">Edit</button>
                                    <button class="btn" onclick="deleteDD('${dd.id}')">√ó</button>
                                </div>
                            </div>
                            <div class="dd-card-specs">
                                ${deviceTypeLabel} ‚Ä¢ ${dd.universes} Universe${dd.universes > 1 ? 's' : ''} ‚Ä¢ ${dd.outputs} Output${dd.outputs > 1 ? 's' : ''} ‚Ä¢ ${dd.connector}
                            </div>
                            ${dd.notes ? `<div style="font-size: 10px; color: var(--text-soft); margin-top: 4px;">${dd.notes}</div>` : ''}
                            ${capacityDisplay}
                            ${assignedDisplay}
                            ${splitDisplay}
                            ${manageButtons}
                        </div>
                    `;
                }).join('');
            }

            function deleteDD(id) {
                if (!confirm('Delete this data distribution?')) return;
                projectData.dataDistributions = projectData.dataDistributions.filter(dd => dd.id !== id);

                // Reassign universes
                autoAssignUniverses();

                renderDDs();
                renderConnections();
                updateStats();
                markProjectUpdated();
            }

            function editDD(id) {
                // TODO: Implement edit functionality
                alert('Edit functionality coming soon!');
            }

            // ============================================
            // Universe Management Between Devices
            // ============================================
            let universeManageState = {
                sourceDeviceId: null,
                destDeviceId: null,
                transferType: null, // 'universe' or 'split'
                selectedSource: [],
                selectedDest: []
            };

            function openUniverseManage(sourceId, destId, transferType = 'universe') {
                const sourceDevice = projectData.dataDistributions.find(dd => dd.id === sourceId);
                const destDevice = projectData.dataDistributions.find(dd => dd.id === destId);

                if (!sourceDevice || !destDevice) {
                    alert('Device not found');
                    return;
                }

                universeManageState = {
                    sourceDeviceId: sourceId,
                    destDeviceId: destId,
                    transferType: transferType,
                    selectedSource: [],
                    selectedDest: []
                };

                // Update modal title based on transfer type
                const modalHeader = transferType === 'split' ? 'Manage Split Universe Assignments' : 'Manage Universe Assignments';
                document.querySelector('#universeManageModal .modal-header').textContent = modalHeader;

                // Update device names
                $('sourceDeviceName').textContent = `${sourceDevice.name} (Source)`;
                $('destDeviceName').textContent = `${destDevice.name} (Destination)`;

                // Render universe lists
                renderUniverseManageModal();

                // Show modal
                $('universeManageModal').classList.add('active');
            }

            function renderUniverseManageModal() {
                const sourceDevice = projectData.dataDistributions.find(dd => dd.id === universeManageState.sourceDeviceId);
                const destDevice = projectData.dataDistributions.find(dd => dd.id === universeManageState.destDeviceId);

                if (!sourceDevice || !destDevice) return;

                const transferType = universeManageState.transferType;

                // Render source list
                const sourceList = $('sourceUniverseList');
                sourceList.innerHTML = '';

                if (transferType === 'universe') {
                    // Show regular assigned universes
                    if (sourceDevice.assignedUniverses && sourceDevice.assignedUniverses.length > 0) {
                        sourceDevice.assignedUniverses.forEach(universeNum => {
                            const item = document.createElement('div');
                            item.className = 'universe-item';
                            item.textContent = `Universe ${universeNum}`;
                            item.onclick = () => toggleSourceSelection(universeNum, false);
                            if (universeManageState.selectedSource.some(s => s.universe === universeNum && !s.isSplit)) {
                                item.classList.add('selected');
                            }
                            sourceList.appendChild(item);
                        });
                    } else {
                        sourceList.innerHTML = '<div style="font-size: 10px; color: var(--text-softer);">No universes assigned</div>';
                    }
                } else {
                    // Show split universes
                    if (sourceDevice.splitUniverses && sourceDevice.splitUniverses.length > 0) {
                        sourceDevice.splitUniverses.forEach(splitInfo => {
                            const item = document.createElement('div');
                            item.className = 'universe-item split';
                            item.innerHTML = `Universe ${splitInfo.universe}<br/><span style="font-size: 9px;">(${splitInfo.positionCount} positions)</span>`;
                            item.onclick = () => toggleSourceSelection(splitInfo.universe, true);
                            if (universeManageState.selectedSource.some(s => s.universe === splitInfo.universe && s.isSplit)) {
                                item.classList.add('selected');
                            }
                            sourceList.appendChild(item);
                        });
                    } else {
                        sourceList.innerHTML = '<div style="font-size: 10px; color: var(--text-softer);">No split universes</div>';
                    }
                }

                // Render destination list
                const destList = $('destUniverseList');
                destList.innerHTML = '';

                if (transferType === 'universe') {
                    // Show regular assigned universes
                    if (destDevice.assignedUniverses && destDevice.assignedUniverses.length > 0) {
                        destDevice.assignedUniverses.forEach(universeNum => {
                            const item = document.createElement('div');
                            item.className = 'universe-item';
                            item.textContent = `Universe ${universeNum}`;
                            item.onclick = () => toggleDestSelection(universeNum, false);
                            if (universeManageState.selectedDest.some(s => s.universe === universeNum && !s.isSplit)) {
                                item.classList.add('selected');
                            }
                            destList.appendChild(item);
                        });
                    } else {
                        destList.innerHTML = '<div style="font-size: 10px; color: var(--text-softer);">No universes assigned</div>';
                    }

                    // Update capacity info for destination
                    const assignedCount = destDevice.assignedUniverses ? destDevice.assignedUniverses.length : 0;
                    const splitCount = destDevice.splitUniverses ? destDevice.splitUniverses.length : 0;
                    if (destDevice.deviceType === 'node') {
                        const totalUsed = assignedCount + splitCount;
                        const available = destDevice.outputs - totalUsed;
                        $('destCapacityInfo').textContent = `(${available} ports available)`;
                    } else {
                        const available = destDevice.universes - assignedCount;
                        $('destCapacityInfo').textContent = `(${available} slots available)`;
                    }
                } else {
                    // Show split universes for destination
                    if (destDevice.splitUniverses && destDevice.splitUniverses.length > 0) {
                        destDevice.splitUniverses.forEach(splitInfo => {
                            const item = document.createElement('div');
                            item.className = 'universe-item split';
                            item.innerHTML = `Universe ${splitInfo.universe}<br/><span style="font-size: 9px;">(${splitInfo.positionCount} positions)</span>`;
                            item.onclick = () => toggleDestSelection(splitInfo.universe, true);
                            if (universeManageState.selectedDest.some(s => s.universe === splitInfo.universe && s.isSplit)) {
                                item.classList.add('selected');
                            }
                            destList.appendChild(item);
                        });
                    } else {
                        destList.innerHTML = '<div style="font-size: 10px; color: var(--text-softer);">No split universes</div>';
                    }

                    // For splitters, show capacity
                    const splitCount = destDevice.splitUniverses ? destDevice.splitUniverses.length : 0;
                    const available = destDevice.universes - splitCount;
                    $('destCapacityInfo').textContent = `(${available} slots available)`;
                }
            }

            function toggleSourceSelection(universeNum, isSplit) {
                const index = universeManageState.selectedSource.findIndex(s => s.universe === universeNum && s.isSplit === isSplit);
                if (index > -1) {
                    universeManageState.selectedSource.splice(index, 1);
                } else {
                    universeManageState.selectedSource.push({ universe: universeNum, isSplit: isSplit });
                }
                renderUniverseManageModal();
            }

            function toggleDestSelection(universeNum, isSplit) {
                const index = universeManageState.selectedDest.findIndex(s => s.universe === universeNum && s.isSplit === isSplit);
                if (index > -1) {
                    universeManageState.selectedDest.splice(index, 1);
                } else {
                    universeManageState.selectedDest.push({ universe: universeNum, isSplit: isSplit });
                }
                renderUniverseManageModal();
            }

            function moveUniverseRight() {
                // Move selected from source to destination
                if (universeManageState.selectedSource.length === 0) {
                    alert('Please select universes to move');
                    return;
                }

                const sourceDevice = projectData.dataDistributions.find(dd => dd.id === universeManageState.sourceDeviceId);
                const destDevice = projectData.dataDistributions.find(dd => dd.id === universeManageState.destDeviceId);

                if (!sourceDevice || !destDevice) return;

                const transferType = universeManageState.transferType;

                // Check capacity
                const assignedCount = destDevice.assignedUniverses ? destDevice.assignedUniverses.length : 0;
                const splitCount = destDevice.splitUniverses ? destDevice.splitUniverses.length : 0;

                let available = 0;
                if (destDevice.deviceType === 'node') {
                    const totalUsed = assignedCount + splitCount;
                    available = destDevice.outputs - totalUsed;
                } else {
                    if (transferType === 'universe') {
                        available = destDevice.universes - assignedCount;
                    } else {
                        available = destDevice.universes - splitCount;
                    }
                }

                if (universeManageState.selectedSource.length > available) {
                    alert(`Destination device only has ${available} available slots`);
                    return;
                }

                // Move the universes
                universeManageState.selectedSource.forEach(selected => {
                    if (transferType === 'universe' && !selected.isSplit) {
                        // Move regular universe
                        const universeNum = selected.universe;
                        const index = sourceDevice.assignedUniverses.indexOf(universeNum);
                        if (index > -1) {
                            sourceDevice.assignedUniverses.splice(index, 1);
                        }

                        // Also check if this universe is tracked as a split universe
                        const splitIndex = sourceDevice.splitUniverses ? sourceDevice.splitUniverses.findIndex(su => su.universe === universeNum) : -1;
                        let splitInfo = null;
                        if (splitIndex > -1) {
                            splitInfo = sourceDevice.splitUniverses[splitIndex];
                            sourceDevice.splitUniverses.splice(splitIndex, 1);
                        }

                        // Add to destination
                        if (!destDevice.assignedUniverses) destDevice.assignedUniverses = [];
                        if (!destDevice.assignedUniverses.includes(universeNum)) {
                            destDevice.assignedUniverses.push(universeNum);
                        }

                        // If it was a split, add to destination splits too
                        if (splitInfo) {
                            if (!destDevice.splitUniverses) destDevice.splitUniverses = [];
                            destDevice.splitUniverses.push(splitInfo);
                        }
                    } else if (transferType === 'split' && selected.isSplit) {
                        // Move split universe handling responsibility
                        const splitIndex = sourceDevice.splitUniverses.findIndex(su => su.universe === selected.universe);
                        if (splitIndex > -1) {
                            const splitInfo = sourceDevice.splitUniverses[splitIndex];

                            // If moving FROM a Node TO a Splitter:
                            // Node keeps base universe, removes split responsibility
                            // Splitter gains split responsibility
                            if (sourceDevice.deviceType === 'node' && destDevice.deviceType === 'splitter') {
                                // Remove split from node (node keeps base universe but doesn't handle split anymore)
                                sourceDevice.splitUniverses.splice(splitIndex, 1);

                                // Splitter receives the universe and handles the split
                                if (!destDevice.assignedUniverses) destDevice.assignedUniverses = [];
                                if (!destDevice.assignedUniverses.includes(selected.universe)) {
                                    destDevice.assignedUniverses.push(selected.universe);
                                }

                                if (!destDevice.splitUniverses) destDevice.splitUniverses = [];
                                destDevice.splitUniverses.push(splitInfo);
                            }
                            // If moving FROM a Splitter TO a Node:
                            // Splitter loses universe entirely
                            // Node gains split responsibility (already has base universe)
                            else if (sourceDevice.deviceType === 'splitter' && destDevice.deviceType === 'node') {
                                // Remove from splitter entirely
                                sourceDevice.splitUniverses.splice(splitIndex, 1);
                                const univIndex = sourceDevice.assignedUniverses.indexOf(selected.universe);
                                if (univIndex > -1) {
                                    sourceDevice.assignedUniverses.splice(univIndex, 1);
                                }

                                // Node gains split responsibility (should already have base universe)
                                if (!destDevice.splitUniverses) destDevice.splitUniverses = [];
                                if (!destDevice.splitUniverses.some(su => su.universe === selected.universe)) {
                                    destDevice.splitUniverses.push(splitInfo);
                                }
                            }
                            // If moving between two nodes: standard move
                            else if (sourceDevice.deviceType === 'node' && destDevice.deviceType === 'node') {
                                sourceDevice.splitUniverses.splice(splitIndex, 1);
                                if (!destDevice.splitUniverses) destDevice.splitUniverses = [];
                                destDevice.splitUniverses.push(splitInfo);

                                const univIndex = sourceDevice.assignedUniverses.indexOf(selected.universe);
                                if (univIndex > -1) {
                                    sourceDevice.assignedUniverses.splice(univIndex, 1);
                                }
                                if (!destDevice.assignedUniverses) destDevice.assignedUniverses = [];
                                if (!destDevice.assignedUniverses.includes(selected.universe)) {
                                    destDevice.assignedUniverses.push(selected.universe);
                                }
                            }
                        }
                    }
                });

                // Clear selection
                universeManageState.selectedSource = [];

                // Re-render
                renderUniverseManageModal();
                renderDDs();
                updateStats();
                markProjectUpdated();
            }

            function moveUniverseLeft() {
                // Move selected from destination to source
                if (universeManageState.selectedDest.length === 0) {
                    alert('Please select universes to move');
                    return;
                }

                const sourceDevice = projectData.dataDistributions.find(dd => dd.id === universeManageState.sourceDeviceId);
                const destDevice = projectData.dataDistributions.find(dd => dd.id === universeManageState.destDeviceId);

                if (!sourceDevice || !destDevice) return;

                const transferType = universeManageState.transferType;

                // Check capacity on source
                const assignedCount = sourceDevice.assignedUniverses ? sourceDevice.assignedUniverses.length : 0;
                const splitCount = sourceDevice.splitUniverses ? sourceDevice.splitUniverses.length : 0;

                let available = 0;
                if (sourceDevice.deviceType === 'node') {
                    const totalUsed = assignedCount + splitCount;
                    available = sourceDevice.outputs - totalUsed;
                } else {
                    if (transferType === 'universe') {
                        available = sourceDevice.universes - assignedCount;
                    } else {
                        available = sourceDevice.universes - splitCount;
                    }
                }

                if (universeManageState.selectedDest.length > available) {
                    alert(`Source device only has ${available} available slots`);
                    return;
                }

                // Move the universes
                universeManageState.selectedDest.forEach(selected => {
                    if (transferType === 'universe' && !selected.isSplit) {
                        // Move regular universe
                        const universeNum = selected.universe;
                        const index = destDevice.assignedUniverses.indexOf(universeNum);
                        if (index > -1) {
                            destDevice.assignedUniverses.splice(index, 1);
                        }

                        // Also check if this universe is tracked as a split universe
                        const splitIndex = destDevice.splitUniverses ? destDevice.splitUniverses.findIndex(su => su.universe === universeNum) : -1;
                        let splitInfo = null;
                        if (splitIndex > -1) {
                            splitInfo = destDevice.splitUniverses[splitIndex];
                            destDevice.splitUniverses.splice(splitIndex, 1);
                        }

                        // Add to source
                        if (!sourceDevice.assignedUniverses) sourceDevice.assignedUniverses = [];
                        if (!sourceDevice.assignedUniverses.includes(universeNum)) {
                            sourceDevice.assignedUniverses.push(universeNum);
                        }

                        // If it was a split, add to source splits too
                        if (splitInfo) {
                            if (!sourceDevice.splitUniverses) sourceDevice.splitUniverses = [];
                            sourceDevice.splitUniverses.push(splitInfo);
                        }
                    } else if (transferType === 'split' && selected.isSplit) {
                        // Move split universe handling responsibility (moving from dest back to source)
                        const splitIndex = destDevice.splitUniverses.findIndex(su => su.universe === selected.universe);
                        if (splitIndex > -1) {
                            const splitInfo = destDevice.splitUniverses[splitIndex];

                            // If moving FROM a Splitter TO a Node:
                            // Splitter loses universe entirely
                            // Node gains split responsibility (already has base universe)
                            if (destDevice.deviceType === 'splitter' && sourceDevice.deviceType === 'node') {
                                // Remove from splitter entirely
                                destDevice.splitUniverses.splice(splitIndex, 1);
                                const univIndex = destDevice.assignedUniverses.indexOf(selected.universe);
                                if (univIndex > -1) {
                                    destDevice.assignedUniverses.splice(univIndex, 1);
                                }

                                // Node gains split responsibility (should already have base universe)
                                if (!sourceDevice.splitUniverses) sourceDevice.splitUniverses = [];
                                if (!sourceDevice.splitUniverses.some(su => su.universe === selected.universe)) {
                                    sourceDevice.splitUniverses.push(splitInfo);
                                }
                            }
                            // If moving FROM a Node TO a Splitter:
                            // Node keeps base universe, removes split responsibility
                            // Splitter gains split responsibility
                            else if (destDevice.deviceType === 'node' && sourceDevice.deviceType === 'splitter') {
                                // Remove split from node (node keeps base universe but doesn't handle split anymore)
                                destDevice.splitUniverses.splice(splitIndex, 1);

                                // Splitter receives the universe and handles the split
                                if (!sourceDevice.assignedUniverses) sourceDevice.assignedUniverses = [];
                                if (!sourceDevice.assignedUniverses.includes(selected.universe)) {
                                    sourceDevice.assignedUniverses.push(selected.universe);
                                }

                                if (!sourceDevice.splitUniverses) sourceDevice.splitUniverses = [];
                                sourceDevice.splitUniverses.push(splitInfo);
                            }
                            // If moving between two nodes: standard move
                            else if (destDevice.deviceType === 'node' && sourceDevice.deviceType === 'node') {
                                destDevice.splitUniverses.splice(splitIndex, 1);
                                if (!sourceDevice.splitUniverses) sourceDevice.splitUniverses = [];
                                sourceDevice.splitUniverses.push(splitInfo);

                                const univIndex = destDevice.assignedUniverses.indexOf(selected.universe);
                                if (univIndex > -1) {
                                    destDevice.assignedUniverses.splice(univIndex, 1);
                                }
                                if (!sourceDevice.assignedUniverses) sourceDevice.assignedUniverses = [];
                                if (!sourceDevice.assignedUniverses.includes(selected.universe)) {
                                    sourceDevice.assignedUniverses.push(selected.universe);
                                }
                            }
                        }
                    }
                });

                // Clear selection
                universeManageState.selectedDest = [];

                // Re-render
                renderUniverseManageModal();
                renderDDs();
                updateStats();
                markProjectUpdated();
            }

            function closeUniverseManageModal() {
                $('universeManageModal').classList.remove('active');
                universeManageState = {
                    sourceDeviceId: null,
                    destDeviceId: null,
                    transferType: null,
                    selectedSource: [],
                    selectedDest: []
                };
            }

            // ============================================
            // Console Management
            // ============================================
            function selectConsole(consoleId) {
                const preset = consolePresets[consoleId];
                if (!preset) return;

                projectData.console = {
                    id: consoleId,
                    ...preset
                };

                // Hide custom form if open
                $('customConsoleForm').style.display = 'none';

                // Update UI to show selected console
                document.querySelectorAll('.console-option').forEach(btn => {
                    btn.classList.remove('selected');
                });
                const selectedBtn = $(`console-${consoleId}`);
                if (selectedBtn) {
                    selectedBtn.classList.add('selected');
                }

                renderConsoleDisplay();
                updateStats();
                updateSectionProgress(); // Mark FOH as complete
                markProjectUpdated();
            }

            function openCustomConsoleForm() {
                // Hide custom console form selection button highlight
                document.querySelectorAll('.console-option').forEach(btn => {
                    btn.classList.remove('selected');
                });
                $('console-custom').classList.add('selected');

                // Show form
                $('customConsoleForm').style.display = 'block';

                // Reset form
                $('customConsoleName').value = '';
                $('customConsoleNetwork').value = '0';
                $('customConsoleCopper').value = '0';
                $('customConsoleNotes').value = '';

                // Hide console display
                $('consoleDisplay').style.display = 'none';
            }

            function cancelCustomConsole() {
                $('customConsoleForm').style.display = 'none';
                document.querySelectorAll('.console-option').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Show previous console if exists
                if (projectData.console) {
                    renderConsoleDisplay();
                }
            }

            function saveCustomConsole() {
                const name = $('customConsoleName').value.trim();
                const networkUniverses = parseInt($('customConsoleNetwork').value) || 0;
                const copperUniverses = parseInt($('customConsoleCopper').value) || 0;
                const notes = $('customConsoleNotes').value.trim();

                if (!name) {
                    alert('Please enter a console name');
                    return;
                }

                if (networkUniverses === 0 && copperUniverses === 0) {
                    alert('Please enter at least one universe capacity (Network or Copper)');
                    return;
                }

                // Determine output mode
                let outputMode = 'simultaneous';
                if (networkUniverses > 0 && copperUniverses === 0) {
                    outputMode = 'network-only';
                } else if (networkUniverses === 0 && copperUniverses > 0) {
                    outputMode = 'copper-only';
                }

                // Create custom console object
                projectData.console = {
                    id: 'custom',
                    name: name,
                    manufacturer: 'Custom',
                    maxUniverses: {
                        network: networkUniverses,
                        copper: copperUniverses
                    },
                    outputMode: outputMode,
                    description: notes || `${networkUniverses} Network, ${copperUniverses} Copper`,
                    notes: notes
                };

                // Hide form
                $('customConsoleForm').style.display = 'none';

                renderConsoleDisplay();
                updateStats();
                updateSectionProgress(); // Mark FOH as complete
                markProjectUpdated();
            }

            function renderConsoleDisplay() {
                // Update selected state on buttons
                if (projectData.console) {
                    document.querySelectorAll('.console-option').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    const selectedBtn = $(`console-${projectData.console.id}`);
                    if (selectedBtn) {
                        selectedBtn.classList.add('selected');
                    }
                }

                if (!projectData.console) {
                    $('consoleDisplay').style.display = 'none';
                    return;
                }

                $('consoleDisplay').style.display = 'block';

                const console = projectData.console;

                // Update console name
                $('consoleName').textContent = `üéõÔ∏è ${console.name}`;

                // Update specs
                $('consoleSpecs').textContent = `${console.manufacturer} ‚Ä¢ ${console.description}`;

                // Calculate usage
                const universesSet = new Set();
                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        const universeAddress = fixture['Universe/Address'];
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                universesSet.add(parseInt(universePart));
                            }
                        }
                    });
                }

                const universesUsed = universesSet.size;

                // Determine which capacity to check based on console type and data mode
                let maxUniverses;
                let capacityLabel;
                let showModeHint = false;

                if (console.outputMode === 'copper-only') {
                    // Copper-only consoles (Quick Q10)
                    maxUniverses = console.maxUniverses.copper;
                    capacityLabel = 'Copper';
                } else if (console.outputMode === 'either') {
                    // Consoles that can do network OR copper (Quick Q20)
                    if (projectData.dataMode === 'network') {
                        maxUniverses = console.maxUniverses.network;
                        capacityLabel = 'Network';
                    } else if (projectData.dataMode === 'copper') {
                        maxUniverses = console.maxUniverses.copper;
                        capacityLabel = 'Copper';
                    } else {
                        // No mode selected - show max of either
                        maxUniverses = Math.max(console.maxUniverses.network, console.maxUniverses.copper);
                        capacityLabel = 'Max';
                        showModeHint = true;
                    }
                } else if (console.outputMode === 'simultaneous') {
                    // Consoles that can do network AND copper (RoadHog4, Full Boar 4)
                    if (projectData.dataMode === 'network') {
                        maxUniverses = console.maxUniverses.network;
                        capacityLabel = 'Network';
                    } else if (projectData.dataMode === 'copper') {
                        maxUniverses = console.maxUniverses.copper;
                        capacityLabel = 'Copper';
                    } else {
                        // No mode selected - show network capacity as default
                        maxUniverses = console.maxUniverses.network;
                        capacityLabel = 'Network';
                        showModeHint = true;
                    }
                }

                const usagePct = maxUniverses > 0 ? (universesUsed / maxUniverses) * 100 : 0;
                const barClass = usagePct > 100 ? 'danger' : usagePct > 75 ? 'warning' : '';
                const overCapacity = universesUsed > maxUniverses;

                let capacityHTML = `
                    <div style="font-size: 10px; margin-top: 6px;">
                        ${capacityLabel} Universe Capacity: ${universesUsed}/${maxUniverses} (${Math.min(usagePct, 100).toFixed(0)}%)
                        ${overCapacity ? `<span style="color: var(--danger); font-weight: 600;"> ‚ö†Ô∏è OVER CAPACITY by ${universesUsed - maxUniverses}</span>` : ''}
                    </div>
                    <div class="capacity-bar">
                        <div class="capacity-fill ${barClass}" style="width: ${Math.min(usagePct, 100)}%"></div>
                    </div>
                `;

                // Show mode details if applicable
                if (showModeHint) {
                    if (console.outputMode === 'either') {
                        capacityHTML += `
                            <div style="font-size: 10px; color: var(--text-soft); margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
                                <div>This console can output ${console.maxUniverses.network} universes via Network OR Copper (not both)</div>
                                <div style="margin-top: 4px; font-style: italic;">Select data mode in BOH section to see specific capacity</div>
                            </div>
                        `;
                    } else if (console.outputMode === 'simultaneous') {
                        capacityHTML += `
                            <div style="font-size: 10px; color: var(--text-soft); margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
                                <div>Network: ${console.maxUniverses.network} universes max</div>
                                <div>Copper: ${console.maxUniverses.copper} universes max (simultaneous)</div>
                                <div style="margin-top: 4px; font-style: italic;">Select data mode in BOH section to see specific capacity</div>
                            </div>
                        `;
                    }
                }

                if (overCapacity) {
                    capacityHTML += `<div style="font-size: 10px; color: var(--danger); margin-top: 4px; font-weight: 500;">‚ö†Ô∏è Console capacity exceeded! Consider upgrading or reducing universes.</div>`;
                }

                $('consoleCapacity').innerHTML = capacityHTML;
            }

            // ============================================
            // Stats Update
            // ============================================
            // ============================================
            // Cable Routing Diagram
            // ============================================
            function renderRoutingDiagram() {
                const svg = document.getElementById('routingDiagram');
                if (!svg) return;

                // Clear previous
                svg.innerHTML = '';

                // Collect all distributions and fixtures
                const distributions = [
                    ...projectData.powerDistributions.map(pd => ({
                        id: `pd-${pd.name}`,
                        name: pd.name,
                        type: 'power-dist',
                        x: 0,
                        y: 0
                    })),
                    ...projectData.dataDistributions.map(dd => ({
                        id: `dd-${dd.name}`,
                        name: dd.name,
                        type: 'data-dist',
                        x: 0,
                        y: 0
                    }))
                ];

                // Get unique fixture positions
                const fixturesByPosition = new Map();
                Object.values(projectData.tsvData || {}).forEach(fixtures => {
                    if (Array.isArray(fixtures)) {
                        fixtures.forEach(fixture => {
                            const pos = fixture.Position || 'Unknown';
                            if (!fixturesByPosition.has(pos)) {
                                fixturesByPosition.set(pos, []);
                            }
                            fixturesByPosition.get(pos).push(fixture);
                        });
                    }
                });

                const positions = Array.from(fixturesByPosition.keys());

                // Layout: distributions on left, positions on right
                const padding = 60;
                const distWidth = 150;
                const distHeight = distributions.length * 120 + 100;
                const posWidth = Math.max(600, positions.length * 180);

                const svgWidth = padding + distWidth + 300 + posWidth + padding;
                const svgHeight = Math.max(distHeight, positions.length * 200 + 120);

                svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

                // Position distributions on left
                distributions.forEach((dist, idx) => {
                    dist.y = padding + idx * 120 + 60;
                    dist.x = padding + 75;
                });

                // Position fixtures on right
                const fixtureNodes = [];
                positions.forEach((pos, idx) => {
                    fixturesByPosition.get(pos).forEach((fixture, subIdx) => {
                        fixtureNodes.push({
                            id: `fixture-${pos}-${subIdx}`,
                            name: fixture['Fixture Type'] || fixture['Name'] || `${pos}-${subIdx}`,
                            position: pos,
                            x: padding + distWidth + 300 + (idx % 3) * 180 + 90,
                            y: padding + idx * 200 + subIdx * 40 + 60
                        });
                    });
                });

                // Draw connections from distributions to positions
                distributions.forEach(dist => {
                    fixtureNodes.forEach(fixture => {
                        // Determine connection type
                        const isPower = dist.type === 'power-dist';
                        const isData = dist.type === 'data-dist';

                        // Draw curved line
                        const x1 = dist.x + 75;
                        const y1 = dist.y;
                        const x2 = fixture.x - 45;
                        const y2 = fixture.y;

                        const midX = (x1 + x2) / 2;
                        const midY = (y1 + y2) / 2 - 20;

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${x1} ${y1} Q ${midX} ${midY} ${x2} ${y2}`);
                        path.setAttribute('class', `diagram-link ${isPower ? 'power' : 'data'}`);
                        path.setAttribute('stroke-dasharray', isData ? '5,5' : 'none');

                        path.addEventListener('mouseenter', () => {
                            path.style.strokeWidth = '4';
                            path.style.opacity = '1';
                        });
                        path.addEventListener('mouseleave', () => {
                            path.style.strokeWidth = '2.5';
                            path.style.opacity = '0.7';
                        });

                        svg.appendChild(path);
                    });
                });

                // Draw distribution nodes
                distributions.forEach(dist => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'diagram-node');

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', dist.x - 60);
                    rect.setAttribute('y', dist.y - 30);
                    rect.setAttribute('width', '120');
                    rect.setAttribute('height', '60');
                    rect.setAttribute('rx', '6');
                    rect.setAttribute('fill', dist.type === 'power-dist' ? '#2563eb' : '#4f46e5');
                    rect.setAttribute('opacity', '0.85');
                    rect.setAttribute('stroke', 'rgba(255,255,255,0.3)');
                    rect.setAttribute('stroke-width', '2');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', dist.x);
                    text.setAttribute('y', dist.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '11');
                    text.setAttribute('font-weight', '600');
                    text.textContent = dist.name.substring(0, 14);

                    const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    icon.setAttribute('x', dist.x - 45);
                    icon.setAttribute('y', dist.y - 8);
                    icon.setAttribute('font-size', '18');
                    icon.textContent = dist.type === 'power-dist' ? '‚ö°' : 'üåê';

                    g.appendChild(rect);
                    g.appendChild(icon);
                    g.appendChild(text);
                    svg.appendChild(g);
                });

                // Draw fixture nodes
                fixtureNodes.forEach(fixture => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'diagram-node');

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', fixture.x - 40);
                    rect.setAttribute('y', fixture.y - 20);
                    rect.setAttribute('width', '80');
                    rect.setAttribute('height', '40');
                    rect.setAttribute('rx', '4');
                    rect.setAttribute('fill', '#10b981');
                    rect.setAttribute('opacity', '0.85');
                    rect.setAttribute('stroke', 'rgba(255,255,255,0.3)');
                    rect.setAttribute('stroke-width', '1.5');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', fixture.x);
                    text.setAttribute('y', fixture.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '9');
                    text.setAttribute('font-weight', '500');
                    text.textContent = fixture.name.substring(0, 12);

                    g.appendChild(rect);
                    g.appendChild(text);
                    svg.appendChild(g);
                });

                // Add defs for gradients
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                gradient.setAttribute('id', 'distGradient');
                gradient.setAttribute('x1', '0%');
                gradient.setAttribute('y1', '0%');
                gradient.setAttribute('x2', '100%');
                gradient.setAttribute('y2', '100%');

                const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop1.setAttribute('offset', '0%');
                stop1.setAttribute('stop-color', '#2563eb');
                stop1.setAttribute('stop-opacity', '1');

                const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop2.setAttribute('offset', '100%');
                stop2.setAttribute('stop-color', '#4f46e5');
                stop2.setAttribute('stop-opacity', '1');

                gradient.appendChild(stop1);
                gradient.appendChild(stop2);
                defs.appendChild(gradient);
                svg.insertBefore(defs, svg.firstChild);
            }

            function updateStats() {
                const hasMVR = !!uploadedFiles.mvr;
                const hasTXT = !!uploadedFiles.txt;
                const hasMVRandTXT = hasMVR && hasTXT;

                // Global Upload Prompt Control
                const globalUploadPrompt = $('globalUploadPrompt');
                const globalPromptIcon = $('globalPromptIcon');
                const globalPromptTitle = $('globalPromptTitle');
                const circuitAssignmentStats = $('circuitAssignmentStats');
                const bohStats = $('bohStats');

                if (hasMVRandTXT) {
                    // Both files loaded - hide prompt, show all stats
                    globalUploadPrompt.style.display = 'none';
                    circuitAssignmentStats.style.display = 'block';
                    bohStats.style.display = 'block';
                } else if (hasTXT) {
                    // TXT loaded - show stats immediately, keep prompt for missing MVR
                    globalUploadPrompt.style.display = 'block';
                    circuitAssignmentStats.style.display = 'block';
                    bohStats.style.display = 'block';
                    globalPromptIcon.textContent = 'üî¥';
                    globalPromptTitle.textContent = 'Upload MVR using toolbar above';
                } else if (hasMVR) {
                    // MVR only - show prompt for TXT, keep stats visible with placeholders
                    globalUploadPrompt.style.display = 'block';
                    circuitAssignmentStats.style.display = 'block';
                    bohStats.style.display = 'block';
                    globalPromptIcon.textContent = 'üü¢';
                    globalPromptTitle.textContent = 'Upload TXT using toolbar above';
                } else {
                    // No files - show generic prompt, keep stats visible with placeholders
                    globalUploadPrompt.style.display = 'block';
                    circuitAssignmentStats.style.display = 'block';
                    bohStats.style.display = 'block';
                    globalPromptIcon.textContent = 'üî¥üü¢';
                    globalPromptTitle.textContent = 'Upload MVR & TXT using toolbar above';
                }

                // Update Universe Assignment stats if data mode is selected
                if (projectData.dataMode) {
                    $('universeAssignmentStats').style.display = 'block';

                    // Get all universes from fixtures
                    const universesSet = new Set();
                    if (projectData.fixtures && projectData.fixtures.length > 0) {
                        projectData.fixtures.forEach(fixture => {
                            const universeAddress = fixture['Universe/Address'];
                            if (universeAddress) {
                                const universePart = universeAddress.split('/')[0];
                                if (universePart) {
                                    universesSet.add(parseInt(universePart));
                                }
                            }
                        });
                    }

                    const totalUniverses = universesSet.size;

                    // Calculate assigned universes
                    const assignedUniverses = new Set();
                    projectData.dataDistributions.forEach(dd => {
                        if (dd.assignedUniverses) {
                            dd.assignedUniverses.forEach(u => assignedUniverses.add(u));
                        }
                    });

                    const totalAssigned = assignedUniverses.size;
                    const unassigned = totalUniverses - totalAssigned;

                    // Detect split universes
                    const splitUniverses = detectSplitUniverses();
                    const totalSplits = splitUniverses.length;

                    // Determine status
                    let status = '-';
                    if (totalUniverses > 0) {
                        if (totalAssigned === totalUniverses) {
                            status = '‚úÖ Complete';
                        } else if (totalAssigned > 0) {
                            status = `‚ö†Ô∏è Partial (${totalAssigned}/${totalUniverses})`;
                        } else {
                            status = '‚ùå None Assigned';
                        }
                    }

                    // Update UI
                    $('statDataMode').textContent = projectData.dataMode === 'network' ? 'Network (EtherCON)' : 'Copper (DMX 5-pin)';
                    $('statUniversesTotal').textContent = totalUniverses;
                    $('statUniversesAssigned').textContent = totalAssigned;
                    $('statUniversesUnassigned').textContent = unassigned;
                    $('statSplitUniverses').textContent = totalSplits;
                    $('statUniversesStatus').textContent = status;
                } else {
                    $('universeAssignmentStats').style.display = 'none';
                }

                // Get circuits from fixtures
                const circuits = getCircuitsFromFixtures();

                // Calculate assignments
                const assigned120 = new Set();
                const assigned208 = new Set();

                projectData.powerDistributions.forEach(pd => {
                    if (pd.assignedCircuits) {
                        pd.assignedCircuits.forEach(circuit => {
                            if (circuit.voltage === 120) {
                                assigned120.add(circuit.multName);
                            } else if (circuit.voltage === 208) {
                                assigned208.add(circuit.multName);
                            }
                        });
                    }
                });

                // Update circuit assignment stats
                const total120 = circuits.mults120.length;
                const totalAssigned120 = assigned120.size;
                const unassigned120 = total120 - totalAssigned120;

                const total208 = circuits.mults208.length;
                const totalAssigned208 = assigned208.size;
                const unassigned208 = total208 - totalAssigned208;

                $('stat120Total').textContent = total120;
                $('stat120Assigned').textContent = totalAssigned120;
                $('stat120Unassigned').textContent = unassigned120;

                $('stat208Total').textContent = total208;
                $('stat208Assigned').textContent = totalAssigned208;
                $('stat208Unassigned').textContent = unassigned208;

                // Calculate Power Distribution status
                const totalCircuits = total120 + total208;
                const totalAssignedCircuits = totalAssigned120 + totalAssigned208;
                let circuitsStatus = '-';

                if (totalCircuits > 0) {
                    if (totalAssignedCircuits === totalCircuits) {
                        circuitsStatus = '‚úÖ Complete';
                    } else if (totalAssignedCircuits > 0) {
                        circuitsStatus = `‚ö†Ô∏è Partial (${totalAssignedCircuits}/${totalCircuits})`;
                    } else {
                        circuitsStatus = '‚ùå None Assigned';
                    }
                }

                $('statCircuitsStatus').textContent = circuitsStatus;

                // Count unique MULTs from imported fixture data (Circuit Name field)
                const multNamesMap = new Map(); // Map to track mults and detect 208V
                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        const circuitName = fixture['Circuit Name'];
                        if (circuitName && circuitName !== '-' && circuitName.trim() !== '') {
                            const trimmed = circuitName.trim();
                            // Detect if mult has 208V indicator
                            const is208V = /\*208|208V/i.test(trimmed);
                            // Store the original name for display
                            if (!multNamesMap.has(trimmed)) {
                                multNamesMap.set(trimmed, is208V);
                            }
                        }
                    });
                }

                const uniqueMults = multNamesMap.size;
                $('statMults').textContent = uniqueMults;

                // Render MULTs list with pills
                const multsList = $('multsList');
                multsList.innerHTML = '';
                if (multNamesMap.size > 0) {
                    // Sort alphabetically
                    const sortedMults = Array.from(multNamesMap.entries()).sort((a, b) =>
                        a[0].localeCompare(b[0])
                    );

                    sortedMults.forEach(([multName, is208V]) => {
                        const pill = document.createElement('span');
                        pill.className = 'pill' + (is208V ? ' volt-208' : '');
                        pill.textContent = multName;
                        multsList.appendChild(pill);
                    });
                } else {
                    multsList.innerHTML = '<span style="font-size: 10px; color: var(--text-softer);">No MULTs found</span>';
                }

                // Calculate universes from imported fixtures
                const universesMap = new Map(); // Map to track universe -> Set of unique positions
                if (projectData.fixtures && projectData.fixtures.length > 0) {
                    projectData.fixtures.forEach(fixture => {
                        const universeAddress = fixture['Universe/Address'];
                        const position = fixture['Position'];
                        if (universeAddress) {
                            const universePart = universeAddress.split('/')[0];
                            if (universePart) {
                                const universeNum = parseInt(universePart);
                                if (!isNaN(universeNum)) {
                                    // Track unique positions per universe
                                    if (!universesMap.has(universeNum)) {
                                        universesMap.set(universeNum, new Set());
                                    }
                                    // Add position to the set (only if it exists and isn't '-')
                                    if (position && position !== '-' && position.trim() !== '') {
                                        universesMap.get(universeNum).add(position.trim());
                                    }
                                }
                            }
                        }
                    });
                }

                const totalUniverses = universesMap.size;
                $('statUniverses').textContent = totalUniverses;

                // Render Universes list with pills
                const universesList = $('universesList');
                universesList.innerHTML = '';
                if (universesMap.size > 0) {
                    // Sort numerically
                    const sortedUniverses = Array.from(universesMap.entries()).sort((a, b) => a[0] - b[0]);

                    sortedUniverses.forEach(([universeNum, positionSet]) => {
                        const positionCount = positionSet.size;
                        const pill = document.createElement('span');

                        // Add multi-position class if 2 or more positions
                        pill.className = 'pill' + (positionCount >= 2 ? ' multi-position' : '');

                        // Show universe number with position count
                        pill.textContent = `Universe ${universeNum} (${positionCount})`;

                        // Add hover tooltip with position details
                        const positionList = Array.from(positionSet).sort().join(', ');
                        pill.title = `${positionCount} position${positionCount !== 1 ? 's' : ''}: ${positionList}`;

                        universesList.appendChild(pill);
                    });
                } else {
                    universesList.innerHTML = '<span style="font-size: 10px; color: var(--text-softer);">No universes found</span>';
                }

                // Power stats (for detailed view)
                $('statPDs').textContent = projectData.powerDistributions.length;
                $('statCircuits').textContent = projectData.powerDistributions.reduce((sum, pd) => sum + (pd.mults * 6), 0);

                const totalLoad = projectData.powerDistributions.reduce((sum, pd) => {
                    return sum + pd.load.L1 + pd.load.L2 + pd.load.L3;
                }, 0);
                const totalKW = (totalLoad * 208 / 1000).toFixed(1);
                $('statLoad').textContent = `${totalKW} kW`;

                // Data stats (for detailed view)
                $('statDDs').textContent = projectData.dataDistributions.length;
                $('statPorts').textContent = projectData.dataDistributions.reduce((sum, dd) => sum + dd.ports, 0);

                // Fixture stats (for detailed view)
                $('statFixtures').textContent = projectData.fixtures.length;
                $('statAssignedPower').textContent = '0';
                $('statAssignedData').textContent = '0';
            }

            // ============================================
            // Export Functions
            // ============================================
            saveProjectBtn.addEventListener('click', handleSaveProject);
            exportGearPdfBtn.addEventListener('click', handleExportGearPDF);
            exportCablePdfBtn.addEventListener('click', handleExportCablePDF);

            function handleSaveProject() {
                // Create a copy of projectData including source files
                const dataToSave = buildSavePayload();

                // Serialize to JSON
                const json = JSON.stringify(dataToSave, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectData.showName}_network.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Update uploadedFiles to reflect JSON is now available
                uploadedFiles.json = dataToSave;
                updateFileChecklist(uploadedFiles, false);
            }

            function downloadJSONFile() {
                // Same as handleSaveProject but callable from checklist button
                handleSaveProject();
            }

            function handleExportGearPDF() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: "portrait",
                    unit: "in",
                    format: "letter",
                });

                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.text("Network Gear List", 0.5, 0.5);

                doc.setFontSize(10);
                doc.setFont("helvetica", "normal");
                doc.text(`Show: ${projectData.showName}`, 0.5, 0.75);
                doc.text(`Generated: ${new Date().toLocaleDateString()}`, 0.5, 0.95);

                // Power Distributions
                let yPos = 1.3;
                doc.setFontSize(12);
                doc.setFont("helvetica", "bold");
                doc.text("Power Distributions", 0.5, yPos);
                yPos += 0.2;

                doc.setFontSize(10);
                doc.setFont("helvetica", "normal");
                projectData.powerDistributions.forEach(pd => {
                    const circuits120 = pd.circuits120 > 0 ? `${pd.circuits120} √ó 120V` : '';
                    const circuits208 = pd.circuits208 > 0 ? `${pd.circuits208} √ó 208V` : '';
                    const separator = circuits120 && circuits208 ? ', ' : '';

                    doc.text(`‚Ä¢ ${pd.name}: ${circuits120}${separator}${circuits208}`, 0.6, yPos);
                    yPos += 0.2;

                    // Add notes if present
                    if (pd.notes) {
                        doc.setFontSize(9);
                        doc.text(`  ${pd.notes}`, 0.7, yPos);
                        yPos += 0.15;
                        doc.setFontSize(10);
                    }
                });

                // Additional Cables/Gear
                if (projectData.gearList && projectData.gearList.length > 0) {
                    yPos += 0.2;
                    doc.setFontSize(12);
                    doc.setFont("helvetica", "bold");
                    doc.text("Additional Cables & Gear", 0.5, yPos);
                    yPos += 0.2;

                    doc.setFontSize(10);
                    doc.setFont("helvetica", "normal");
                    projectData.gearList.forEach(item => {
                        doc.text(`‚Ä¢ ${item}`, 0.6, yPos);
                        yPos += 0.2;
                    });
                }

                // Data Distributions
                yPos += 0.2;
                doc.setFontSize(12);
                doc.setFont("helvetica", "bold");
                doc.text("Data Distributions", 0.5, yPos);
                yPos += 0.2;

                // Show mode if selected
                if (projectData.dataMode) {
                    doc.setFontSize(10);
                    doc.setFont("helvetica", "italic");
                    const modeText = projectData.dataMode === 'network' ? 'Network Mode (EtherCON)' : 'Copper Mode (DMX 5-pin)';
                    doc.text(`Mode: ${modeText}`, 0.6, yPos);
                    yPos += 0.2;
                }

                doc.setFontSize(10);
                doc.setFont("helvetica", "normal");

                // Group by device type
                const nodes = projectData.dataDistributions.filter(dd => dd.deviceType === 'node');
                const splitters = projectData.dataDistributions.filter(dd => dd.deviceType === 'splitter');

                if (nodes.length > 0) {
                    doc.setFont("helvetica", "bold");
                    doc.text("Nodes:", 0.6, yPos);
                    yPos += 0.15;
                    doc.setFont("helvetica", "normal");

                    nodes.forEach(dd => {
                        const universeList = dd.assignedUniverses && dd.assignedUniverses.length > 0
                            ? ` (Universes: ${dd.assignedUniverses.join(', ')})`
                            : '';
                        doc.text(`‚Ä¢ ${dd.name}: ${dd.universes} Universes, ${dd.outputs} Outputs (${dd.connector})${universeList}`, 0.7, yPos);
                        yPos += 0.15;

                        if (dd.notes) {
                            doc.setFontSize(9);
                            doc.text(`  ${dd.notes}`, 0.8, yPos);
                            yPos += 0.15;
                            doc.setFontSize(10);
                        }

                        // Add split universes if present
                        if (dd.splitUniverses && dd.splitUniverses.length > 0) {
                            doc.setFontSize(9);
                            doc.setFont("helvetica", "italic");
                            doc.text(`  Split Universes (${dd.splitUniverses.length}):`, 0.8, yPos);
                            yPos += 0.15;
                            dd.splitUniverses.forEach(su => {
                                doc.text(`    - Universe ${su.universe} (${su.positionCount} positions: ${su.positions.join(', ')})`, 0.9, yPos);
                                yPos += 0.15;
                            });
                            doc.setFont("helvetica", "normal");
                            doc.setFontSize(10);
                        }
                    });
                    yPos += 0.1;
                }

                if (splitters.length > 0) {
                    doc.setFont("helvetica", "bold");
                    doc.text("Opti Splitters:", 0.6, yPos);
                    yPos += 0.15;
                    doc.setFont("helvetica", "normal");

                    splitters.forEach(dd => {
                        const universeList = dd.assignedUniverses && dd.assignedUniverses.length > 0
                            ? ` (Universes: ${dd.assignedUniverses.join(', ')})`
                            : '';
                        doc.text(`‚Ä¢ ${dd.name}: ${dd.universes} Universe${dd.universes > 1 ? 's' : ''}, ${dd.outputs} Outputs (${dd.connector})${universeList}`, 0.7, yPos);
                        yPos += 0.15;

                        if (dd.notes) {
                            doc.setFontSize(9);
                            doc.text(`  ${dd.notes}`, 0.8, yPos);
                            yPos += 0.15;
                            doc.setFontSize(10);
                        }
                    });
                }

                doc.save(`${projectData.showName}_gear_list.pdf`);
            }

            function handleExportCablePDF() {
                alert('Cable Schedule PDF coming soon!');
            }

            // ============================================
            // Theme Toggle
            // ============================================
            themeToggle.addEventListener('change', (e) => {
                toggleTheme(e.target.checked);
            });

            function toggleTheme(isDark) {
                if (isDark) {
                    document.body.classList.add('dark-theme');
                } else {
                    document.body.classList.remove('dark-theme');
                }
                localStorage.setItem('network_builder_theme', isDark ? 'dark' : 'light');
            }

            function restoreThemePreference() {
                const saved = localStorage.getItem('network_builder_theme');
                if (saved === 'dark') {
                    themeToggle.checked = true;
                    toggleTheme(true);
                } else if (saved === 'light') {
                    themeToggle.checked = false;
                    toggleTheme(false);
                } else {
                    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    themeToggle.checked = prefersDark;
                    toggleTheme(prefersDark);
                }
            }

            // ============================================
            // Initialize
            // ============================================
            lastSnapshot = captureSnapshot();
            updateUndoRedoButtons();
            restoreThemePreference();
            updateStats();
            updateTSVDependentUI(); // Show TSV prompts on initial load
            renderRoutingDiagram(); // Render initial diagram

            // Check for auto-saved project on load
            const autoSaved = loadAutoSavedProject();
            if (autoSaved) {
                uploadedFiles.json = autoSaved;
                updateFileChecklist(uploadedFiles, true);
            }
        </script>
        <div id="toast" class="toast"></div>
    </body>
</html>
