<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>üí°3REP LX Data Entry Tool</title>
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <!-- jsPDF for PDF generation -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
        <style>
            :root {
                --blue: #2563eb;
                --blue-soft: #eff6ff;
                --blue-strong: #1d4ed8;
                --bg: #f3f4f6;
                --bg-dark: #020617;
                --card: #ffffff;
                --card-dark: #020617;
                --border: #e5e7eb;
                --border-soft: #d1d5db;
                --text: #111827;
                --text-soft: #6b7280;
                --text-softer: #9ca3af;
                --danger: #ef4444;
                --warn: #f59e0b;
                --safe: #10b981;
                --font:
                    system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, "Helvetica Neue", Arial, sans-serif;
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                padding: 16px 10px 22px;
                font-family: var(--font);
                background: var(--bg);
                color: var(--text);
                display: flex;
                justify-content: center;
            }
            /* DMX overlap error - red left border instead of background */
            tr.row-overlap {
                box-shadow: inset 4px 0 0 0 var(--danger);
            }

            /* LD columns (green tint) - Channel, Purpose */
            td[data-col-key="Channel"],
            td[data-col-key="Purpose"],
            th[data-col-key="Channel"],
            th[data-col-key="Purpose"] {
                background-color: rgba(16, 185, 129, 0.08);
            }
            body.dark-theme td[data-col-key="Channel"],
            body.dark-theme td[data-col-key="Purpose"],
            body.dark-theme th[data-col-key="Channel"],
            body.dark-theme th[data-col-key="Purpose"] {
                background-color: rgba(16, 185, 129, 0.15);
            }

            /* ME columns (orange tint) - Universe, Address, Mult, Circuit */
            td[data-col-key="Universe"],
            td[data-col-key="Address"],
            td[data-col-key="Mult"],
            td[data-col-key="Circuit"],
            th[data-col-key="Universe"],
            th[data-col-key="Address"],
            th[data-col-key="Mult"],
            th[data-col-key="Circuit"] {
                background-color: rgba(249, 115, 22, 0.08);
            }
            body.dark-theme td[data-col-key="Universe"],
            body.dark-theme td[data-col-key="Address"],
            body.dark-theme td[data-col-key="Mult"],
            body.dark-theme td[data-col-key="Circuit"],
            body.dark-theme th[data-col-key="Universe"],
            body.dark-theme th[data-col-key="Address"],
            body.dark-theme th[data-col-key="Mult"],
            body.dark-theme th[data-col-key="Circuit"] {
                background-color: rgba(249, 115, 22, 0.15);
            }

            /* Reference columns (muted) - DMX Footprint, Orig Ch, Wattage */
            td[data-col-key="DMX Footprint"],
            td[data-col-key="OriginalChannel"],
            td[data-col-key="Wattage"],
            th[data-col-key="DMX Footprint"],
            th[data-col-key="OriginalChannel"],
            th[data-col-key="Wattage"] {
                color: var(--text-softer);
                font-style: italic;
                background-color: rgba(148, 163, 184, 0.06);
            }
            body.dark-theme td[data-col-key="DMX Footprint"],
            body.dark-theme td[data-col-key="OriginalChannel"],
            body.dark-theme td[data-col-key="Wattage"],
            body.dark-theme th[data-col-key="DMX Footprint"],
            body.dark-theme th[data-col-key="OriginalChannel"],
            body.dark-theme th[data-col-key="Wattage"] {
                color: var(--text-softer);
                background-color: rgba(148, 163, 184, 0.1);
            }

            /* Toast notification styles */
            .toast {
                position: fixed;
                bottom: 20px;
                right: 20px;
                max-width: 400px;
                padding: 16px 20px;
                border-radius: 12px;
                background: #fef2f2;
                border: 1px solid #fecaca;
                color: #991b1b;
                font-size: 13px;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                animation: slideIn 0.3s ease-out;
            }
            body.dark-theme .toast {
                background: #450a0a;
                border-color: #7f1d1d;
                color: #fecaca;
            }
            .toast-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                font-weight: 600;
                font-size: 14px;
            }
            .toast-close {
                background: none;
                border: none;
                font-size: 18px;
                cursor: pointer;
                color: inherit;
                opacity: 0.7;
            }
            .toast-close:hover {
                opacity: 1;
            }
            .toast-list {
                margin: 0;
                padding-left: 18px;
            }
            .toast-list li {
                margin-bottom: 4px;
            }
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            body.dark-theme {
                background: #020617;
                color: #e5e7eb;
            }
            body.dark-theme .card,
            body.dark-theme .pane-main,
            body.dark-theme .pane-side,
            body.dark-theme .table-wrap {
                background: var(--card-dark);
                border-color: #1f2937;
            }
            body.dark-theme th {
                background: #111827;
                color: #e5e7eb;
            }
            body.dark-theme td[data-readonly="true"] {
                color: var(--text-softer);
            }
            body.dark-theme .btn {
                background: #020617;
                border-color: #374151;
                color: #e5e7eb;
            }
            body.dark-theme .btn-primary {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                border-color: transparent;
                color: #f9fafb;
            }

            .app-shell {
                width: 100%;
                max-width: 1400px;
            }

            .card {
                background: var(--card);
                border-radius: 20px;
                border: 1px solid var(--border);
                box-shadow: 0 12px 35px rgba(15, 23, 42, 0.12);
                padding: 14px 16px 16px;
            }

            .header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
                flex-wrap: wrap;
                margin-bottom: 8px;
            }

            .brand {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .brand-logo {
                height: 40px;
                width: auto;
                max-width: 120px;
                object-fit: contain;
            }
            .brand-text h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: 0.03em;
            }
            .brand-text span {
                font-size: 11px;
                color: var(--text-soft);
            }

            .toolbar {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                justify-content: flex-end;
                gap: 6px;
            }

            .btn {
                border-radius: 999px;
                border: 1px solid var(--border-soft);
                padding: 5px 11px;
                font-size: 11px;
                background: #f9fafb;
                color: var(--text);
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
                white-space: nowrap;
            }
            .btn .icon {
                font-size: 12px;
            }
            .btn-primary {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                color: #fff;
                border-color: transparent;
            }
            /* LD Button - Green (Channel/Purpose column color) */
            .btn-ld {
                background: rgba(16, 185, 129, 0.9);
                color: #fff;
                border-color: transparent;
            }
            body.dark-theme .btn-ld {
                background: rgba(16, 185, 129, 0.85);
            }
            /* ME Button - Orange (Universe/Mult column color) */
            .btn-me {
                background: rgba(249, 115, 22, 0.9);
                color: #fff;
                border-color: transparent;
            }
            body.dark-theme .btn-me {
                background: rgba(249, 115, 22, 0.85);
            }
            /* Blue Button (CSV Labels, PDF) */
            .btn-blue {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                color: #fff;
                border-color: transparent;
            }
            .btn:disabled {
                opacity: 0.45;
                cursor: default;
            }

            .file-input-wrapper {
                position: relative;
                overflow: hidden;
            }
            .file-input-wrapper input[type="file"] {
                position: absolute;
                inset: 0;
                opacity: 0;
                cursor: pointer;
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 4px 8px;
                border-radius: 999px;
                background: rgba(148, 163, 184, 0.16);
                font-size: 11px;
                border: 1px solid rgba(148, 163, 184, 0.4);
            }
            .pill-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: var(--safe);
                box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.35);
            }
            .pill-history {
                background: rgba(59, 130, 246, 0.08);
                border-color: rgba(59, 130, 246, 0.5);
            }
            .pill-history .label {
                font-size: 11px;
            }

            .theme-switch {
                position: relative;
                display: inline-flex;
                align-items: center;
                cursor: pointer;
                padding: 0;
            }
            .theme-switch input {
                display: none;
            }
            .theme-slider {
                position: relative;
                width: 44px;
                height: 20px;
                background: #e5e7eb;
                border-radius: 999px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0 4px;
                font-size: 11px;
            }
            .theme-knob {
                position: absolute;
                top: 2px;
                left: 2px;
                width: 16px;
                height: 16px;
                border-radius: 999px;
                background: #ffffff;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
                transition: transform 0.16s ease;
            }
            .theme-icon {
                opacity: 0.7;
            }
            body.dark-theme .theme-knob {
                transform: translateX(24px);
            }
            body.dark-theme .theme-slider {
                background: #111827;
                color: #e5e7eb;
            }

            .layout {
                display: grid;
                gap: 10px;
                grid-template-columns: minmax(0, 2.4fr) minmax(280px, 1fr);
                margin-top: 8px;
            }
            @media (max-width: 960px) {
                .layout {
                    grid-template-columns: 1fr;
                }
            }

            .pane-main,
            .pane-side {
                background: var(--card);
                border-radius: 14px;
                border: 1px solid var(--border);
                padding: 10px;
            }

            .pane-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 6px;
            }
            .pane-header-title {
                font-size: 13px;
                font-weight: 600;
            }
            .pane-header-subtitle {
                font-size: 11px;
                color: var(--text-soft);
            }

            .filter-bar {
                display: flex;
                align-items: center;
                gap: 6px;
                margin-bottom: 6px;
            }
            .filter-bar input[type="search"] {
                flex: 1;
                font-size: 11px;
                padding: 5px 7px;
                border-radius: 999px;
                border: 1px solid var(--border-soft);
                background: #f9fafb;
            }

            .table-wrap {
                border-radius: 12px;
                border: 1px solid var(--border);
                overflow: hidden;
                background: var(--card);
            }

            /* Flash animation when auto-scrolled to overlap */
            @keyframes flashRow {
                0%,
                100% {
                    background-color: rgba(255, 255, 0, 0);
                }
                50% {
                    background-color: rgba(255, 255, 0, 0.4);
                }
            }

            tr.row-flash td {
                animation: flashRow 1.2s ease-out;
            }
            .table-scroll {
                max-height: 64vh;
                overflow: auto;
            }

            table {
                border-collapse: collapse;
                width: 100%;
                min-width: 800px;
                font-size: 10px;
                table-layout: auto;
            }

            thead {
                position: sticky;
                top: 0;
                z-index: 2;
                background: #e5e7eb;
            }
            body.dark-theme thead {
                background: #111827;
            }

            th,
            td {
                padding: 3px 4px;
                border-bottom: 1px solid var(--border);
                white-space: nowrap;
            }
            th {
                text-align: center;
                font-weight: 600;
                font-size: 11px;
                user-select: none;
                cursor: pointer;
            }
            th.sorted {
                color: var(--blue-strong);
            }

            td {
                vertical-align: middle;
                text-align: left;
            }
            td[data-readonly="true"] {
                color: var(--text-soft);
            }

            td.col-numeric,
            th.col-numeric {
                text-align: right;
            }

            td input,
            td select {
                width: 100%;
                box-sizing: border-box;
                padding: 2px 4px;
                font-size: 11px;
                border-radius: 6px;
                border: 1px solid transparent;
                background: transparent;
                color: inherit;
            }
            td input:focus,
            td select:focus {
                outline: none;
                border-color: var(--blue-strong);
                background: var(--blue-soft);
            }

            tr.row-cable td {
                opacity: 0.6;
                font-style: italic;
            }

            td.cell-selected {
                box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.9);
                background: rgba(59, 130, 246, 0.12);
            }

            .status-bar {
                padding: 4px 6px;
                border-top: 1px solid var(--border);
                font-size: 11px;
                color: var(--text-soft);
            }

            .asana-notice {
                padding: 12px 16px;
                border-top: 1px solid var(--border);
                background: var(--blue-soft);
                display: none;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
                font-size: 13px;
            }
            .asana-notice.visible {
                display: flex;
            }
            body.dark-theme .asana-notice {
                background: rgba(37, 99, 235, 0.1);
            }
            .asana-notice-text {
                color: var(--text);
                line-height: 1.4;
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .asana-logo {
                height: 20px;
                width: auto;
                flex-shrink: 0;
            }
            .asana-notice-btn {
                padding: 6px 14px;
                background: var(--blue);
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                white-space: nowrap;
                transition: background 0.15s;
            }
            .asana-notice-btn:hover {
                background: var(--blue-strong);
            }

            .stats-block {
                padding: 6px 6px 8px;
                border-radius: 10px;
                border: 1px solid var(--border-soft);
                background: rgba(248, 250, 252, 0.9);
                margin-bottom: 8px;
            }
            body.dark-theme .stats-block {
                background: rgba(15, 23, 42, 0.9);
                border-color: #1f2937;
            }

            .stats-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 11px;
                margin-bottom: 3px;
            }
            .stats-row strong {
                font-size: 12px;
            }

            @keyframes flashRow {
                0%,
                100% {
                    background-color: rgba(255, 255, 0, 0);
                }
                50% {
                    background-color: rgba(255, 255, 0, 0.4);
                }
            }
            tr.row-flash td {
                animation: flashRow 1.2s ease-out;
            }

            .universe-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
                margin-top: 4px;
            }
            .universe-item {
                border-radius: 8px;
                padding: 4px 6px;
                border: 1px solid var(--border-soft);
                background: #f9fafb;
                font-size: 11px;
                display: flex;
                flex-direction: column;
                gap: 3px;
            }
            body.dark-theme .universe-item {
                background: #020617;
            }
            .universe-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .universe-header span.label {
                color: var(--text-soft);
            }
            .universe-header span.value {
                font-variant-numeric: tabular-nums;
            }
            .universe-bar {
                position: relative;
                width: 100%;
                height: 5px;
                border-radius: 999px;
                background: rgba(148, 163, 184, 0.35);
                overflow: hidden;
            }
            .universe-fill {
                position: absolute;
                inset: 0;
                border-radius: inherit;
                transform-origin: left center;
            }

            .mult-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
                margin-top: 4px;
                font-size: 11px;
            }
            .mult-item {
                border-radius: 8px;
                padding: 4px 6px;
                border: 1px solid var(--border-soft);
                background: #f9fafb;
                display: flex;
                flex-direction: column;
                gap: 3px;
            }
            body.dark-theme .mult-item {
                background: #020617;
            }
            .phase-summary {
                display: flex;
                flex-direction: column;
                gap: 4px;
                font-size: 13px;
                margin-top: 6px;
            }
            .phase {
                display: flex;
                justify-content: space-between;
                padding: 4px 6px;
                border-radius: 4px;
                font-weight: 500;
            }
            .phase.l1 {
                background: rgba(255, 0, 0, 0.08);
            }
            .phase.l2 {
                background: rgba(0, 128, 255, 0.08);
            }
            .phase.l3 {
                background: rgba(0, 255, 0, 0.08);
            }
            .phase-balance {
                margin-top: 4px;
                text-align: right;
                font-size: 12px;
                font-style: italic;
                color: var(--text-softer);
            }
            .mult-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 11px;
                gap: 4px;
            }
            .mult-header span.label {
                font-weight: 600;
            }
            .mult-header span.value {
                font-variant-numeric: tabular-nums;
                color: var(--text-soft);
            }
            .mult-volt-toggle {
                display: inline-flex;
                align-items: center;
                gap: 2px;
                font-size: 10px;
                color: var(--text-soft);
            }
            .mult-volt-toggle input {
                margin: 0;
            }
            .mult-circuits {
                display: flex;
                flex-wrap: wrap;
                gap: 3px;
                margin-top: 2px;
            }
            .mult-circuit-entry {
                padding: 2px 5px;
                border-radius: 999px;
                font-variant-numeric: tabular-nums;
                font-size: 10px;
                color: #ffffff;
                box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.35);
            }

            .c1-pill {
                background: #92400e;
            }
            .c2-pill {
                background: #b91c1c;
            }
            .c3-pill {
                background: #ea580c;
            }
            .c4-pill {
                background: #ca8a04;
            }
            .c5-pill {
                background: #16a34a;
            }
            .c6-pill {
                background: #2563eb;
            }

            /* Circuit text colors based on phase leg */
            .circuit-color-1 {
                color: #92400e !important;
                font-weight: 600;
            }
            .circuit-color-2 {
                color: #b91c1c !important;
                font-weight: 600;
            }
            .circuit-color-3 {
                color: #ea580c !important;
                font-weight: 600;
            }
            .circuit-color-4 {
                color: #ca8a04 !important;
                font-weight: 600;
            }
            .circuit-color-5 {
                color: #16a34a !important;
                font-weight: 600;
            }
            .circuit-color-6 {
                color: #2563eb !important;
                font-weight: 600;
            }
            body.dark-theme .circuit-color-1 {
                color: #fbbf24 !important;
            }
            body.dark-theme .circuit-color-2 {
                color: #f87171 !important;
            }
            body.dark-theme .circuit-color-3 {
                color: #fb923c !important;
            }
            body.dark-theme .circuit-color-4 {
                color: #fde047 !important;
            }
            body.dark-theme .circuit-color-5 {
                color: #4ade80 !important;
            }
            body.dark-theme .circuit-color-6 {
                color: #60a5fa !important;
            }

            .amp-safe {
                box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.9);
            }
            .amp-warn {
                box-shadow: 0 0 0 1px rgba(245, 158, 11, 0.95);
            }
            .amp-danger {
                box-shadow: 0 0 0 2px rgba(239, 68, 68, 1);
            }

            .phase-summary {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                margin-top: 4px;
                font-size: 10px;
            }
            .phase-pill {
                padding: 2px 6px;
                border-radius: 999px;
                color: #ffffff;
                font-variant-numeric: tabular-nums;
            }
            .phase-pill.l1 {
                background: #000000;
            }
            .phase-pill.l2 {
                background: #dc2626;
            }
            .phase-pill.l3 {
                background: #1d4ed8;
            }
            .phase-balance {
                margin-top: 4px;
                text-align: right;
                font-size: 12px;
                font-style: italic;
                color: var(--text-softer);
                display: flex;
                flex-direction: column;
                gap: 2px;
            }
            .device-filter-actions {
                display: flex;
                justify-content: flex-end;
                gap: 4px;
                margin: 2px 0 4px;
            }
            .device-filter-list {
                display: flex;
                flex-direction: column;
                gap: 2px;
                max-height: 180px;
                overflow: auto;
                font-size: 11px;
            }
            .device-filter-item {
                display: flex;
                align-items: center;
                gap: 5px;
                padding: 2px 2px;
                border-radius: 6px;
            }
            .device-filter-item:hover {
                background: rgba(148, 163, 184, 0.18);
            }
            .device-filter-item input {
                margin: 0;
            }

            .theme-note {
                font-size: 10px;
                color: var(--text-softer);
                margin-top: 4px;
            }

            /* Preload banner just under toolbar */
            #preloadBanner {
                margin-top: 6px;
            }
            tr.row-selected td {
                background: rgba(59, 130, 246, 0.12);
                box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.4);
            }
            .toolbar {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                flex-wrap: wrap;
                gap: 6px;
            }

            .toolbar-left {
                display: flex;
                align-items: center;
                gap: 10px;
                flex-wrap: wrap;
            }

            .toolbar-right {
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 6px;
            }

            .toolbar-row {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                justify-content: flex-end;
                gap: 6px;
            }
            /* Center align headers and data cells */
            th,
            td {
                text-align: center !important;
                vertical-align: middle;
                padding: 3px 4px;
            }

            /* Keep numeric columns also centered (instead of right-aligned) */
            th.col-numeric,
            td.col-numeric {
                text-align: center !important;
            }

            /* Optional: make header text look cleaner and less cramped */
            th {
                font-weight: 600;
                letter-spacing: 0.03em;
                padding-top: 6px;
                padding-bottom: 6px;
            }

            /* Optional: for more balanced column spacing */
            td {
                padding-top: 5px;
                padding-bottom: 5px;
            }

            /* ====================================
               CUSTOM MODAL SYSTEM
               ==================================== */
            .modal-overlay {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(4px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: modalFadeIn 0.2s ease;
            }

            .modal-container {
                background: var(--card);
                border-radius: 16px;
                border: 1px solid var(--border);
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow: hidden;
                animation: modalSlideUp 0.3s ease;
            }

            body.dark-theme .modal-container {
                background: var(--card-dark);
                border-color: #1f2937;
            }

            .modal-header {
                padding: 20px 24px;
                border-bottom: 1px solid var(--border);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            body.dark-theme .modal-header {
                border-color: #1f2937;
            }

            .modal-title {
                margin: 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--text);
            }

            .modal-close {
                background: none;
                border: none;
                font-size: 28px;
                cursor: pointer;
                color: var(--text-soft);
                line-height: 1;
                padding: 0;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                transition: all 0.15s;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .modal-close:hover {
                background: var(--bg);
                color: var(--text);
            }

            body.dark-theme .modal-close:hover {
                background: #1f2937;
            }

            .modal-body {
                padding: 24px;
                overflow-y: auto;
                max-height: 60vh;
                color: var(--text);
                line-height: 1.6;
            }

            .modal-body p {
                margin: 0 0 12px 0;
            }

            .modal-body p:last-child {
                margin-bottom: 0;
            }

            .modal-body strong {
                color: var(--text);
            }

            .modal-footer {
                padding: 16px 24px;
                border-top: 1px solid var(--border);
                display: flex;
                justify-content: flex-end;
                gap: 8px;
            }

            body.dark-theme .modal-footer {
                border-color: #1f2937;
            }

            .modal-footer .btn {
                border-radius: 8px;
                padding: 8px 16px;
                font-size: 13px;
            }

            .btn-danger {
                background: var(--danger);
                color: #fff;
                border-color: transparent;
            }

            .btn-danger:hover:not(:disabled) {
                background: #dc2626;
            }

            @keyframes modalFadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            @keyframes modalSlideUp {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            @keyframes modalFadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }

            /* ====================================
               MULTI-PROJECT MANAGEMENT
               ==================================== */
            .project-switcher {
                position: relative;
                display: inline-block;
            }

            .project-switcher-btn {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 6px 12px;
                border-radius: 999px;
                border: 1px solid var(--border-soft);
                background: var(--card);
                color: var(--text);
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.15s;
            }

            .project-switcher-btn:hover {
                background: var(--bg);
                border-color: var(--blue);
            }

            body.dark-theme .project-switcher-btn {
                background: #020617;
                border-color: #374151;
            }

            body.dark-theme .project-switcher-btn:hover {
                background: #1f2937;
            }

            .project-dropdown {
                position: absolute;
                top: calc(100% + 4px);
                left: 0;
                min-width: 300px;
                max-width: 400px;
                background: var(--card);
                border: 1px solid var(--border);
                border-radius: 12px;
                box-shadow: 0 12px 35px rgba(15, 23, 42, 0.15);
                z-index: 1000;
                display: none;
                flex-direction: column;
                max-height: 400px;
                overflow: hidden;
            }

            body.dark-theme .project-dropdown {
                background: var(--card-dark);
                border-color: #1f2937;
            }

            .project-dropdown.visible {
                display: flex;
            }

            .project-dropdown-header {
                padding: 12px 16px;
                border-bottom: 1px solid var(--border);
                display: flex;
                gap: 8px;
            }

            body.dark-theme .project-dropdown-header {
                border-color: #1f2937;
            }

            .project-dropdown-header input {
                flex: 1;
                padding: 6px 10px;
                border: 1px solid var(--border-soft);
                border-radius: 6px;
                font-size: 12px;
                background: var(--bg);
                color: var(--text);
            }

            body.dark-theme .project-dropdown-header input {
                background: #1f2937;
                border-color: #374151;
            }

            .project-dropdown-header button {
                padding: 6px 12px;
                border-radius: 6px;
                font-size: 12px;
                white-space: nowrap;
            }

            .project-list {
                flex: 1;
                overflow-y: auto;
                padding: 8px;
            }

            .project-item {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 10px 12px;
                border-radius: 8px;
                cursor: pointer;
                transition: background 0.15s;
                gap: 8px;
            }

            .project-item:hover {
                background: var(--bg);
            }

            body.dark-theme .project-item:hover {
                background: #1f2937;
            }

            .project-item.active {
                background: var(--blue-soft);
                border-left: 3px solid var(--blue);
            }

            body.dark-theme .project-item.active {
                background: rgba(37, 99, 235, 0.15);
            }

            .project-info {
                flex: 1;
                min-width: 0;
            }

            .project-name {
                font-size: 13px;
                font-weight: 500;
                color: var(--text);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .project-meta {
                font-size: 11px;
                color: var(--text-soft);
                margin-top: 2px;
            }

            .project-actions {
                display: flex;
                gap: 4px;
                opacity: 0;
                transition: opacity 0.15s;
            }

            .project-item:hover .project-actions {
                opacity: 1;
            }

            .project-action-btn {
                padding: 4px 8px;
                border: none;
                background: transparent;
                border-radius: 4px;
                font-size: 11px;
                cursor: pointer;
                color: var(--text-soft);
                transition: all 0.15s;
            }

            .project-action-btn:hover {
                background: rgba(0, 0, 0, 0.1);
                color: var(--text);
            }

            body.dark-theme .project-action-btn:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .project-action-btn.danger:hover {
                background: var(--danger);
                color: white;
            }

            .last-saved-indicator {
                font-size: 10px;
                color: var(--text-softer);
                margin-left: 8px;
                opacity: 0.6;
                transition: opacity 0.3s;
            }

            .project-dropdown-footer {
                padding: 8px 16px;
                border-top: 1px solid var(--border);
                font-size: 11px;
                color: var(--text-soft);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            body.dark-theme .project-dropdown-footer {
                border-color: #1f2937;
            }
        </style>
    </head>
    <body>
        <div class="app-shell">
            <div class="card">
                <div class="header">
                    <div class="brand">
                        <img
                            class="brand-logo"
                            alt="3REP logo"
                            src="https://drive.google.com/thumbnail?id=10-B4tVpvCMupmSPeBGIKezK5zv3oMJtB&sz=w200"
                        />
                        <div class="brand-text">
                            <h1>üí°3REP LX Data Entry Tool</h1>
                            <span>Created by GWB for 3REP</span>
                        </div>
                    </div>

                    <div class="toolbar">
                        <!-- LEFT SIDE: Theme toggle, File status, Clear File -->
                        <div class="toolbar-left">
                            <label
                                class="theme-switch"
                                title="Toggle light / dark"
                            >
                                <input type="checkbox" id="themeToggle" />
                                <div class="theme-knob"></div>
                                <div class="theme-slider">
                                    <span class="theme-icon sun">‚òÄÔ∏è</span>
                                    <span class="theme-icon moon">üåô</span>
                                </div>
                            </label>
                            <label
                                class="btn file-input-wrapper"
                                aria-label="Upload VWX EXP.txt"
                            >
                                <span class="icon">üì§</span> Upload VWX EXP.txt
                                <input
                                    id="fileInput"
                                    type="file"
                                    accept=".txt"
                                />
                            </label>
                            <div
                                class="pill"
                                aria-live="polite"
                                id="fileStatusWrap"
                            >
                                <span class="pill-dot"></span>
                                <span id="fileStatus">No file loaded</span>
                            </div>

                            <!-- PROJECT SWITCHER -->
                            <div class="project-switcher">
                                <button class="project-switcher-btn" id="projectSwitcherBtn">
                                    <span class="icon">üìÅ</span>
                                    <span id="currentProjectName">No Project</span>
                                    <span>‚ñº</span>
                                </button>
                                <div class="project-dropdown" id="projectDropdown">
                                    <div class="project-dropdown-header">
                                        <input
                                            type="text"
                                            id="newProjectNameInput"
                                            placeholder="New project name..."
                                        />
                                        <button class="btn btn-primary" id="createProjectBtn">
                                            Create
                                        </button>
                                    </div>
                                    <div class="project-list" id="projectList">
                                        <!-- Projects will be rendered here -->
                                    </div>
                                    <div class="project-dropdown-footer">
                                        <span id="projectCount">0 projects</span>
                                        <span class="last-saved-indicator" id="lastSavedIndicator">Not saved</span>
                                    </div>
                                </div>
                            </div>

                            <button id="clearFileBtn" class="btn">
                                <span class="icon">üóëÔ∏è</span> Clear File
                            </button>
                        </div>

                        <!-- RIGHT SIDE BUTTONS -->
                        <div class="toolbar-right">
                            <!-- ================= TOP ROW - EXPORTS ================= -->
                            <div class="toolbar-row">
                                <button
                                    id="downloadLogBtn"
                                    class="btn"
                                    disabled
                                >
                                    <span class="icon">üìú</span> Change Log
                                </button>

                                <button
                                    id="downloadBtn"
                                    class="btn btn-ld"
                                    disabled
                                >
                                    <span class="icon">üíæ</span> Export VWX
                                    LD_IMP.txt
                                </button>

                                <button
                                    id="downloadBtnME"
                                    class="btn btn-me"
                                    disabled
                                >
                                    <span class="icon">üíæ</span> Export VWX
                                    ME_IMP.txt
                                </button>

                                <button
                                    id="createGearListPdfBtn"
                                    class="btn btn-blue"
                                    disabled
                                >
                                    <span class="icon">üìã</span> Export Gear
                                    List PDF
                                </button>

                                <button
                                    id="createPdfBtn"
                                    class="btn btn-blue"
                                    disabled
                                >
                                    <span class="icon">üìÑ</span> Export LX Patch
                                    PDF
                                </button>

                                <button
                                    id="exportCsvBtn"
                                    class="btn btn-blue"
                                    disabled
                                >
                                    <span class="icon">üè∑Ô∏è</span> Export CSV for
                                    Avery Labels
                                </button>
                            </div>

                            <!-- ================= BOTTOM ROW - EDIT TOOLS ================= -->
                            <div class="toolbar-row">
                                <button
                                    id="undoBtn"
                                    class="btn"
                                    disabled
                                    title="Nothing to undo"
                                >
                                    <span class="icon">‚Ü∫</span> Undo
                                </button>

                                <button
                                    id="redoBtn"
                                    class="btn"
                                    disabled
                                    title="Nothing to redo"
                                >
                                    <span class="icon">‚Üª</span> Redo
                                </button>

                                <button id="autoPatchBtn" class="btn">
                                    <span class="icon">ü™Ñ</span> Auto Patch
                                </button>

                                <button id="columnClearBtn" class="btn">
                                    <span class="icon">üßπ</span> Column Clear
                                </button>

                                <button
                                    id="historyPill"
                                    class="pill pill-history"
                                    aria-live="polite"
                                    style="opacity: 0.6"
                                >
                                    <span class="label">History:</span>
                                    <span id="historyCount" class="label"
                                        >0</span
                                    >
                                    <span>¬∑</span>
                                    <span id="historyLast" class="label"
                                        >Nothing yet</span
                                    >
                                </button>

                                <button id="revertBtn" class="btn" disabled>
                                    <span class="icon">üîÅ</span> Revert
                                </button>
                            </div>
                        </div>
                    </div>
                    <!-- Preload banner (shows when saved data is detected) -->
                    <div
                        id="preloadBanner"
                        style="
                            display: none;
                            font-size: 11px;
                            color: gray;
                            margin-top: 4px;
                        "
                    >
                        Preloaded data detected.
                    </div>

                    <!-- Warning area (for overlaps or phase imbalance) -->
                    <div
                        id="warning"
                        style="color: #ff4444; font-size: 11px; margin-top: 4px"
                    ></div>
                </div>

                <div class="layout">
                    <section class="pane-main">
                        <div class="pane-header">
                            <div>
                                <div class="pane-header-title">
                                    Fixture Table
                                </div>
                                <div class="pane-header-subtitle">
                                    Sort any column ¬∑ Arrow keys move between
                                    cells ¬∑ Ctrl/‚åò+Z / Ctrl/‚åò+Shift+Z for
                                    undo/redo.
                                </div>
                            </div>
                        </div>

                        <div class="filter-bar">
                            <input
                                id="filterInput"
                                type="search"
                                placeholder="Filter: Instrument, Purpose, Position, Channel, Universe‚Ä¶"
                                aria-label="Filter rows"
                            />
                            <button
                                id="clearFilterBtn"
                                class="btn"
                                type="button"
                            >
                                ‚úñÔ∏è Clear
                            </button>
                        </div>

                        <div
                            style="
                                display: flex;
                                justify-content: flex-end;
                                margin-bottom: 8px;
                            "
                        >
                            <label
                                style="
                                    display: flex;
                                    align-items: center;
                                    gap: 6px;
                                    font-size: 11px;
                                    color: var(--text-soft);
                                    cursor: pointer;
                                "
                            >
                                <input
                                    type="checkbox"
                                    id="hideMEColumnsToggle"
                                />
                                <span
                                    >Hide ME columns (Uni, Addr, Mult, Ckt,
                                    Watts)</span
                                >
                            </label>
                        </div>

                        <div class="table-wrap">
                            <div class="table-scroll">
                                <table id="fixtureTable">
                                    <thead></thead>
                                    <tbody id="fixtureBody"></tbody>
                                </table>
                            </div>
                            <div class="status-bar">
                                <span id="statusSummary"></span>
                            </div>
                            <div id="asanaNotice" class="asana-notice">
                                <div class="asana-notice-text">
                                    <svg
                                        class="asana-logo"
                                        viewBox="0 0 200 200"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <circle
                                            cx="100"
                                            cy="60"
                                            r="35"
                                            fill="#F06A6A"
                                        />
                                        <circle
                                            cx="65"
                                            cy="120"
                                            r="35"
                                            fill="#F06A6A"
                                        />
                                        <circle
                                            cx="135"
                                            cy="120"
                                            r="35"
                                            fill="#F06A6A"
                                        />
                                    </svg>
                                    <strong
                                        >For any changes to Fixture Type,
                                        Placement, or DMX Mode, you must
                                        complete an Asana Form for CAD.</strong
                                    >
                                </div>
                                <button
                                    class="asana-notice-btn"
                                    onclick="window.open('https://form.asana.com/?k=aIxBHYt6TvIVktuclJRvHw&d=1206048893285511', '_blank')"
                                >
                                    Open CAD Asana Form
                                </button>
                            </div>
                        </div>
                    </section>

                    <aside class="pane-side">
                        <div class="stats-block">
                            <div class="stats-row">
                                <span>Total fixtures</span>
                                <span
                                    ><strong id="statFixtures">0</strong></span
                                >
                            </div>
                            <div class="stats-row">
                                <span>Total DMX</span>
                                <span><strong id="statDMX">0</strong></span>
                            </div>
                            <div class="stats-row">
                                <span>Total Wattage</span>
                                <span
                                    ><strong id="statWattage">0</strong> W</span
                                >
                            </div>
                            <div class="stats-row">
                                <span>Total phase amps (L1+L2+L3)</span>
                                <span
                                    ><strong id="statAmps">0.0</strong> A</span
                                >
                            </div>
                            <div class="stats-row">
                                <span>Universes in use</span>
                                <span
                                    ><strong id="statUniverseCount"
                                        >0</strong
                                    ></span
                                >
                            </div>
                            <div id="phaseSummary" class="phase-summary"></div>
                        </div>
                        <div class="phase-balance">
                            <div id="imbalanceValue">Œî 0.0 A</div>
                            <div id="neutralValue">Neutral: 0.0 A</div>
                        </div>
                        <div
                            class="stats-block"
                            id="deviceFilterBlock"
                            style="display: none"
                        >
                            <div class="stats-row">
                                <span>Device Types</span>
                                <span id="deviceFilterCount"
                                    ><strong>0</strong></span
                                >
                            </div>
                            <div class="device-filter-actions">
                                <button
                                    id="deviceFilterAllBtn"
                                    class="btn"
                                    type="button"
                                >
                                    Select all
                                </button>
                                <button
                                    id="deviceFilterClearBtn"
                                    class="btn"
                                    type="button"
                                >
                                    Clear
                                </button>
                            </div>
                            <div
                                id="deviceFilterList"
                                class="device-filter-list"
                                role="group"
                                aria-label="Filter by device type"
                            ></div>
                        </div>

                        <div class="stats-block">
                            <div class="stats-row">
                                <span>Universe utilization</span>
                            </div>
                            <div id="universeList" class="universe-list"></div>
                        </div>

                        <div class="stats-block">
                            <div class="stats-row">
                                <span>Mults</span>
                                <span id="statMultCount"
                                    ><strong>0</strong></span
                                >
                            </div>
                            <div id="multList" class="mult-list"></div>
                        </div>
                    </aside>
                </div>
            </div>
        </div>
        <!-- Auto Patch Options Modal -->
        <div
            id="autoPatchModal"
            style="
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.45);
                z-index: 999;
                justify-content: center;
                align-items: center;
            "
        >
            <div class="card" style="max-width: 340px; padding: 18px 22px">
                <h3
                    style="
                        margin: 0 0 12px 0;
                        font-size: 14px;
                        font-weight: 600;
                    "
                >
                    Auto Patch Options
                </h3>
                <p
                    style="
                        font-size: 11px;
                        color: var(--text-soft);
                        margin: 0 0 14px 0;
                    "
                >
                    Select what to assign:
                </p>

                <div
                    style="
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        font-size: 11px;
                    "
                >
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="apUniverses" checked />
                        <span>Universes</span>
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="apAddresses" checked />
                        <span>Addresses</span>
                        <span style="color: var(--text-softer); font-size: 10px"
                            >(sorted by channel within position)</span
                        >
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="apMults" checked />
                        <span>Mults</span>
                        <span style="color: var(--text-softer); font-size: 10px"
                            >(one per position)</span
                        >
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="apCircuits" checked />
                        <span>Circuits</span>
                        <span style="color: var(--text-softer); font-size: 10px"
                            >(higher ch# = ckt 1, near fan out)</span
                        >
                    </label>
                </div>

                <div
                    style="
                        display: flex;
                        justify-content: flex-end;
                        gap: 8px;
                        margin-top: 18px;
                    "
                >
                    <button id="apCancelBtn" class="btn">Cancel</button>
                    <button id="apConfirmBtn" class="btn btn-primary">
                        Apply
                    </button>
                </div>
            </div>
        </div>
        <!-- Column Clear Modal -->
        <div
            id="columnClearModal"
            style="
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.45);
                z-index: 999;
                justify-content: center;
                align-items: center;
            "
        >
            <div class="card" style="max-width: 340px; padding: 18px 22px">
                <h3
                    style="
                        margin: 0 0 12px 0;
                        font-size: 14px;
                        font-weight: 600;
                    "
                >
                    Clear Columns
                </h3>
                <p
                    style="
                        font-size: 11px;
                        color: var(--text-soft);
                        margin: 0 0 14px 0;
                    "
                >
                    Select which columns to clear:
                </p>

                <div
                    style="
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        font-size: 11px;
                    "
                >
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="clrMult" />
                        <span>Mult</span>
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="clrCircuit" />
                        <span>Circuit</span>
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="clrAddress" />
                        <span>Address</span>
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="clrUniverse" />
                        <span>Universe</span>
                    </label>
                    <label
                        style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            cursor: pointer;
                        "
                    >
                        <input type="checkbox" id="clrChannel" />
                        <span>Channel #</span>
                    </label>
                </div>

                <div
                    style="
                        display: flex;
                        justify-content: flex-end;
                        gap: 8px;
                        margin-top: 18px;
                    "
                >
                    <button id="clrCancelBtn" class="btn">Cancel</button>
                    <button id="clrConfirmBtn" class="btn btn-primary">
                        Clear
                    </button>
                </div>
            </div>
        </div>
        <script>
            let fixtures = [];
            let originalFixtures = [];
            let headers = [];
            let displayOrder = [];
            let sortState = null;

            let originalFileName = "patch.txt";
            // Session version tracking for exports
            // Format: ShowName MONTH.DAYvVERSION_DOCUMENT
            let sessionVersion = 1; // Increments per export action within the session

            // Selection now supports multi-row editing
            const selection = {
                rowIndex: null,
                colKey: null,
                multiRows: new Set(), // hold all selected row indices
                lastClickedRow: null, // for shift-click range selection
            };
            const editableColumns = new Set(["Purpose", "Channel"]);

            const MULT_BASES = Array.from({ length: 14 }, (_, i) =>
                String.fromCharCode("A".charCodeAt(0) + i),
            );
            let customMultOptions = new Set();
            let MULT_OPTIONS = [...MULT_BASES, "BATT"];

            const UNIVERSE_CAPACITY = 512;

            // ====================================
            // CUSTOM MODAL SYSTEM
            // ====================================

            function showModal(title, bodyHTML, buttons = []) {
                // Remove existing modal if any
                const existing = document.getElementById('customModalOverlay');
                if (existing) existing.remove();

                // Create modal HTML
                const modal = document.createElement('div');
                modal.id = 'customModalOverlay';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-container">
                        <div class="modal-header">
                            <h3 class="modal-title">${title}</h3>
                            <button class="modal-close" onclick="closeModal()">&times;</button>
                        </div>
                        <div class="modal-body">${bodyHTML}</div>
                        <div class="modal-footer" id="modalFooter"></div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Add buttons
                const footer = document.getElementById('modalFooter');
                buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = `btn ${btn.className || ''}`;
                    button.textContent = btn.label;
                    button.onclick = () => {
                        if (btn.onClick) btn.onClick();
                        if (btn.closeOnClick !== false) closeModal();
                    };
                    footer.appendChild(button);
                });

                // ESC to close
                document.addEventListener('keydown', handleModalKeydown);

                // Click overlay to close
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'customModalOverlay') closeModal();
                });
            }

            function closeModal() {
                const modal = document.getElementById('customModalOverlay');
                if (modal) {
                    modal.style.animation = 'modalFadeOut 0.2s ease';
                    setTimeout(() => modal.remove(), 200);
                }
                document.removeEventListener('keydown', handleModalKeydown);
            }

            function handleModalKeydown(e) {
                if (e.key === 'Escape') {
                    closeModal();
                }
                if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                    const primaryBtn = document.querySelector('.modal-footer .btn-primary');
                    if (primaryBtn) primaryBtn.click();
                }
            }

            // Helper: Custom alert
            function customAlert(title, message) {
                showModal(title, `<p>${message}</p>`, [
                    { label: 'OK', className: 'btn-primary' }
                ]);
            }

            // Helper: Custom confirm (returns Promise)
            function customConfirm(title, message) {
                return new Promise((resolve) => {
                    showModal(title, `<p>${message}</p>`, [
                        {
                            label: 'Cancel',
                            className: 'btn',
                            onClick: () => resolve(false)
                        },
                        {
                            label: 'Confirm',
                            className: 'btn-primary',
                            onClick: () => resolve(true)
                        }
                    ]);
                });
            }

            // ====================================
            // MULTI-PROJECT MANAGEMENT SYSTEM
            // ====================================

            const PROJECTS_STORAGE_KEY = 'lx_data_entry_projects_v1';
            const CURRENT_PROJECT_KEY = 'lx_current_project';
            let currentProjectName = null;
            let autoSaveTimeout = null;

            function getAllProjects() {
                try {
                    const data = localStorage.getItem(PROJECTS_STORAGE_KEY);
                    return data ? JSON.parse(data) : {};
                } catch (e) {
                    console.error('Error loading projects:', e);
                    return {};
                }
            }

            function saveProjectData(projectName, data) {
                const projects = getAllProjects();
                projects[projectName] = {
                    name: projectName,
                    savedAt: new Date().toISOString(),
                    fixtures: data.fixtures || [],
                    originalFixtures: data.originalFixtures || [],
                    headers: data.headers || [],
                    originalFileName: data.originalFileName || 'patch.txt',
                    customMults: data.customMults || [],
                    historyStack: data.historyStack || [],
                    version: '3.0'
                };

                try {
                    localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(projects));
                    localStorage.setItem(CURRENT_PROJECT_KEY, projectName);
                    return true;
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        customAlert('Storage Full', 'LocalStorage is full. Please delete old projects.');
                    } else {
                        customAlert('Save Error', 'Could not save project: ' + e.message);
                    }
                    return false;
                }
            }

            function loadProjectData(projectName) {
                const projects = getAllProjects();
                const project = projects[projectName];

                if (!project) {
                    customAlert('Project Not Found', `Project "${projectName}" does not exist.`);
                    return false;
                }

                // Restore state
                fixtures = project.fixtures || [];
                originalFixtures = project.originalFixtures || [];
                headers = project.headers || [];
                originalFileName = project.originalFileName || 'patch.txt';
                customMultOptions = new Set(project.customMults || []);
                MULT_OPTIONS = [...MULT_BASES, ...customMultOptions, "BATT"];

                // Clear history when switching projects
                historyStack.length = 0;
                redoStack.length = 0;
                updateUndoButtons();

                // Update UI
                currentProjectName = projectName;
                fileStatus.textContent = fixtures.length > 0
                    ? `${projectName}: ${fixtures.length} fixtures`
                    : `${projectName}: Empty`;

                updateCurrentProjectDisplay();

                // Re-render
                detectDeviceTypeKey();
                indexDeviceTypes();
                renderDeviceTypePanel();
                renderTable();
                updateStats();

                localStorage.setItem(CURRENT_PROJECT_KEY, projectName);
                return true;
            }

            function deleteProject(projectName) {
                const projects = getAllProjects();
                delete projects[projectName];
                localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(projects));

                // If we deleted the current project, clear it
                if (currentProjectName === projectName) {
                    currentProjectName = null;
                    localStorage.removeItem(CURRENT_PROJECT_KEY);
                    updateCurrentProjectDisplay();
                }

                renderProjectList();
            }

            function duplicateProject(projectName) {
                const projects = getAllProjects();
                const source = projects[projectName];

                if (!source) return;

                let newName = `${projectName} (Copy)`;
                let counter = 2;
                while (projects[newName]) {
                    newName = `${projectName} (Copy ${counter})`;
                    counter++;
                }

                projects[newName] = {
                    ...source,
                    name: newName,
                    savedAt: new Date().toISOString()
                };

                localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(projects));
                renderProjectList();
                showToast('Project Duplicated', [`Created "${newName}"`]);
            }

            function autoSaveCurrentProject() {
                if (!currentProjectName) return;

                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = setTimeout(() => {
                    const saved = saveProjectData(currentProjectName, {
                        fixtures,
                        originalFixtures,
                        headers,
                        originalFileName,
                        customMults: Array.from(customMultOptions),
                        historyStack
                    });

                    if (saved) {
                        updateLastSavedIndicator();
                    }
                }, 2000); // Auto-save 2 seconds after last change
            }

            function updateLastSavedIndicator() {
                const indicator = document.getElementById('lastSavedIndicator');
                if (indicator) {
                    const now = new Date();
                    indicator.textContent = `Saved ${now.toLocaleTimeString()}`;
                    indicator.style.opacity = 1;
                    setTimeout(() => {
                        indicator.style.opacity = 0.6;
                    }, 2000);
                }
            }

            function updateCurrentProjectDisplay() {
                const displayEl = document.getElementById('currentProjectName');
                if (displayEl) {
                    displayEl.textContent = currentProjectName || 'No Project';
                }
            }

            function renderProjectList() {
                const projects = getAllProjects();
                const projectList = document.getElementById('projectList');
                const projectCount = document.getElementById('projectCount');

                if (!projectList) return;

                const projectNames = Object.keys(projects).sort((a, b) => {
                    const dateA = new Date(projects[a].savedAt);
                    const dateB = new Date(projects[b].savedAt);
                    return dateB - dateA; // Most recent first
                });

                if (projectNames.length === 0) {
                    projectList.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-soft);">No projects yet</div>';
                } else {
                    projectList.innerHTML = projectNames.map(name => {
                        const project = projects[name];
                        const isActive = name === currentProjectName;
                        const fixtureCount = (project.fixtures || []).length;
                        const savedDate = new Date(project.savedAt);
                        const timeAgo = getTimeAgo(savedDate);

                        return `
                            <div class="project-item ${isActive ? 'active' : ''}" onclick="switchToProject('${escapeHtml(name)}')">
                                <div class="project-info">
                                    <div class="project-name">${escapeHtml(name)}</div>
                                    <div class="project-meta">
                                        ${fixtureCount} fixture${fixtureCount !== 1 ? 's' : ''} ‚Ä¢ ${timeAgo}
                                    </div>
                                </div>
                                <div class="project-actions">
                                    <button class="project-action-btn" onclick="event.stopPropagation(); duplicateProject('${escapeHtml(name)}')" title="Duplicate">
                                        üìã
                                    </button>
                                    <button class="project-action-btn danger" onclick="event.stopPropagation(); confirmDeleteProject('${escapeHtml(name)}')" title="Delete">
                                        üóëÔ∏è
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('');
                }

                if (projectCount) {
                    projectCount.textContent = `${projectNames.length} project${projectNames.length !== 1 ? 's' : ''}`;
                }
            }

            function switchToProject(projectName) {
                // Save current project before switching
                if (currentProjectName && fixtures.length > 0) {
                    saveProjectData(currentProjectName, {
                        fixtures,
                        originalFixtures,
                        headers,
                        originalFileName,
                        customMults: Array.from(customMultOptions),
                        historyStack
                    });
                }

                // Load new project
                const success = loadProjectData(projectName);
                if (success) {
                    hideProjectDropdown();
                    showToast('Project Loaded', [`Switched to "${projectName}"`]);
                }
            }

            async function confirmDeleteProject(projectName) {
                const confirmed = await customConfirm(
                    'Delete Project?',
                    `Are you sure you want to delete "${projectName}"? This cannot be undone.`
                );

                if (confirmed) {
                    deleteProject(projectName);
                    showToast('Project Deleted', [`"${projectName}" has been deleted`]);
                }
            }

            function getTimeAgo(date) {
                const seconds = Math.floor((new Date() - date) / 1000);

                if (seconds < 60) return 'Just now';
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

                return date.toLocaleDateString();
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Project dropdown toggle
            function toggleProjectDropdown() {
                const dropdown = document.getElementById('projectDropdown');
                if (dropdown.classList.contains('visible')) {
                    hideProjectDropdown();
                } else {
                    renderProjectList();
                    dropdown.classList.add('visible');
                }
            }

            function hideProjectDropdown() {
                const dropdown = document.getElementById('projectDropdown');
                dropdown.classList.remove('visible');
            }

            // Create new project
            function createNewProject() {
                const input = document.getElementById('newProjectNameInput');
                const name = input.value.trim();

                if (!name) {
                    customAlert('Invalid Name', 'Please enter a project name.');
                    return;
                }

                const projects = getAllProjects();
                if (projects[name]) {
                    customAlert('Project Exists', `A project named "${name}" already exists.`);
                    return;
                }

                // Save current project if any
                if (currentProjectName && fixtures.length > 0) {
                    saveProjectData(currentProjectName, {
                        fixtures,
                        originalFixtures,
                        headers,
                        originalFileName,
                        customMults: Array.from(customMultOptions),
                        historyStack
                    });
                }

                // Create new empty project
                currentProjectName = name;
                fixtures = [];
                originalFixtures = [];
                headers = [];
                originalFileName = 'patch.txt';
                historyStack.length = 0;
                redoStack.length = 0;

                // Save the new empty project
                saveProjectData(name, {
                    fixtures: [],
                    originalFixtures: [],
                    headers: [],
                    originalFileName: 'patch.txt',
                    customMults: [],
                    historyStack: []
                });

                // Update UI
                fileStatus.textContent = `${name}: Empty`;
                updateCurrentProjectDisplay();
                renderTable();
                updateStats();
                renderProjectList();
                hideProjectDropdown();

                input.value = '';
                showToast('Project Created', [`Created new project "${name}"`]);
            }

            // Initialize on load
            function initializeProjectSystem() {
                const savedProjectName = localStorage.getItem(CURRENT_PROJECT_KEY);
                if (savedProjectName) {
                    const projects = getAllProjects();
                    if (projects[savedProjectName]) {
                        currentProjectName = savedProjectName;
                        updateCurrentProjectDisplay();
                    }
                }

                // Set up event listeners
                const switcherBtn = document.getElementById('projectSwitcherBtn');
                if (switcherBtn) {
                    switcherBtn.addEventListener('click', toggleProjectDropdown);
                }

                const createBtn = document.getElementById('createProjectBtn');
                if (createBtn) {
                    createBtn.addEventListener('click', createNewProject);
                }

                const newProjectInput = document.getElementById('newProjectNameInput');
                if (newProjectInput) {
                    newProjectInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            createNewProject();
                        }
                    });
                }

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    const switcher = document.querySelector('.project-switcher');
                    if (switcher && !switcher.contains(e.target)) {
                        hideProjectDropdown();
                    }
                });
            }

            const DEVICE_TYPE_CANDIDATE_KEYS = [
                "Device Type",
                "Instrument Type",
                "Fixture Type",
            ];
            let deviceTypeKey = null;
            const deviceTypeLabels = new Map();
            const deviceTypeSelections = new Map();

            const mult208Overrides = new Map();

            let filterQuery = "";
            let hideMEColumns = false;
            const ME_COLUMN_KEYS = [
                "Universe",
                "Address",
                "Mult",
                "Circuit",
                "Wattage",
            ];
            const historyStack = [];
            const redoStack = [];
            const MAX_HISTORY = 200;
            let activeEdit = null;

            const $ = (id) => document.getElementById(id);

            const fileInput = $("fileInput");

            const fileStatus = $("fileStatus");
            const downloadBtn = $("downloadBtn");
            const downloadBtnME = $("downloadBtnME");
            const exportCsvBtn = $("exportCsvBtn");
            const createPdfBtn = $("createPdfBtn");
            const createGearListPdfBtn = $("createGearListPdfBtn");
            const downloadLogBtn = $("downloadLogBtn");
            const revertBtn = $("revertBtn");
            const clearFileBtn = $("clearFileBtn");
            const columnClearBtn = $("columnClearBtn");
            const autoPatchBtn = $("autoPatchBtn");

            // ‚úÖ Auto Patch DOM Elements ‚Äî must be defined before event listener
            const apConfirmBtn = document.getElementById("apConfirmBtn");
            const apCancelBtn = document.getElementById("apCancelBtn");

            const apUniverses = document.getElementById("apUniverses");
            const apAddresses = document.getElementById("apAddresses");
            const apMults = document.getElementById("apMults");
            const apCircuits = document.getElementById("apCircuits");

            // --- Auto Patch Core Logic ---
            apConfirmBtn.addEventListener("click", () => {
                const assignUniverses = apUniverses.checked;
                const assignAddresses = apAddresses.checked;
                const assignMults = apMults.checked;
                const assignCircuits = apCircuits.checked;

                if (
                    !assignUniverses &&
                    !assignAddresses &&
                    !assignMults &&
                    !assignCircuits
                ) {
                    customAlert("No Actions Selected", "Please select at least one action for Auto Patch.");
                    return;
                }

                const before = fixtures.map(cloneRow);
                const UNIVERSE_CAPACITY = 512;

                // --- Step 1: Group fixtures by Position ---
                const positionMap = new Map();
                fixtures.forEach((f, idx) => {
                    if (isCableRow(f)) return;
                    const pos = (f["Position"] || "").trim() || "(no position)";
                    if (!positionMap.has(pos)) {
                        positionMap.set(pos, []);
                    }
                    positionMap.get(pos).push({ fixture: f, idx });
                });

                // --- Step 2: Sort fixtures within each position by Channel (ascending) ---
                positionMap.forEach((fixtureList) => {
                    fixtureList.sort((a, b) => {
                        const chA = parseIntSafe(a.fixture["Channel"]) || 9999;
                        const chB = parseIntSafe(b.fixture["Channel"]) || 9999;
                        return chA - chB;
                    });
                });

                // --- Step 3: Calculate total DMX per position ---
                const positionDMX = new Map();
                positionMap.forEach((fixtureList, pos) => {
                    let total = 0;
                    fixtureList.forEach(({ fixture }) => {
                        total += parseIntSafe(fixture["DMX Footprint"]) || 1;
                    });
                    positionDMX.set(pos, total);
                });

                // --- Step 4: Universe/Address Assignment ---
                if (assignUniverses || assignAddresses) {
                    // Track universes: { id, used, nextAddr }
                    const universes = [{ id: 1, used: 0, nextAddr: 1 }];

                    const getOrCreateUniverse = (needed) => {
                        // Try to find existing universe that can fit the entire position
                        for (const u of universes) {
                            if (u.used + needed <= UNIVERSE_CAPACITY) {
                                return u;
                            }
                        }
                        // Create new universe
                        const newId = universes.length + 1;
                        const u = { id: newId, used: 0, nextAddr: 1 };
                        universes.push(u);
                        return u;
                    };

                    // Sort positions by total DMX (largest first) for better packing
                    const sortedPositions = Array.from(positionMap.keys()).sort(
                        (a, b) => {
                            return positionDMX.get(b) - positionDMX.get(a);
                        },
                    );

                    sortedPositions.forEach((pos) => {
                        const fixtureList = positionMap.get(pos);
                        const totalDMX = positionDMX.get(pos);

                        // Get universe for this position (entire position in one universe if possible)
                        let currentUniverse = getOrCreateUniverse(
                            Math.min(totalDMX, UNIVERSE_CAPACITY),
                        );

                        fixtureList.forEach(({ fixture }) => {
                            const footprint =
                                parseIntSafe(fixture["DMX Footprint"]) || 1;

                            // Check if we need to spill to next universe
                            if (
                                currentUniverse.nextAddr + footprint - 1 >
                                UNIVERSE_CAPACITY
                            ) {
                                // Position exceeds 512, need to continue to next universe
                                const newId = universes.length + 1;
                                currentUniverse = {
                                    id: newId,
                                    used: 0,
                                    nextAddr: 1,
                                };
                                universes.push(currentUniverse);
                            }

                            // Assign universe and address
                            setUniverseAddressParts(
                                fixture,
                                String(currentUniverse.id),
                                String(currentUniverse.nextAddr),
                            );

                            currentUniverse.nextAddr += footprint;
                            currentUniverse.used += footprint;
                        });
                    });
                }

                // --- Step 5: MULT Assignment (one letter per position) ---
                if (assignMults) {
                    let multIndex = 0;
                    const sortedPositions = Array.from(
                        positionMap.keys(),
                    ).sort();

                    sortedPositions.forEach((pos) => {
                        const multLetter =
                            MULT_OPTIONS[multIndex % MULT_OPTIONS.length] ||
                            "A";
                        const fixtureList = positionMap.get(pos);

                        fixtureList.forEach(({ fixture }) => {
                            fixture["Circuit Name"] = multLetter;
                        });

                        multIndex++;
                    });
                }

                // --- Step 6: Circuit Assignment (wattage-based with 208V detection) ---
                // Higher channel = House Right (near fan out) = Circuit 1
                // High wattage (>120W): spread across all 6 circuits
                // Low wattage (‚â§120W): cram onto fewest circuits
                if (assignCircuits) {
                    const MAX_CIRCUIT_AMPS = 18;
                    const WATTAGE_THRESHOLD = 120;

                    // Group fixtures by position (which maps to Mult)
                    const positionFixtures = new Map();
                    fixtures.forEach((f, idx) => {
                        if (isCableRow(f)) return;
                        const pos =
                            (f["Position"] || "").trim() || "(no position)";
                        if (!positionFixtures.has(pos)) {
                            positionFixtures.set(pos, []);
                        }
                        positionFixtures.get(pos).push({ fixture: f, idx });
                    });

                    // Process each position (each position = one Mult)
                    positionFixtures.forEach((allFixtures, pos) => {
                        // Group by fixture type to calculate relative positions within each type
                        const byType = new Map();
                        allFixtures.forEach(({ fixture, idx }) => {
                            const type =
                                fixture["Instrument Type"] ||
                                fixture["Device Type"] ||
                                "Unknown";
                            if (!byType.has(type)) {
                                byType.set(type, []);
                            }
                            byType.get(type).push({ fixture, idx });
                        });

                        // For each fixture type, sort by channel and assign relative position (0-1)
                        // 0 = House Left (low channel within type), 1 = House Right (high channel within type)
                        byType.forEach((typeFixtures) => {
                            typeFixtures.sort((a, b) => {
                                const chA =
                                    parseIntSafe(a.fixture["Channel"]) || 0;
                                const chB =
                                    parseIntSafe(b.fixture["Channel"]) || 0;
                                return chA - chB;
                            });

                            const count = typeFixtures.length;
                            typeFixtures.forEach((item, i) => {
                                // relativePos: 0 = HL (first/lowest ch in type), 1 = HR (last/highest ch in type)
                                item.relativePos =
                                    count > 1 ? i / (count - 1) : 0.5;
                            });
                        });

                        // Flatten all fixtures with their relative positions
                        const allWithPos = [];
                        byType.forEach((typeFixtures) => {
                            typeFixtures.forEach((item) =>
                                allWithPos.push(item),
                            );
                        });

                        // Sort by relative position DESCENDING (HR/high channel first = circuit 1)
                        allWithPos.sort(
                            (a, b) => b.relativePos - a.relativePos,
                        );

                        // Determine voltage for this position's Mult
                        // Check if mult is flagged as 208V or auto-detect from name
                        const multName =
                            allWithPos[0]?.fixture["Circuit Name"] || "";
                        const mult208 =
                            mult208Overrides.get(multName) ??
                            /\*?\s*208/i.test(multName);
                        const voltage = mult208 ? 208 : 120;

                        // Step 1: Check if ANY fixture at this position is > 120W
                        const hasHighWattage = allWithPos.some(
                            ({ fixture }) => {
                                const watts =
                                    parseIntSafe(fixture["Wattage"]) || 0;
                                return watts > WATTAGE_THRESHOLD;
                            },
                        );

                        // Track amperage for each circuit (1-6)
                        const circuitAmps = [0, 0, 0, 0, 0, 0];

                        if (hasHighWattage) {
                            // HIGH WATTAGE MODE: Use all 6 circuits with target fixture count
                            // Calculate target fixtures per circuit to ensure all 6 get used
                            const totalFixtures = allWithPos.length;
                            const targetPerCircuit = Math.ceil(
                                totalFixtures / 6,
                            );

                            let currentCircuit = 0;
                            let fixturesOnCurrentCircuit = 0;

                            allWithPos.forEach(({ fixture }) => {
                                const watts =
                                    parseIntSafe(fixture["Wattage"]) || 0;
                                const amps = watts / voltage;

                                // Check if we should move to next circuit
                                const wouldExceedAmps =
                                    circuitAmps[currentCircuit] + amps >
                                    MAX_CIRCUIT_AMPS;
                                const reachedTarget =
                                    fixturesOnCurrentCircuit >=
                                    targetPerCircuit;
                                const notLastCircuit = currentCircuit < 5;

                                if (
                                    (wouldExceedAmps ||
                                        (reachedTarget && notLastCircuit)) &&
                                    currentCircuit < 5
                                ) {
                                    // Move to next circuit
                                    currentCircuit++;
                                    fixturesOnCurrentCircuit = 0;
                                }

                                // Assign fixture to current circuit
                                circuitAmps[currentCircuit] += amps;
                                fixture["Circuit Number"] = String(
                                    currentCircuit + 1,
                                );
                                fixturesOnCurrentCircuit++;
                            });
                        } else {
                            // LOW WATTAGE MODE: Cram onto fewest circuits
                            // Fill circuit 1 completely, then circuit 2, etc.
                            let currentCircuit = 0;

                            allWithPos.forEach(({ fixture }) => {
                                const watts =
                                    parseIntSafe(fixture["Wattage"]) || 0;
                                const amps = watts / voltage;

                                // Try to add to current circuit
                                if (
                                    circuitAmps[currentCircuit] + amps <=
                                    MAX_CIRCUIT_AMPS
                                ) {
                                    circuitAmps[currentCircuit] += amps;
                                    fixture["Circuit Number"] = String(
                                        currentCircuit + 1,
                                    );
                                } else {
                                    // Current circuit full, move to next
                                    currentCircuit++;
                                    if (currentCircuit > 5) currentCircuit = 0; // wrap around if needed
                                    circuitAmps[currentCircuit] += amps;
                                    fixture["Circuit Number"] = String(
                                        currentCircuit + 1,
                                    );
                                }
                            });
                        }
                    });
                }

                // ‚úÖ Refresh and record changes
                renderTable();
                updateStats();
                pushHistory({
                    type: "bulk",
                    before,
                    after: fixtures.map(cloneRow),
                });
                autoSaveCurrentProject(); // Auto-save after auto-patch
                $("autoPatchModal").style.display = "none";
            });
            // --- Column Clear Logic ---
            const columnClearModal = $("columnClearModal");
            const clrCancelBtn = $("clrCancelBtn");
            const clrConfirmBtn = $("clrConfirmBtn");

            columnClearBtn.addEventListener("click", () => {
                columnClearModal.style.display = "flex";
            });

            clrCancelBtn.addEventListener("click", () => {
                columnClearModal.style.display = "none";
            });

            // --- Fixed Column Clear Logic ---
            clrConfirmBtn.addEventListener("click", () => {
                const colsToClear = [];
                if ($("clrMult").checked) colsToClear.push("Circuit Name");
                if ($("clrCircuit").checked) colsToClear.push("Circuit Number");
                if ($("clrAddress").checked) colsToClear.push("Address");
                if ($("clrUniverse").checked) colsToClear.push("Universe");
                if ($("clrChannel").checked) colsToClear.push("Channel");

                if (!colsToClear.length) {
                    customAlert("No Columns Selected", "Please select at least one column to clear.");
                    return;
                }

                const before = {};
                fixtures.forEach((f, i) => {
                    before[i] = {};
                    colsToClear.forEach((k) => {
                        before[i][k] = f[k];
                        f[k] = "";

                        // ‚úÖ Keep Universe/Address consistent
                        if (k === "Universe" || k === "Address") {
                            setUniverseAddressParts(f, "", "");
                            if (headers.includes("Universe/Address"))
                                f["Universe/Address"] = "";
                        }
                    });
                });

                // ‚úÖ Make side-pane stats repopulate
                pushHistory({
                    type: "bulk",
                    before,
                    after: fixtures.map(cloneRow),
                });
                discoverCustomMults();
                renderTable();
                updateStats();

                columnClearModal.style.display = "none";
            });
            const hydrateBtn = document.getElementById("hydrateBtn");
            const undoBtn = $("undoBtn");
            const redoBtn = $("redoBtn");
            const preloadBanner = document.getElementById("preloadBanner");
            const warning = document.getElementById("warning");
            const historyPill = $("historyPill");
            const historyCount = $("historyCount");
            const historyLast = $("historyLast");
            const filterInput = $("filterInput");
            const clearFilterBtn = $("clearFilterBtn");
            const themeToggle = $("themeToggle");
            // --- Declare global phase totals before any function calls ---
            let ampsL1 = 0;
            let ampsL2 = 0;
            let ampsL3 = 0;

            const fixtureTable = $("fixtureTable");
            const fixtureBody = $("fixtureBody");
            const statusSummary = $("statusSummary");

            const statFixtures = $("statFixtures");
            const statDMX = $("statDMX");
            const statWattage = $("statWattage");
            const statAmps = $("statAmps");
            const statUniverseCount = $("statUniverseCount");
            const statMultCount = $("statMultCount");
            const universeList = $("universeList");
            const multList = $("multList");
            const phaseSummary = $("phaseSummary");
            const deviceFilterBlock = $("deviceFilterBlock");
            const deviceFilterList = $("deviceFilterList");
            const deviceFilterCount = $("deviceFilterCount");
            const deviceFilterAllBtn = $("deviceFilterAllBtn");
            const deviceFilterClearBtn = $("deviceFilterClearBtn");

            const COLUMN_WIDTH_RULES = {
                "Instrument Type": { min: 100, max: 180 },
                Position: { min: 70, max: 120 },
                Purpose: { min: 80, max: 140 },
                "DMX Footprint": { min: 35, max: 45 },
                OriginalChannel: { min: 45, max: 55 },
                Channel: { min: 35, max: 45 },
                Universe: { min: 35, max: 45 },
                Address: { min: 40, max: 50 },
                Mult: { min: 40, max: 55 },
                Circuit: { min: 35, max: 45 },
                Wattage: { min: 40, max: 55 },
            };

            const visibleColumns = [
                {
                    key: "Instrument Type",
                    label: "Instrument",
                    mapped: true,
                    editable: false,
                    numeric: false,
                    reference: false,
                },
                {
                    key: "Position",
                    label: "Position",
                    mapped: true,
                    editable: false,
                    numeric: false,
                    reference: false,
                },
                {
                    key: "Purpose",
                    label: "Purpose",
                    mapped: true,
                    editable: true,
                    numeric: false,
                    reference: false,
                },
                {
                    key: "DMX Footprint",
                    label: "DMX Mode",
                    mapped: true,
                    editable: false,
                    numeric: true,
                    reference: true,
                },
                {
                    key: "OriginalChannel",
                    label: "Orig Ch",
                    mapped: false,
                    editable: false,
                    numeric: true,
                    reference: true,
                },
                {
                    key: "Channel",
                    label: "Ch#",
                    mapped: true,
                    editable: true,
                    numeric: true,
                    reference: false,
                },
                {
                    key: "Universe",
                    label: "Uni",
                    mapped: false,
                    editable: true,
                    numeric: true,
                    reference: false,
                },
                {
                    key: "Address",
                    label: "Addr",
                    mapped: false,
                    editable: true,
                    numeric: true,
                    reference: false,
                },
                {
                    key: "Mult",
                    label: "Mult",
                    mapped: false,
                    editable: true,
                    numeric: false,
                    reference: false,
                },
                {
                    key: "Circuit",
                    label: "Ckt",
                    mapped: false,
                    editable: true,
                    numeric: true,
                    reference: false,
                },
                {
                    key: "Wattage",
                    label: "Watts",
                    mapped: true,
                    editable: false,
                    numeric: true,
                    reference: true,
                },
            ];

            const NUMERIC_HEADERS = new Set([
                "Channel",
                "Universe",
                "Address",
                "DMX Footprint",
                "Wattage",
                "Unit #",
                "Unit Number",
                "Dimmer",
            ]);

            function isNumericHeader(h) {
                return NUMERIC_HEADERS.has(h);
            }

            function parseIntSafe(v) {
                if (v == null) return NaN;
                const n = parseInt(String(v).replace(/[^\d\-]/g, ""), 10);
                return Number.isNaN(n) ? NaN : n;
            }

            function cloneRow(f) {
                const c = {};
                headers.forEach((h) => {
                    c[h] = f[h];
                });
                return c;
            }

            function getUniverseAddressParts(f) {
                const raw = f["Universe/Address"] || "";
                const m = String(raw).match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                if (m) return { universe: m[1], address: m[2] };
                const m2 = String(raw).match(/^\s*(\d+)\s*\/\s*$/);
                if (m2) return { universe: m2[1], address: "" };
                return {
                    universe: f["Universe"] || "",
                    address: f["Address"] || "",
                };
            }

            function setUniverseAddressParts(f, universe, address) {
                if (!headers.includes("Universe/Address")) return;
                if (universe && address)
                    f["Universe/Address"] = `${universe}/${address}`;
                else if (universe && !address)
                    f["Universe/Address"] = `${universe}/`;
                else f["Universe/Address"] = "";
            }

            function isCableRow(f) {
                if (!headers.includes("Cable")) return false;
                const v = f["Cable"];
                if (v == null) return false;
                const trimmed = String(v).trim();
                if (trimmed === "" || trimmed === "-") return false;
                return true;
            }

            function debounce(fn, delay) {
                let t = null;
                return (...args) => {
                    if (t) clearTimeout(t);
                    t = setTimeout(() => fn(...args), delay);
                };
            }

            function toNorm(str) {
                if (str == null) return "";
                return String(str).trim().toLowerCase();
            }

            function parseCircuitName(name) {
                const out = { isBatt: false, is208: false, base: "" };
                if (!name) return out;
                const t = String(name).trim();
                if (!t) return out;
                const upper = t.toUpperCase();
                if (upper === "BATT") {
                    out.isBatt = true;
                    return out;
                }
                if (/208/.test(upper)) out.is208 = true;
                const base = t.replace(/\s*\*?\s*208V?$/i, "");
                out.base = base || t;
                return out;
            }

            function computeCircuit208Meta(rawName) {
                const trimmed = (rawName || "").trim();
                if (!trimmed)
                    return {
                        base: "",
                        isBatt: false,
                        isBaseLetter: false,
                        is208: false,
                    };
                const parsed = parseCircuitName(trimmed);
                if (parsed.isBatt)
                    return {
                        base: trimmed,
                        isBatt: true,
                        isBaseLetter: false,
                        is208: false,
                    };
                const base = parsed.base || trimmed;
                const isBaseLetter = MULT_BASES.includes(base);
                let is208;
                if (isBaseLetter) {
                    is208 = parsed.is208;
                } else {
                    is208 = true;
                }
                if (mult208Overrides.has(base)) {
                    is208 = !!mult208Overrides.get(base);
                }
                return { base, isBatt: false, isBaseLetter, is208 };
            }

            function computeCircuitNameForExport(rawName) {
                const trimmed = (rawName || "").trim();
                if (!trimmed) return "";
                const meta = computeCircuit208Meta(trimmed);
                if (meta.isBatt) return trimmed;
                if (meta.isBaseLetter) {
                    return meta.is208 ? `${meta.base} *208` : meta.base;
                }
                return trimmed;
            }

            function detectDeviceTypeKey() {
                deviceTypeKey = null;
                for (const k of DEVICE_TYPE_CANDIDATE_KEYS) {
                    if (headers.includes(k)) {
                        deviceTypeKey = k;
                        break;
                    }
                }
                deviceFilterBlock.style.display = deviceTypeKey
                    ? "block"
                    : "none";
            }

            function indexDeviceTypes() {
                deviceTypeLabels.clear();
                deviceTypeSelections.clear();
                if (!deviceTypeKey) return;
                fixtures.forEach((f) => {
                    if (isCableRow(f)) return;
                    const raw = f[deviceTypeKey];
                    if (!raw) return;
                    const norm = toNorm(raw);
                    if (!norm) return;
                    if (!deviceTypeLabels.has(norm)) {
                        deviceTypeLabels.set(norm, String(raw).trim());
                    }
                });
            }

            function countFixturesByDeviceType(norm) {
                let c = 0;
                fixtures.forEach((f) => {
                    if (isCableRow(f)) return;
                    const n = toNorm(f[deviceTypeKey]);
                    if (n === norm) c++;
                });
                return c;
            }

            function passesDeviceTypeFilter(f) {
                if (!deviceTypeKey) return true;
                const norm = toNorm(f[deviceTypeKey]);
                const sel = deviceTypeSelections.get(norm);
                return sel !== false;
            }

            function renderDeviceTypePanel() {
                deviceFilterList.innerHTML = "";
                if (!deviceTypeKey || !deviceTypeLabels.size) {
                    deviceFilterBlock.style.display = "none";
                    return;
                }
                deviceFilterBlock.style.display = "block";

                const entries = Array.from(deviceTypeLabels.entries()).sort(
                    (a, b) =>
                        a[1].localeCompare(b[1], undefined, {
                            sensitivity: "base",
                        }),
                );

                entries.forEach(([norm, label]) => {
                    const id = `dt-${norm.replace(/[^a-z0-9]+/g, "-") || "blank"}`;
                    const row = document.createElement("label");
                    row.className = "device-filter-item";

                    const cb = document.createElement("input");
                    cb.type = "checkbox";
                    cb.id = id;
                    cb.dataset.norm = norm;
                    cb.checked = deviceTypeSelections.get(norm) !== false;
                    cb.addEventListener("change", handleDeviceTypeToggle);

                    const txt = document.createElement("span");
                    txt.textContent = label;

                    const meta = document.createElement("span");
                    meta.style.marginLeft = "auto";
                    meta.style.color = "var(--text-softer)";
                    meta.textContent = countFixturesByDeviceType(norm);

                    row.appendChild(cb);
                    row.appendChild(txt);
                    row.appendChild(meta);
                    deviceFilterList.appendChild(row);
                });

                deviceFilterCount.innerHTML = `<strong>${entries.length}</strong>`;
            }

            function handleDeviceTypeToggle(e) {
                const norm = e.target.dataset.norm;
                deviceTypeSelections.set(norm, e.target.checked);
                renderTable();
                updateStats();
            }

            fileInput.addEventListener("change", handleFileSelect);
            function handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                if (!/\.txt$/i.test(file.name || "")) {
                    customAlert("Invalid File Type", "Please choose a .txt file.");
                    return;
                }
                originalFileName = file.name || "patch.txt";
                exportCounter = 0;
                fileStatus.textContent = "Loaded: " + originalFileName;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    const text = ev.target.result || "";
                    loadFromText(text);
                };
                reader.readAsText(file);
            }

            function loadFromText(text) {
                const lines = (text || "")
                    .replace(/\r\n/g, "\n")
                    .replace(/\r/g, "\n")
                    .split("\n");
                const nonEmpty = lines.filter((l) => l.trim().length > 0);
                if (!nonEmpty.length) {
                    customAlert("Empty File", "The uploaded file appears to be empty.");
                    return;
                }

                headers = nonEmpty[0].split("\t");
                // DO NOT TRIM HEADERS ‚Äì preserve exact spacing
                headers = headers.map((h) => h);

                for (let i = 1; i < nonEmpty.length; i++) {
                    const row = nonEmpty[i];
                    const cols = row.split("\t");
                    if (cols.length === 1 && cols[0].trim() === "") continue;
                    const f = {};
                    headers.forEach((h, idx) => {
                        f[h] = cols[idx] !== undefined ? cols[idx] : "";
                    });
                    fixtures.push(f);
                }

                originalFixtures = fixtures.map(cloneRow);

                mult208Overrides.clear();

                detectDeviceTypeKey();
                indexDeviceTypes();
                renderDeviceTypePanel();

                discoverCustomMults();

                displayOrder = fixtures.map((_, idx) => idx);
                sortState = null;
                clearSelection();

                renderTable();
                updateStats();

                const hasData = fixtures.length > 0;
                [
                    downloadBtn,
                    downloadBtnME,
                    downloadLogBtn,
                    revertBtn,
                    exportCsvBtn,
                    createPdfBtn,
                    createGearListPdfBtn,
                ].forEach((b) => (b.disabled = !hasData));

                // Show/hide Asana notice based on whether file is loaded
                const asanaNotice = $("asanaNotice");
                if (hasData) {
                    asanaNotice.classList.add("visible");
                } else {
                    asanaNotice.classList.remove("visible");
                }

                historyStack.length = 0;
                redoStack.length = 0;
                activeEdit = null;
                updateUndoButtons();
                autoSaveCurrentProject(); // Auto-save after file load
            }
            const applyFilterNow = () => {
                renderTable();
            };
            const applyFilter = debounce(applyFilterNow, 120);

            filterInput.addEventListener("input", (e) => {
                filterQuery = e.target.value || "";
                applyFilter();
            });
            clearFilterBtn.addEventListener("click", () => {
                filterQuery = "";
                filterInput.value = "";
                applyFilterNow();
            });

            // --- Hide ME Columns Toggle ---
            const hideMEColumnsToggle = $("hideMEColumnsToggle");
            hideMEColumnsToggle.addEventListener("change", () => {
                hideMEColumns = hideMEColumnsToggle.checked;
                renderTable();
            });

            function rowMatchesFilter(f) {
                const q = (filterQuery || "").trim().toLowerCase();
                if (!q) return true;
                const keys = [
                    "Instrument Type",
                    "Purpose",
                    "Position",
                    "Channel",
                    "Universe/Address",
                    "Circuit Name",
                    "Circuit Number",
                    "DMX Footprint",
                    "Wattage",
                    "Device Type",
                    "Fixture Type",
                ];
                for (const k of keys) {
                    if (!headers.includes(k)) continue;
                    const v = (f[k] || "").toString().toLowerCase();
                    if (v.includes(q)) return true;
                }
                return false;
            }

            function renderTable() {
                renderHeader();
                renderRows();
                updateCellSelectionStyles();
                autoSizeColumns();
            }

            function renderHeader() {
                const thead = fixtureTable.querySelector("thead");
                thead.innerHTML = "";
                const tr = document.createElement("tr");

                visibleColumns.forEach((col) => {
                    if (col.mapped && !headers.includes(col.key)) return;
                    if (
                        !col.mapped &&
                        (col.key === "Universe" || col.key === "Address") &&
                        !headers.includes("Universe/Address")
                    )
                        return;
                    if (
                        !col.mapped &&
                        (col.key === "Mult" || col.key === "Circuit") &&
                        (!headers.includes("Circuit Name") ||
                            !headers.includes("Circuit Number"))
                    )
                        return;
                    // Skip ME columns if hidden
                    if (hideMEColumns && ME_COLUMN_KEYS.includes(col.key))
                        return;

                    const th = document.createElement("th");
                    th.dataset.colKey = col.key;

                    let label = col.label;
                    if (sortState && sortState.key === col.key) {
                        th.classList.add("sorted");
                        label += sortState.direction === "asc" ? " ‚ñ≤" : " ‚ñº";
                    }
                    th.textContent = label;

                    if (col.numeric) th.classList.add("col-numeric");

                    th.addEventListener("click", () =>
                        handleHeaderClick(col.key),
                    );
                    tr.appendChild(th);
                });

                thead.appendChild(tr);
            }

            function visibleRowIndices() {
                const base =
                    displayOrder.length === fixtures.length
                        ? displayOrder
                        : fixtures.map((_, i) => i);

                return base.filter((idx) => {
                    const f = fixtures[idx];
                    if (!rowMatchesFilter(f)) return false;
                    if (!passesDeviceTypeFilter(f)) return false;
                    return true;
                });
            }

            function renderRows() {
                fixtureBody.innerHTML = "";
                const rows = visibleRowIndices();

                rows.forEach((rowIndex) => {
                    const f = fixtures[rowIndex];
                    const tr = document.createElement("tr");
                    tr.dataset.rowIndex = rowIndex;
                    if (isCableRow(f)) tr.classList.add("row-cable");
                    // --- allow Cmd/Ctrl multi-select and Shift range-select ---
                    tr.addEventListener("click", (e) => {
                        if (e.shiftKey && selection.lastClickedRow !== null) {
                            // Range selection: select all rows between lastClickedRow and rowIndex
                            const visibleRows = visibleRowIndices();
                            const lastIdx = visibleRows.indexOf(
                                selection.lastClickedRow,
                            );
                            const currentIdx = visibleRows.indexOf(rowIndex);

                            if (lastIdx !== -1 && currentIdx !== -1) {
                                const start = Math.min(lastIdx, currentIdx);
                                const end = Math.max(lastIdx, currentIdx);

                                // Clear and add range
                                if (!(e.metaKey || e.ctrlKey)) {
                                    selection.multiRows.clear();
                                }
                                for (let i = start; i <= end; i++) {
                                    selection.multiRows.add(visibleRows[i]);
                                }
                                selection.rowIndex = rowIndex;
                            }
                        } else if (e.metaKey || e.ctrlKey) {
                            // Toggle individual row selection
                            if (selection.multiRows.has(rowIndex)) {
                                selection.multiRows.delete(rowIndex);
                            } else {
                                selection.multiRows.add(rowIndex);
                            }
                            selection.lastClickedRow = rowIndex;
                        } else {
                            // Normal single selection
                            selection.multiRows.clear();
                            selection.multiRows.add(rowIndex);
                            selection.rowIndex = rowIndex;
                            selection.lastClickedRow = rowIndex;
                        }
                        updateCellSelectionStyles();
                    });

                    visibleColumns.forEach((col) => {
                        if (col.mapped && !headers.includes(col.key)) return;
                        if (
                            !col.mapped &&
                            (col.key === "Universe" || col.key === "Address") &&
                            !headers.includes("Universe/Address")
                        )
                            return;
                        if (
                            !col.mapped &&
                            (col.key === "Mult" || col.key === "Circuit") &&
                            (!headers.includes("Circuit Name") ||
                                !headers.includes("Circuit Number"))
                        )
                            return;
                        // Skip ME columns if hidden
                        if (hideMEColumns && ME_COLUMN_KEYS.includes(col.key))
                            return;

                        const td = document.createElement("td");
                        td.dataset.colKey = col.key;
                        td.dataset.rowIndex = rowIndex;
                        if (col.numeric) td.classList.add("col-numeric");

                        if (col.key === "OriginalChannel") {
                            td.dataset.readonly = "true";
                            td.textContent =
                                originalFixtures[rowIndex]?.["Channel"] ?? "";
                        } else if (
                            col.key === "Universe" ||
                            col.key === "Address"
                        ) {
                            const { universe, address } =
                                getUniverseAddressParts(f);
                            if (col.key === "Universe") {
                                const sel = document.createElement("select");
                                sel.dataset.rowIndex = rowIndex;
                                sel.dataset.colKey = "Universe";
                                const optEmpty =
                                    document.createElement("option");
                                optEmpty.value = "";
                                optEmpty.textContent = "";
                                sel.appendChild(optEmpty);
                                for (let u = 1; u <= 24; u++) {
                                    const op = document.createElement("option");
                                    op.value = String(u);
                                    op.textContent = String(u);
                                    if (String(u) === universe)
                                        op.selected = true;
                                    sel.appendChild(op);
                                }
                                attachCellNav(sel, rowIndex, col.key);
                                sel.addEventListener("focus", () =>
                                    beginEdit(rowIndex, "Universe"),
                                );
                                sel.addEventListener("change", (e) => {
                                    commitEdit(rowIndex, "Universe", () => {
                                        const val = e.target.value;
                                        const { address: addrPrev } =
                                            getUniverseAddressParts(
                                                fixtures[rowIndex],
                                            );
                                        setUniverseAddressParts(
                                            fixtures[rowIndex],
                                            val,
                                            addrPrev,
                                        );
                                    });
                                });
                                td.appendChild(sel);
                            } else {
                                const input = document.createElement("input");
                                input.type = "number";
                                input.min = "1";
                                input.max = "512";
                                input.value = address;
                                attachCellNav(input, rowIndex, col.key);
                                input.addEventListener("focus", () =>
                                    beginEdit(rowIndex, "Address"),
                                );
                                input.addEventListener("input", (e) => {
                                    const raw = e.target.value;
                                    const n = parseIntSafe(raw);
                                    if (Number.isNaN(n) || n < 1) {
                                        e.target.value = "";
                                        return;
                                    }
                                    const clamped = Math.min(
                                        512,
                                        Math.max(1, n),
                                    );
                                    e.target.value = String(clamped);
                                    const { universe: uPrev } =
                                        getUniverseAddressParts(
                                            fixtures[rowIndex],
                                        );
                                    fixtures[rowIndex]["Universe/Address"] = "";
                                    setUniverseAddressParts(
                                        fixtures[rowIndex],
                                        uPrev,
                                        String(clamped),
                                    );
                                    updateStats();
                                });
                                input.addEventListener("blur", (e) => {
                                    const val = e.target.value;
                                    commitEdit(rowIndex, "Address", () => {
                                        const n = parseIntSafe(val);
                                        if (Number.isNaN(n)) {
                                            const { universe: uPrev } =
                                                getUniverseAddressParts(
                                                    fixtures[rowIndex],
                                                );
                                            setUniverseAddressParts(
                                                fixtures[rowIndex],
                                                uPrev,
                                                "",
                                            );
                                        }
                                    });
                                });
                                td.appendChild(input);
                            }
                        } else if (col.key === "Mult") {
                            const wrap = document.createElement("div");
                            const sel = document.createElement("select");
                            sel.dataset.rowIndex = rowIndex;
                            sel.dataset.colKey = "Mult";

                            // Look at the raw Circuit Name from the file
                            const rawCircuit =
                                fixtures[rowIndex]["Circuit Name"] || "";
                            const meta = computeCircuit208Meta(rawCircuit);

                            // Decide what to show in the dropdown:
                            // - If it's BATT, show "BATT"
                            // - If it's a plain letter mult like "A*208" / "A 208V", show just "A"
                            // - Otherwise, show the raw text
                            let current;
                            if (meta.isBatt) {
                                current = "BATT";
                            } else if (meta.isBaseLetter) {
                                current = meta.base; // e.g. "A" from "A*208"
                            } else {
                                current = rawCircuit;
                            }

                            const opts = ["", ...MULT_OPTIONS];
                            opts.forEach((v) => {
                                const op = document.createElement("option");
                                op.value = v;
                                op.textContent = v;
                                if (v === current) op.selected = true;
                                sel.appendChild(op);
                            });

                            attachCellNav(sel, rowIndex, col.key);
                            sel.addEventListener("focus", () =>
                                beginEdit(rowIndex, "Circuit Name"),
                            );
                            sel.addEventListener("change", (e) => {
                                commitEdit(rowIndex, "Circuit Name", () => {
                                    fixtures[rowIndex]["Circuit Name"] =
                                        e.target.value;
                                    updateStats();
                                });
                            });

                            wrap.appendChild(sel);
                            td.appendChild(wrap);
                        } else if (col.key === "Circuit") {
                            const sel = document.createElement("select");
                            sel.dataset.rowIndex = rowIndex;
                            sel.dataset.colKey = "Circuit";
                            const current =
                                fixtures[rowIndex]["Circuit Number"] || "";

                            // Add color class based on circuit number
                            if (current) {
                                sel.classList.add(`circuit-color-${current}`);
                            }

                            const opts = ["", "1", "2", "3", "4", "5", "6"];
                            opts.forEach((v) => {
                                const op = document.createElement("option");
                                op.value = v;
                                op.textContent = v;
                                if (v === current) op.selected = true;
                                sel.appendChild(op);
                            });
                            attachCellNav(sel, rowIndex, col.key);
                            sel.addEventListener("focus", () =>
                                beginEdit(rowIndex, "Circuit Number"),
                            );
                            sel.addEventListener("change", (e) => {
                                commitEdit(rowIndex, "Circuit Number", () => {
                                    fixtures[rowIndex]["Circuit Number"] =
                                        e.target.value;
                                    updateStats();
                                });
                            });
                            td.appendChild(sel);
                        } else if (col.mapped && editableColumns.has(col.key)) {
                            const input = document.createElement("input");
                            input.type = "text";
                            input.value = f[col.key] ?? "";
                            attachCellNav(input, rowIndex, col.key);
                            input.addEventListener("focus", () =>
                                beginEdit(rowIndex, col.key),
                            );
                            input.addEventListener("input", (e) => {
                                fixtures[rowIndex][col.key] = e.target.value;
                                updateStats();
                            });
                            input.addEventListener("blur", () => {
                                commitEdit(rowIndex, col.key, null);
                            });
                            td.appendChild(input);
                        } else if (col.mapped) {
                            td.dataset.readonly = "true";
                            td.textContent = f[col.key] ?? "";
                        } else {
                            td.dataset.readonly = "true";
                            td.textContent = "-";
                        }

                        if (
                            selection.rowIndex === rowIndex &&
                            selection.colKey === col.key
                        ) {
                            td.classList.add("cell-selected");
                        }

                        tr.appendChild(td);
                    });

                    fixtureBody.appendChild(tr);
                });

                fixtureBody.addEventListener("keydown", handleCellKeyDown);
            }

            function autoSizeColumns() {
                const thead = fixtureTable.querySelector("thead");
                const hdrCells = thead.querySelectorAll("th");
                hdrCells.forEach((th) => {
                    const key = th.dataset.colKey;
                    if (!key) return;
                    const rule = COLUMN_WIDTH_RULES[key] || {
                        min: 60,
                        max: 200,
                    };
                    th.style.minWidth = rule.min + "px";
                    th.style.width = rule.max + "px";
                });
            }

            function handleHeaderClick(colKey) {
                if (!colKey) return;
                let dir = "asc";
                if (
                    sortState &&
                    sortState.key === colKey &&
                    sortState.direction === "asc"
                ) {
                    dir = "desc";
                }
                sortState = { key: colKey, direction: dir };
                sortDisplayOrder();
                renderTable();
            }

            function sortDisplayOrder() {
                if (!sortState) return;
                const { key, direction } = sortState;
                const sign = direction === "asc" ? 1 : -1;
                displayOrder.sort((a, b) => {
                    const fa = fixtures[a];
                    const fb = fixtures[b];
                    const va =
                        key === "OriginalChannel"
                            ? (originalFixtures[a]?.["Channel"] ?? "")
                            : (fa[key] ?? "");
                    const vb =
                        key === "OriginalChannel"
                            ? (originalFixtures[b]?.["Channel"] ?? "")
                            : (fb[key] ?? "");
                    const na = parseIntSafe(va);
                    const nb = parseIntSafe(vb);
                    if (
                        !Number.isNaN(na) &&
                        !Number.isNaN(nb) &&
                        (va !== "" || vb !== "")
                    ) {
                        if (na < nb) return -1 * sign;
                        if (na > nb) return 1 * sign;
                        return 0;
                    }
                    const sa = String(va).toLowerCase();
                    const sb = String(vb).toLowerCase();
                    if (sa < sb) return -1 * sign;
                    if (sa > sb) return 1 * sign;
                    return 0;
                });
            }

            function clearSelection() {
                selection.rowIndex = null;
                selection.colKey = null;
                selection.multiRows.clear();
                selection.lastClickedRow = null;
                updateCellSelectionStyles();
            }

            function setSelection(rowIndex, colKey) {
                selection.rowIndex = rowIndex;
                selection.colKey = colKey;
                updateCellSelectionStyles();
            }

            function updateCellSelectionStyles() {
                // Clear cell selection
                fixtureBody
                    .querySelectorAll("td.cell-selected")
                    .forEach((td) => td.classList.remove("cell-selected"));

                // Highlight selected cell
                if (selection.rowIndex != null && selection.colKey) {
                    fixtureBody
                        .querySelectorAll(
                            `td[data-row-index="${selection.rowIndex}"][data-col-key="${selection.colKey}"]`,
                        )
                        .forEach((td) => {
                            td.classList.add("cell-selected");
                        });
                }

                // Highlight multi-selected rows
                fixtureBody.querySelectorAll("tr").forEach((tr) => {
                    const idx = parseInt(tr.dataset.rowIndex, 10);
                    tr.classList.toggle(
                        "row-selected",
                        selection.multiRows.has(idx),
                    );
                });
            }

            function attachCellNav(el, rowIndex, colKey) {
                el.tabIndex = -1;
                el.addEventListener("click", () => {
                    setSelection(rowIndex, colKey);
                });
            }

            function findCell(rowIndex, colKey) {
                return fixtureBody.querySelector(
                    `td[data-row-index="${rowIndex}"][data-col-key="${colKey}"]`,
                );
            }

            function focusCell(rowIndex, colKey) {
                const td = findCell(rowIndex, colKey);
                if (!td) return;
                setSelection(rowIndex, colKey);
                const inputLike = td.querySelector("input,select");
                if (inputLike) {
                    inputLike.focus();
                    inputLike.select?.();
                } else {
                    td.focus();
                }
            }

            function handleCellKeyDown(e) {
                const key = e.key;
                if (
                    ![
                        "ArrowUp",
                        "ArrowDown",
                        "ArrowLeft",
                        "ArrowRight",
                    ].includes(key)
                )
                    return;

                const cell = e.target.closest("td");
                if (!cell) return;
                const rowIndex = parseInt(cell.dataset.rowIndex, 10);
                const colKey = cell.dataset.colKey;

                const rows = visibleRowIndices();
                const rowPos = rows.indexOf(rowIndex);
                if (rowPos < 0) return;

                const cols = visibleColumns.filter((col) => {
                    if (col.mapped && !headers.includes(col.key)) return false;
                    if (
                        !col.mapped &&
                        (col.key === "Universe" || col.key === "Address") &&
                        !headers.includes("Universe/Address")
                    )
                        return false;
                    if (
                        !col.mapped &&
                        (col.key === "Mult" || col.key === "Circuit") &&
                        (!headers.includes("Circuit Name") ||
                            !headers.includes("Circuit Number"))
                    )
                        return false;
                    // Skip ME columns if hidden
                    if (hideMEColumns && ME_COLUMN_KEYS.includes(col.key))
                        return false;
                    return true;
                });
                const colPos = cols.findIndex((c) => c.key === colKey);
                if (colPos < 0) return;

                e.preventDefault();

                let nextRowPos = rowPos;
                let nextColPos = colPos;

                if (key === "ArrowUp") nextRowPos = Math.max(0, rowPos - 1);
                if (key === "ArrowDown")
                    nextRowPos = Math.min(rows.length - 1, rowPos + 1);
                if (key === "ArrowLeft") nextColPos = Math.max(0, colPos - 1);
                if (key === "ArrowRight")
                    nextColPos = Math.min(cols.length - 1, colPos + 1);

                const nextRowIndex = rows[nextRowPos];
                const nextColKey = cols[nextColPos].key;
                focusCell(nextRowIndex, nextColKey);
            }

            function describeHistoryEntry(entry) {
                if (!entry) return "Nothing yet";
                if (entry.type === "edit") {
                    return `Cell edit (${entry.colKey})`;
                }
                return entry.type;
            }

            function updateUndoButtons() {
                const undoAvailable = historyStack.length > 0;
                const redoAvailable = redoStack.length > 0;
                undoBtn.disabled = !undoAvailable;
                redoBtn.disabled = !redoAvailable;

                const lastUndo = historyStack[historyStack.length - 1] || null;
                const lastRedo = redoStack[redoStack.length - 1] || null;

                undoBtn.title = undoAvailable
                    ? `Undo: ${describeHistoryEntry(lastUndo)}`
                    : "Nothing to undo";
                redoBtn.title = redoAvailable
                    ? `Redo: ${describeHistoryEntry(lastRedo)}`
                    : "Nothing to redo";

                if (historyPill && historyCount && historyLast) {
                    historyCount.textContent = String(historyStack.length);
                    historyLast.textContent = describeHistoryEntry(lastUndo);
                    historyPill.style.opacity = historyStack.length ? 1 : 0.6;
                }
            }

            function pushHistory(entry) {
                historyStack.push(entry);
                if (historyStack.length > MAX_HISTORY) historyStack.shift();
                redoStack.length = 0;
                updateUndoButtons();
            }

            function beginEdit(rowIndex, colKey) {
                activeEdit = {
                    rowIndex,
                    colKey,
                    before: cloneRow(fixtures[rowIndex])[colKey],
                };
            }

            function commitEdit(rowIndex, colKey, extraMutations) {
                if (typeof extraMutations === "function") extraMutations();

                if (!activeEdit) return;
                const afterVal = fixtures[rowIndex][colKey];

                // --- Multi-row edit support with column-specific rules ---
                if (selection.multiRows.size > 1) {
                    const sortedRows = Array.from(selection.multiRows).sort(
                        (a, b) => a - b,
                    );

                    // Store before state for bulk history
                    const beforeState = {};
                    sortedRows.forEach((r) => {
                        beforeState[r] = { [colKey]: fixtures[r][colKey] };
                    });

                    if (colKey === "Purpose") {
                        // Purpose: All selected rows mirror the edited value
                        for (const r of sortedRows) {
                            fixtures[r]["Purpose"] = afterVal;
                        }
                    } else if (colKey === "Channel") {
                        // Channel: Sequential numbering starting with edited value
                        const base = parseIntSafe(afterVal);
                        if (!Number.isNaN(base)) {
                            let ch = base;
                            for (const r of sortedRows) {
                                fixtures[r]["Channel"] = String(ch++);
                            }
                        }
                    } else if (colKey === "Universe") {
                        // Universe: All selected rows mirror the edited value
                        for (const r of sortedRows) {
                            const { address } = getUniverseAddressParts(
                                fixtures[r],
                            );
                            setUniverseAddressParts(
                                fixtures[r],
                                afterVal,
                                address,
                            );
                        }
                    } else if (colKey === "Address") {
                        // Address: Sequential based on DMX Footprint
                        const base = parseIntSafe(afterVal);
                        if (!Number.isNaN(base)) {
                            let addr = base;
                            for (const r of sortedRows) {
                                const { universe } = getUniverseAddressParts(
                                    fixtures[r],
                                );
                                const footprint =
                                    parseIntSafe(
                                        fixtures[r]["DMX Footprint"],
                                    ) || 1;
                                setUniverseAddressParts(
                                    fixtures[r],
                                    universe,
                                    String(addr),
                                );
                                addr += footprint;
                            }
                        }
                    } else if (colKey === "Mult") {
                        // Mult: All selected rows mirror the edited value
                        for (const r of sortedRows) {
                            fixtures[r]["Circuit Name"] = afterVal;
                        }
                    } else if (colKey === "Circuit") {
                        // Circuit: All selected rows mirror the edited value
                        for (const r of sortedRows) {
                            fixtures[r]["Circuit Number"] = afterVal;
                        }
                    } else if (
                        colKey === "Circuit Number" ||
                        colKey === "Circuit Name"
                    ) {
                        // Legacy support: Mult / Circuit ‚Äî same value for all
                        for (const r of sortedRows) {
                            fixtures[r][colKey] = afterVal;
                        }
                    }

                    // Store after state for bulk history
                    const afterState = {};
                    sortedRows.forEach((r) => {
                        afterState[r] = { [colKey]: fixtures[r][colKey] };
                    });

                    // Push bulk history
                    pushHistory({
                        type: "bulk",
                        before: beforeState,
                        after: afterState,
                    });
                } else {
                    // Single-edit history
                    if (
                        activeEdit.rowIndex === rowIndex &&
                        activeEdit.colKey === colKey &&
                        activeEdit.before !== afterVal
                    ) {
                        pushHistory({
                            type: "edit",
                            rowIndex,
                            colKey,
                            before: activeEdit.before,
                            after: afterVal,
                        });
                    }
                }

                activeEdit = null;
                renderTable();
                updateStats();
                autoSaveCurrentProject(); // Auto-save after edit
            }

            function undo() {
                const entry = historyStack.pop();
                if (!entry) return;
                clearSelection();
                if (entry.type === "edit") {
                    fixtures[entry.rowIndex][entry.colKey] = entry.before;
                } else if (entry.type === "bulk") {
                    Object.keys(entry.before).forEach((idx) => {
                        const n = parseInt(idx, 10);
                        const patch = entry.before[idx];
                        Object.keys(patch).forEach((k) => {
                            fixtures[n][k] = patch[k];
                        });
                    });
                }
                redoStack.push(entry);
                renderTable();
                updateStats();
                updateUndoButtons();
            }

            function redo() {
                const entry = redoStack.pop();
                if (!entry) return;
                clearSelection();
                if (entry.type === "edit") {
                    fixtures[entry.rowIndex][entry.colKey] = entry.after;
                } else if (entry.type === "bulk") {
                    Object.keys(entry.after).forEach((idx) => {
                        const n = parseInt(idx, 10);
                        const patch = entry.after[idx];
                        Object.keys(patch).forEach((k) => {
                            fixtures[n][k] = patch[k];
                        });
                    });
                }
                historyStack.push(entry);
                renderTable();
                updateStats();
                updateUndoButtons();
            }

            undoBtn.addEventListener("click", undo);
            redoBtn.addEventListener("click", redo);

            // Revert button - restore all fixtures to original state
            revertBtn.addEventListener("click", async () => {
                const confirmed = await customConfirm(
                    "Revert All Changes?",
                    "This will restore the original data. <strong>This action cannot be undone.</strong>"
                );

                if (!confirmed) {
                    return;
                }
                clearSelection();

                // Restore fixtures from originalFixtures
                fixtures = originalFixtures.map(cloneRow);

                // Clear history
                historyStack.length = 0;
                redoStack.length = 0;
                updateUndoButtons();

                // Refresh display
                displayOrder = fixtures.map((_, idx) => idx);
                sortState = null;
                discoverCustomMults();
                renderTable();
                updateStats();
            });

            // Clear File button - refreshes the page
            clearFileBtn.addEventListener("click", async () => {
                const confirmed = await customConfirm(
                    "Clear All Data?",
                    "This will refresh the page and clear all data."
                );

                if (confirmed) {
                    window.location.reload();
                }
            });

            document.addEventListener("keydown", (e) => {
                const z = e.key.toLowerCase() === "z";
                if ((e.metaKey || e.ctrlKey) && z && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                }
                if (
                    (e.metaKey || e.ctrlKey) &&
                    ((z && e.shiftKey) || e.key.toLowerCase() === "y")
                ) {
                    e.preventDefault();
                    redo();
                }
            });

            // Clear selection when clicking outside the table
            document.addEventListener("click", (e) => {
                const clickedInTable = e.target.closest("#fixtureTable");
                const clickedInModal = e.target.closest(".modal");
                if (!clickedInTable && !clickedInModal) {
                    clearSelection();
                }
            });

            function discoverCustomMults() {
                customMultOptions.clear();
                fixtures.forEach((f) => {
                    const v = f["Circuit Name"];
                    if (!v) return;
                    const val = String(v).trim();
                    if (!val) return;
                    const parsed = parseCircuitName(val);
                    if (parsed.isBatt) return;
                    const base = parsed.base || val;
                    if (MULT_BASES.includes(base)) return;
                    if (base.toUpperCase() === "BATT") return;
                    customMultOptions.add(base);
                });
                MULT_OPTIONS = [
                    ...MULT_BASES,
                    ...Array.from(customMultOptions),
                    "BATT",
                ];
            }
            const universeUsage = new Map(); // tracks DMX per universe
            const multMap = new Map(); // tracks mults for leg balance

            function updateStats() {
                let totalFixtures = 0;
                let totalDMX = 0;
                let totalWatt = 0;

                // Reset global data before recalculating
                universeUsage.clear();
                multMap.clear();

                // Phase tracking
                const ampsByPhase = { L1: 0, L2: 0, L3: 0 };

                // Loop through all fixtures
                fixtures.forEach((f) => {
                    if (isCableRow(f)) return; // skip cables

                    totalFixtures++;

                    // --- DMX footprint ---
                    const dmx = parseIntSafe(f["DMX Footprint"]) || 0;
                    totalDMX += dmx;

                    // --- Wattage ---
                    const watts = parseIntSafe(f["Wattage"]) || 0;
                    totalWatt += watts;

                    // --- Universe usage ---
                    const { universe } = getUniverseAddressParts(f);
                    if (universe) {
                        if (!universeUsage.has(universe)) {
                            universeUsage.set(universe, { dmx: 0 });
                        }
                        universeUsage.get(universe).dmx += dmx;
                    }

                    // --- Mult tracking (with normalization) ---
                    let mult = f["Mult"] || f["Circuit Name"] || "";
                    const circuit = parseIntSafe(f["Circuit Number"]) || 0;

                    // Normalize name to merge "B *208", "B*208", "b *208 " etc.
                    mult = mult.trim().toUpperCase();
                    mult = mult.replace(/\s*\*\s*/g, "*"); // collapse spaces around *
                    mult = mult.replace(/\s+/g, " "); // collapse any double spaces

                    if (!multMap.has(mult)) {
                        // Auto-detect 208 from mult label (e.g. "B*208")
                        const auto208 = /\*?\s*208/i.test(mult);
                        multMap.set(mult, {
                            is208: mult208Overrides.get(mult) ?? auto208,
                            wattsTotal: 0,
                            circuits: {},
                        });
                    }

                    const m = multMap.get(mult);
                    m.wattsTotal += watts;

                    const volts = m.is208 ? 208 : 120;
                    const amps = volts ? watts / volts : 0;

                    if (circuit) {
                        if (!m.circuits[circuit]) {
                            m.circuits[circuit] = { amps: 0, watts: 0 };
                        }
                        m.circuits[circuit].amps += amps;
                        m.circuits[circuit].watts += watts;
                    }

                    // Phase balance based on circuit number
                    if (circuit === 1 || circuit === 2) ampsByPhase.L1 += amps;
                    else if (circuit === 3 || circuit === 4)
                        ampsByPhase.L2 += amps;
                    else if (circuit === 5 || circuit === 6)
                        ampsByPhase.L3 += amps;
                });

                // Calculate totals after loop
                const totalAmps =
                    ampsByPhase.L1 + ampsByPhase.L2 + ampsByPhase.L3;

                // Compute Imbalance and Neutral Current (Wye system)
                const ampsL1 = ampsByPhase.L1;
                const ampsL2 = ampsByPhase.L2;
                const ampsL3 = ampsByPhase.L3;

                const maxAmp = Math.max(ampsL1, ampsL2, ampsL3);
                const minAmp = Math.min(ampsL1, ampsL2, ampsL3);
                const imbalance = maxAmp - minAmp;

                // Neutral current (vector sum for 3-phase wye)
                const neutralCurrent = Math.sqrt(
                    Math.max(
                        0,
                        ampsL1 ** 2 +
                            ampsL2 ** 2 +
                            ampsL3 ** 2 -
                            (ampsL1 * ampsL2 +
                                ampsL2 * ampsL3 +
                                ampsL3 * ampsL1),
                    ),
                );

                // Update stats display
                phaseSummary.innerHTML = "";
                statFixtures.textContent = String(totalFixtures);
                statDMX.textContent = String(totalDMX);
                statWattage.textContent = String(totalWatt);
                statAmps.textContent = totalAmps.toFixed(1);

                // Update imbalance and neutral display
                const imbalanceEl = document.getElementById("imbalanceValue");
                const neutralEl = document.getElementById("neutralValue");

                if (imbalanceEl)
                    imbalanceEl.textContent = `Œî ${imbalance.toFixed(1)} A`;
                if (neutralEl)
                    neutralEl.textContent = `Neutral: ${neutralCurrent.toFixed(1)} A`;

                universeList.innerHTML = "";
                const uniFiltered = Array.from(universeUsage.entries())
                    .filter(([u]) => {
                        const n = parseInt(u, 10);
                        return !Number.isNaN(n) && n > 0;
                    })
                    .sort((a, b) => parseInt(a[0], 10) - parseInt(b[0], 10));

                statUniverseCount.textContent = String(uniFiltered.length);

                uniFiltered.forEach(([u, o]) => {
                    const ratio = Math.min(o.dmx / UNIVERSE_CAPACITY, 1);
                    let color = "var(--safe)";
                    if (ratio > 0.9) color = "var(--danger)";
                    else if (ratio > 0.75) color = "var(--warn)";

                    const item = document.createElement("div");
                    item.className = "universe-item";

                    const header = document.createElement("div");
                    header.className = "universe-header";
                    const l = document.createElement("span");
                    l.className = "label";
                    l.textContent = "Universe " + u;
                    const v = document.createElement("span");
                    v.className = "value";
                    v.textContent = `${o.dmx} / 512 ch`;
                    header.appendChild(l);
                    header.appendChild(v);

                    const bar = document.createElement("div");
                    bar.className = "universe-bar";
                    const fill = document.createElement("div");
                    fill.className = "universe-fill";
                    fill.style.transform = `scaleX(${ratio})`;
                    fill.style.background = color;
                    bar.appendChild(fill);

                    item.appendChild(header);
                    item.appendChild(bar);
                    universeList.appendChild(item);
                });

                multList.innerHTML = "";
                const multEntries = Array.from(multMap.entries()).sort(
                    (a, b) => b[1].wattsTotal - a[1].wattsTotal,
                );
                multEntries.forEach(([name, m]) => {
                    const item = document.createElement("div");
                    item.className = "mult-item";

                    const header = document.createElement("div");
                    header.className = "mult-header";

                    const labelSpan = document.createElement("span");
                    labelSpan.className = "label";
                    labelSpan.textContent = name;

                    const volts = m.is208 ? 208 : 120;
                    const ampsTotal = m.wattsTotal / volts;
                    const valueSpan = document.createElement("span");
                    valueSpan.className = "value";
                    valueSpan.textContent = `${ampsTotal.toFixed(1)}A (${m.wattsTotal}W @${volts}V)`;

                    const toggleWrap = document.createElement("label");
                    toggleWrap.className = "mult-volt-toggle";
                    const cb = document.createElement("input");
                    cb.type = "checkbox";
                    cb.checked = m.is208;
                    cb.addEventListener("change", () => {
                        mult208Overrides.set(name, cb.checked);
                        updateStats();
                    });
                    const cbLabel = document.createElement("span");
                    cbLabel.textContent = "208V";
                    toggleWrap.appendChild(cb);
                    toggleWrap.appendChild(cbLabel);

                    header.appendChild(labelSpan);
                    header.appendChild(toggleWrap);
                    header.appendChild(valueSpan);
                    item.appendChild(header);

                    const wrap = document.createElement("div");
                    wrap.className = "mult-circuits";
                    const circuits = Object.entries(m.circuits).sort(
                        (a, b) => parseInt(a[0], 10) - parseInt(b[0], 10),
                    );
                    circuits.forEach(([cStr, vals]) => {
                        const c = parseInt(cStr, 10);
                        const pill = document.createElement("span");
                        let phaseClass = "";
                        if (c === 1) phaseClass = "c1-pill";
                        else if (c === 2) phaseClass = "c2-pill";
                        else if (c === 3) phaseClass = "c3-pill";
                        else if (c === 4) phaseClass = "c4-pill";
                        else if (c === 5) phaseClass = "c5-pill";
                        else if (c === 6) phaseClass = "c6-pill";

                        let ampClass = "amp-safe";
                        if (vals.amps > 20) ampClass = "amp-danger";
                        else if (vals.amps > 18) ampClass = "amp-warn";

                        pill.className = `mult-circuit-entry ${phaseClass} ${ampClass}`;
                        pill.textContent = `${name}${cStr}: ${vals.amps.toFixed(1)}A (${vals.watts}W)`;
                        wrap.appendChild(pill);
                    });
                    if (circuits.length) item.appendChild(wrap);

                    multList.appendChild(item);
                });
                statMultCount.innerHTML = `<strong>${multEntries.length}</strong>`;

                // Render phase pills
                const phases = [
                    { key: "L1", label: "L1 (1+2)", cls: "l1" },
                    { key: "L2", label: "L2 (3+4)", cls: "l2" },
                    { key: "L3", label: "L3 (5+6)", cls: "l3" },
                ];

                phases.forEach((p) => {
                    const amps = ampsByPhase[p.key] || 0;
                    const div = document.createElement("div");
                    div.className = `phase ${p.cls}`;
                    div.innerHTML = `
                        <span class="label">${p.label}</span>
                        <span class="value">${amps.toFixed(1)} A</span>
                    `;
                    phaseSummary.appendChild(div);
                });

                // Imbalance indicator pill
                const balanceDiv = document.createElement("div");
                balanceDiv.className = "phase-balance";
                balanceDiv.innerHTML = `Œî ${imbalance.toFixed(1)} A`;
                phaseSummary.appendChild(balanceDiv);

                // --- Overlapping DMX Address check ---
                if (!statusSummary) return;
                const overlaps = new Set();
                const byUniverse = new Map();

                // Group fixtures by universe
                fixtures.forEach((f, idx) => {
                    if (isCableRow(f)) return;
                    const { universe, address } = getUniverseAddressParts(f);
                    const footprint = parseIntSafe(f["DMX Footprint"]) || 1;
                    if (!universe || !address) return;
                    const start = parseInt(address);
                    const end = start + footprint - 1;

                    if (!byUniverse.has(universe)) byUniverse.set(universe, []);
                    byUniverse.get(universe).push({ idx, start, end });
                });

                // Check for overlaps within each universe
                byUniverse.forEach((list) => {
                    list.sort((a, b) => a.start - b.start);
                    for (let i = 0; i < list.length - 1; i++) {
                        const a = list[i];
                        const b = list[i + 1];
                        if (b.start <= a.end) {
                            overlaps.add(a.idx);
                            overlaps.add(b.idx);
                        }
                    }
                });
                if (fixtureBody) {
                    fixtureBody.querySelectorAll("tr").forEach((tr) => {
                        const i = parseInt(tr.dataset.rowIndex, 10);
                        tr.classList.toggle("row-overlap", overlaps.has(i));
                    });
                }

                // Add footer warning if overlaps exist
                statusSummary.innerHTML = `Fixtures: ${fixtures.length}`;
                if (overlaps.size > 0) {
                    const overlapCount = overlaps.size;
                    const overlapUniverses = [];

                    const overlapDetails = [];

                    byUniverse.forEach((list, uni) => {
                        list.sort((a, b) => a.start - b.start);
                        for (let i = 0; i < list.length - 1; i++) {
                            const a = list[i];
                            const b = list[i + 1];
                            if (b.start <= a.end) {
                                overlapUniverses.push(uni);

                                const fa = fixtures[a.idx];
                                const fb = fixtures[b.idx];
                                const cha = fa["Channel"] || "?";
                                const chb = fb["Channel"] || "?";

                                overlapDetails.push(
                                    `U${uni}: Ch ${cha}‚Äì${chb}`,
                                );
                            }
                        }
                    });

                    const uniqueUniverses = [...new Set(overlapUniverses)].join(
                        ", ",
                    );

                    const warning = document.createElement("span");
                    warning.innerHTML = ` ‚ö†Ô∏è ${overlapCount} overlapping fixtures (U${uniqueUniverses}) ‚Äî ${overlapDetails.join(
                        "; ",
                    )}`;
                    warning.style.cursor = "pointer";
                    warning.style.marginLeft = "8px";
                    warning.style.color = "var(--danger, #ff4444)";
                    warning.style.fontWeight = "bold";
                    warning.title = "Click to jump to first overlap";

                    warning.addEventListener("click", () => {
                        const firstIdx = Math.min(...overlaps);
                        const row = fixtureBody.querySelector(
                            `tr[data-row-index="${firstIdx}"]`,
                        );
                        if (row) {
                            row.scrollIntoView({
                                behavior: "smooth",
                                block: "center",
                            });
                            row.classList.add("row-flash");
                            setTimeout(
                                () => row.classList.remove("row-flash"),
                                1200,
                            );
                        }
                    });

                    statusSummary.appendChild(warning);
                }

                // Enable/disable ME button based on 80% completion of Mult and Circuit
                updateMEButtonState();
            }

            function updateMEButtonState() {
                if (!fixtures.length) {
                    downloadBtnME.disabled = true;
                    return;
                }

                // Count fixture lines (exclude cable rows)
                let fixtureCount = 0;
                let completeCount = 0;

                fixtures.forEach((f) => {
                    if (isCableRow(f)) return;
                    fixtureCount++;

                    const mult = (f["Mult"] || f["Circuit Name"] || "").trim();
                    const circuit = (f["Circuit Number"] || "").trim();

                    if (mult && circuit) {
                        completeCount++;
                    }
                });

                // Enable if 80% or more have both Mult and Circuit
                const completionRate =
                    fixtureCount > 0 ? completeCount / fixtureCount : 0;
                downloadBtnME.disabled = completionRate < 0.8;
            }

            autoPatchBtn.addEventListener("click", openAutoPatchModal);

            function openAutoPatchModal() {
                clearSelection();
                $("autoPatchModal").style.display = "flex";
            }

            /**
             * Generate standardized export filename
             * Format: ShowName MONTH.DAYvVERSION_DOCUMENT
             * @param {string} documentSuffix - e.g., "LD_IMP.txt", "ME_IMP.txt", "Labels.csv", "LX_Patch.pdf"
             * @returns {string} Generated filename
             */
            function buildExportFileName(documentSuffix) {
                const now = new Date();
                const month = String(now.getMonth() + 1).padStart(2, "0");
                const day = String(now.getDate()).padStart(2, "0");

                // Get original file base name (no extension)
                let showName = (originalFileName || "Show").replace(
                    /\.[^.]+$/,
                    "",
                );

                // Clean off any previous date/version or suffixes
                showName = showName
                    .replace(/\s\d{1,2}\.\d{1,2}v\d+.*$/i, "") // Remove existing MONTH.DAYvVERSION_*
                    .replace(/\s\d{2}\.\d{2}[a-z]?(_EXP|_IMP)?$/i, "") // Remove old format
                    .trim();

                // Construct new filename: ShowName MONTH.DAYvVERSION_DOCUMENT
                const fileName = `${showName} ${month}.${day}v${sessionVersion}_${documentSuffix}`;

                // Increment session version for next export
                sessionVersion++;

                return fileName;
            }
            function buildExportText() {
                const lines = [];

                // Always use imported headers exactly as-is
                lines.push(headers.join("\t"));

                fixtures.forEach((f) => {
                    const row = headers.map((h) => {
                        let val = f[h] ?? "";

                        if (h === "Universe/Address") {
                            const { universe, address } =
                                getUniverseAddressParts(f);
                            val =
                                universe && address
                                    ? `${universe}/${address}`
                                    : universe || "";
                        } else if (h === "Circuit Name") {
                            val = computeCircuitNameForExport(val);
                        }

                        return String(val);
                    });

                    lines.push(row.join("\t"));
                });

                return lines.join("\n");
            }

            // Toast notification helper
            function showToast(title, items) {
                // Remove existing toast if any
                const existing = document.querySelector(".toast");
                if (existing) existing.remove();

                const toast = document.createElement("div");
                toast.className = "toast";

                const header = document.createElement("div");
                header.className = "toast-header";
                header.innerHTML = `<span>${title}</span>`;

                const closeBtn = document.createElement("button");
                closeBtn.className = "toast-close";
                closeBtn.innerHTML = "√ó";
                closeBtn.addEventListener("click", () => toast.remove());
                header.appendChild(closeBtn);

                toast.appendChild(header);

                if (items && items.length) {
                    const list = document.createElement("ul");
                    list.className = "toast-list";
                    items.forEach((item) => {
                        const li = document.createElement("li");
                        li.textContent = item;
                        list.appendChild(li);
                    });
                    toast.appendChild(list);
                }

                document.body.appendChild(toast);

                // Auto-dismiss after 8 seconds
                setTimeout(() => {
                    if (toast.parentNode) toast.remove();
                }, 8000);
            }

            // ====================================
            // COMPREHENSIVE VALIDATION SYSTEM
            // ====================================

            function validateForVectorworksExport() {
                const errors = [];
                const warnings = [];
                const nonCableFixtures = fixtures.filter(f => !isCableRow(f));

                if (nonCableFixtures.length === 0) {
                    return { valid: true, errors: [], warnings: [] };
                }

                // ===== CRITICAL ERRORS (Block Export) =====

                // 1. Missing Required Fields
                const requiredFields = [
                    { key: 'Channel', label: 'Channel' },
                    { key: 'Position', label: 'Position' },
                    { key: 'Instrument Type', label: 'Instrument Type', alt: 'Device Type' }
                ];

                requiredFields.forEach(field => {
                    const missing = nonCableFixtures.filter(f => {
                        const value = f[field.key] || (field.alt && f[field.alt]) || '';
                        return String(value).trim() === '';
                    });

                    if (missing.length > 0) {
                        errors.push({
                            type: 'missing_required',
                            field: field.label,
                            count: missing.length,
                            message: `${missing.length} fixture${missing.length > 1 ? 's' : ''} missing ${field.label}`,
                            fixtures: missing.slice(0, 5).map(f =>
                                `Ch ${f.Channel || '?'}: ${f['Instrument Type'] || f['Device Type'] || 'Unknown'}`
                            ),
                            canAutoFix: field.key === 'Channel'
                        });
                    }
                });

                // 2. Duplicate Channel Numbers
                const channelCounts = new Map();
                nonCableFixtures.forEach(f => {
                    const ch = f.Channel;
                    if (ch && String(ch).trim() !== '') {
                        channelCounts.set(ch, (channelCounts.get(ch) || 0) + 1);
                    }
                });

                const duplicateChannels = Array.from(channelCounts.entries())
                    .filter(([ch, count]) => count > 1);

                if (duplicateChannels.length > 0) {
                    errors.push({
                        type: 'duplicate_channels',
                        count: duplicateChannels.length,
                        message: `${duplicateChannels.length} duplicate channel number${duplicateChannels.length > 1 ? 's' : ''}`,
                        channels: duplicateChannels.slice(0, 5).map(([ch, count]) => `Ch ${ch} (${count}x)`),
                        canAutoFix: true
                    });
                }

                // 3. DMX Address Overlaps
                const overlaps = detectDMXOverlaps();
                if (overlaps.count > 0) {
                    errors.push({
                        type: 'dmx_overlaps',
                        count: overlaps.count,
                        message: `${overlaps.count} DMX address overlap${overlaps.count > 1 ? 's' : ''}`,
                        details: overlaps.details.slice(0, 5),
                        canAutoFix: true
                    });
                }

                // ===== WARNINGS (Recommended but not blocking) =====

                // 1. Missing Universe/Address
                const noUniverse = nonCableFixtures.filter(f => {
                    const { universe, address } = getUniverseAddressParts(f);
                    return !universe || !address;
                });

                if (noUniverse.length > 0) {
                    warnings.push({
                        type: 'missing_universe',
                        count: noUniverse.length,
                        message: `${noUniverse.length} fixture${noUniverse.length > 1 ? 's' : ''} without Universe/Address`,
                        description: 'Cable Planner cannot route data for these fixtures'
                    });
                }

                // 2. Missing Circuit Assignment
                const noCircuit = nonCableFixtures.filter(f =>
                    (!f['Circuit Name'] || !f['Circuit Number']) &&
                    String(f['Circuit Name'] || '').trim() !== '' &&
                    String(f['Circuit Number'] || '').trim() !== ''
                );

                if (noCircuit.length > 0) {
                    warnings.push({
                        type: 'missing_circuit',
                        count: noCircuit.length,
                        message: `${noCircuit.length} fixture${noCircuit.length > 1 ? 's' : ''} without circuit assignment`,
                        description: 'Cable Planner cannot route power for these fixtures'
                    });
                }

                return {
                    valid: errors.length === 0,
                    errors: errors,
                    warnings: warnings
                };
            }

            function detectDMXOverlaps() {
                const overlaps = new Set();
                const byUniverse = new Map();
                const details = [];

                // Group fixtures by universe
                fixtures.forEach((f, idx) => {
                    if (isCableRow(f)) return;
                    const { universe, address } = getUniverseAddressParts(f);
                    const footprint = parseIntSafe(f["DMX Footprint"]) || 1;
                    if (!universe || !address) return;
                    const start = parseInt(address);
                    const end = start + footprint - 1;

                    if (!byUniverse.has(universe)) byUniverse.set(universe, []);
                    byUniverse.get(universe).push({ idx, start, end, fixture: f });
                });

                // Check for overlaps within each universe
                byUniverse.forEach((list, uni) => {
                    list.sort((a, b) => a.start - b.start);
                    for (let i = 0; i < list.length - 1; i++) {
                        const a = list[i];
                        const b = list[i + 1];
                        if (b.start <= a.end) {
                            overlaps.add(a.idx);
                            overlaps.add(b.idx);
                            details.push(
                                `U${uni}: Ch ${a.fixture.Channel || '?'} (${a.start}-${a.end}) overlaps Ch ${b.fixture.Channel || '?'} (${b.start}-${b.end})`
                            );
                        }
                    }
                });

                return {
                    count: overlaps.size,
                    indices: Array.from(overlaps),
                    details: details
                };
            }

            // ====================================
            // AUTO-FIX FUNCTIONS
            // ====================================

            function autoFixDuplicateChannels() {
                const seen = new Set();
                let nextChannel = 1;
                let fixedCount = 0;

                const nonCable = fixtures.filter(f => !isCableRow(f));

                nonCable.forEach(f => {
                    const ch = f.Channel;
                    if (seen.has(ch)) {
                        // Find next available channel
                        while (seen.has(String(nextChannel))) {
                            nextChannel++;
                        }
                        f.Channel = String(nextChannel);
                        seen.add(String(nextChannel));
                        fixedCount++;
                    } else if (ch) {
                        seen.add(ch);
                    }
                });

                return fixedCount;
            }

            function autoFixDMXOverlaps() {
                const byUniverse = new Map();

                // Group by universe
                fixtures.forEach((f, idx) => {
                    if (isCableRow(f)) return;
                    const { universe, address } = getUniverseAddressParts(f);
                    const footprint = parseIntSafe(f["DMX Footprint"]) || 1;
                    if (!universe || !address) return;

                    if (!byUniverse.has(universe)) byUniverse.set(universe, []);
                    byUniverse.get(universe).push({ fixture: f, address: parseInt(address), footprint });
                });

                let fixedCount = 0;

                // Fix each universe
                byUniverse.forEach((list, universe) => {
                    // Sort by current address
                    list.sort((a, b) => a.address - b.address);

                    let nextAddr = 1;
                    list.forEach(({ fixture, footprint }) => {
                        const currentAddr = parseInt(getUniverseAddressParts(fixture).address);

                        // If overlaps, reassign
                        if (currentAddr < nextAddr) {
                            setUniverseAddressParts(fixture, universe, String(nextAddr));
                            fixedCount++;
                        } else {
                            nextAddr = currentAddr;
                        }

                        nextAddr += footprint;

                        // Check universe capacity
                        if (nextAddr > 513) {
                            console.warn(`Universe ${universe} exceeded 512 channels`);
                        }
                    });
                });

                return fixedCount;
            }

            function showValidationModal(validation) {
                const hasErrors = validation.errors.length > 0;
                const hasWarnings = validation.warnings.length > 0;

                let bodyHTML = '<div style="font-size: 13px; line-height: 1.6;">';

                // Errors Section
                if (hasErrors) {
                    bodyHTML += `
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin: 0 0 12px 0; color: var(--danger); font-size: 15px;">
                                ‚ùå ${validation.errors.length} Error${validation.errors.length > 1 ? 's' : ''} Found (Must Fix)
                            </h4>
                            <div style="display: flex; flex-direction: column; gap: 12px;">
                    `;

                    validation.errors.forEach(err => {
                        bodyHTML += `
                            <div style="padding: 12px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid var(--danger); border-radius: 6px;">
                                <div style="font-weight: 600; margin-bottom: 6px;">${err.message}</div>
                        `;

                        if (err.fixtures) {
                            bodyHTML += '<ul style="margin: 6px 0; padding-left: 20px; font-size: 12px;">';
                            err.fixtures.forEach(f => {
                                bodyHTML += `<li>${f}</li>`;
                            });
                            if (err.count > 5) {
                                bodyHTML += `<li><em>...and ${err.count - 5} more</em></li>`;
                            }
                            bodyHTML += '</ul>';
                        }

                        if (err.channels) {
                            bodyHTML += '<div style="font-size: 12px; margin-top: 6px;">' + err.channels.join(', ') + '</div>';
                        }

                        if (err.details) {
                            bodyHTML += '<ul style="margin: 6px 0; padding-left: 20px; font-size: 12px;">';
                            err.details.forEach(d => {
                                bodyHTML += `<li>${d}</li>`;
                            });
                            if (err.count > 5) {
                                bodyHTML += `<li><em>...and ${err.count - 5} more</em></li>`;
                            }
                            bodyHTML += '</ul>';
                        }

                        bodyHTML += '</div>';
                    });

                    bodyHTML += '</div></div>';
                }

                // Warnings Section
                if (hasWarnings) {
                    bodyHTML += `
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin: 0 0 12px 0; color: var(--warn); font-size: 15px;">
                                ‚ö†Ô∏è ${validation.warnings.length} Warning${validation.warnings.length > 1 ? 's' : ''} (Recommended)
                            </h4>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                    `;

                    validation.warnings.forEach(warn => {
                        bodyHTML += `
                            <div style="padding: 10px; background: rgba(245, 158, 11, 0.1); border-left: 3px solid var(--warn); border-radius: 6px;">
                                <div style="font-weight: 600; font-size: 13px;">${warn.message}</div>
                                ${warn.description ? `<div style="font-size: 12px; margin-top: 4px; color: var(--text-soft);">${warn.description}</div>` : ''}
                            </div>
                        `;
                    });

                    bodyHTML += '</div></div>';
                }

                bodyHTML += '</div>';

                // Buttons
                const buttons = [];

                if (hasErrors) {
                    buttons.push({
                        label: 'Cancel',
                        className: 'btn',
                        onClick: () => {}
                    });

                    // Check if any errors can be auto-fixed
                    const canAutoFix = validation.errors.some(e => e.canAutoFix);
                    if (canAutoFix) {
                        buttons.push({
                            label: 'Auto-Fix Issues',
                            className: 'btn btn-primary',
                            onClick: () => handleAutoFix(validation)
                        });
                    }
                } else {
                    buttons.push({
                        label: 'Export Anyway',
                        className: 'btn btn-primary',
                        onClick: () => proceedWithExport()
                    });
                }

                showModal('Export Validation', bodyHTML, buttons);
            }

            function handleAutoFix(validation) {
                let totalFixed = 0;
                const fixMessages = [];

                // Fix duplicate channels
                if (validation.errors.some(e => e.type === 'duplicate_channels')) {
                    const fixed = autoFixDuplicateChannels();
                    totalFixed += fixed;
                    if (fixed > 0) {
                        fixMessages.push(`Renumbered ${fixed} duplicate channels`);
                    }
                }

                // Fix DMX overlaps
                if (validation.errors.some(e => e.type === 'dmx_overlaps')) {
                    const fixed = autoFixDMXOverlaps();
                    totalFixed += fixed;
                    if (fixed > 0) {
                        fixMessages.push(`Resolved ${fixed} DMX overlaps`);
                    }
                }

                // Update display
                renderTable();
                updateStats();

                // Show success and re-validate
                showToast('Auto-Fix Complete', fixMessages);

                // Re-validate
                setTimeout(() => {
                    const newValidation = validateForVectorworksExport();
                    if (newValidation.valid) {
                        customAlert('All Fixed!', 'All issues have been resolved. You can now export.');
                    } else {
                        showValidationModal(newValidation);
                    }
                }, 500);
            }

            let pendingExportType = null;

            function proceedWithExport() {
                if (pendingExportType === 'LD') {
                    actuallyDownload();
                } else if (pendingExportType === 'ME') {
                    actuallyDownloadME();
                }
                pendingExportType = null;
            }

            // OLD validation function (kept for backward compatibility)
            function validateExport() {
                const validationColumns = [
                    { key: "Channel", label: "Channel" },
                    { key: "Purpose", label: "Purpose" },
                    {
                        key: "Universe",
                        label: "Universe",
                        getter: (f) => getUniverseAddressParts(f).universe,
                    },
                    {
                        key: "Address",
                        label: "Address",
                        getter: (f) => getUniverseAddressParts(f).address,
                    },
                    {
                        key: "Mult",
                        label: "Mult",
                        getter: (f) => f["Circuit Name"] || "",
                    },
                    {
                        key: "Circuit",
                        label: "Circuit",
                        getter: (f) => f["Circuit Number"] || "",
                    },
                ];

                const issues = [];
                const nonCableFixtures = fixtures.filter((f) => !isCableRow(f));
                const totalCount = nonCableFixtures.length;

                if (totalCount === 0) return { valid: true, issues: [] };

                validationColumns.forEach((col) => {
                    // Count filled values
                    let filledCount = 0;
                    const incompleteByType = new Map();

                    nonCableFixtures.forEach((f) => {
                        const value = col.getter
                            ? col.getter(f)
                            : f[col.key] || "";
                        const isFilled = String(value).trim() !== "";

                        if (isFilled) {
                            filledCount++;
                        } else {
                            // Track incomplete fixtures by type
                            const fixtureType =
                                f["Instrument Type"] ||
                                f["Device Type"] ||
                                "Unknown";
                            incompleteByType.set(
                                fixtureType,
                                (incompleteByType.get(fixtureType) || 0) + 1,
                            );
                        }
                    });

                    const completionRate = filledCount / totalCount;
                    const incompleteCount = totalCount - filledCount;

                    // Only flag if >50% complete but not 100%
                    if (completionRate > 0.5 && completionRate < 1) {
                        const typeList = Array.from(incompleteByType.entries())
                            .map(([type, count]) => `${count}x ${type}`)
                            .join(", ");
                        issues.push(
                            `${col.label}: ${incompleteCount} incomplete (${typeList})`,
                        );
                    }
                });

                return { valid: issues.length === 0, issues };
            }

            downloadBtn.addEventListener("click", handleDownload);
            function handleDownload() {
                if (!fixtures.length) return;
                clearSelection();

                // NEW: Comprehensive validation
                const validation = validateForVectorworksExport();

                if (!validation.valid) {
                    // Show validation modal with errors
                    pendingExportType = 'LD';
                    showValidationModal(validation);
                    return;
                }

                // If only warnings, show them but allow export
                if (validation.warnings.length > 0) {
                    pendingExportType = 'LD';
                    showValidationModal(validation);
                    return;
                }

                // All clear, proceed
                actuallyDownload();
            }

            function actuallyDownload() {
                const text = buildExportText();

                // Vectorworks FIX ‚Äî normalize CR/LF
                const safeText = text.replace(/\r/g, "").replace(/\n+/g, "\n");

                const blob = new Blob([safeText], {
                    type: "text/plain;charset=utf-8",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = buildExportFileName("LD_IMP.txt");
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // ME Export Handler - same as LD but with different filename
            downloadBtnME.addEventListener("click", handleDownloadME);
            function handleDownloadME() {
                if (!fixtures.length) return;
                clearSelection();

                // NEW: Comprehensive validation
                const validation = validateForVectorworksExport();

                if (!validation.valid) {
                    // Show validation modal with errors
                    pendingExportType = 'ME';
                    showValidationModal(validation);
                    return;
                }

                // If only warnings, show them but allow export
                if (validation.warnings.length > 0) {
                    pendingExportType = 'ME';
                    showValidationModal(validation);
                    return;
                }

                // All clear, proceed
                actuallyDownloadME();
            }

            function actuallyDownloadME() {
                const text = buildExportText();

                // Vectorworks FIX ‚Äî normalize CR/LF
                const safeText = text.replace(/\r/g, "").replace(/\n+/g, "\n");

                const blob = new Blob([safeText], {
                    type: "text/plain;charset=utf-8",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = buildExportFileName("ME_IMP.txt");
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function parseLensFromInstrument(name) {
                if (!name) return "";

                const degreeMatch = name.match(/(\d+)\s*(?:degree|deg|¬∞)/i);
                if (degreeMatch) {
                    return degreeMatch[1];
                }

                const parts = name.trim().split(/\s+/);
                if (!parts.length) return "";
                const last = parts[parts.length - 1];
                const m = last.match(/^(\d+)(?:¬∞|deg)?$/i);
                if (m) return m[1];

                return "";
            }

            exportCsvBtn.addEventListener("click", handleDownloadCSV);

            function handleDownloadCSV() {
                if (!fixtures.length) return;
                clearSelection();

                const LABEL_HEADERS = [
                    "Instrument",
                    "Lens",
                    "Channel Count",
                    "Position",
                    "Purpose",
                    "Channel #",
                    "Universe",
                    "Address",
                    "Wattage",
                    "Mult",
                    "Circuit",
                    "DIM",
                ];
                const toCSV = (s) => `"${String(s ?? "").replace(/"/g, '""')}"`;
                const lines = [];

                lines.push(LABEL_HEADERS.map(toCSV).join(","));

                fixtures.forEach((f) => {
                    if (isCableRow(f)) return;

                    let instrumentRaw = "";
                    if (headers.includes("Instrument Type")) {
                        instrumentRaw = f["Instrument Type"] || "";
                    } else if (headers.includes("Instrument")) {
                        instrumentRaw = f["Instrument"] || "";
                    }
                    const instrument = instrumentRaw;

                    let lens = parseLensFromInstrument(instrumentRaw);
                    if (!lens && headers.includes("Lens")) {
                        lens = f["Lens"] || "";
                    }

                    const channelCount = headers.includes("DMX Footprint")
                        ? f["DMX Footprint"] || ""
                        : "";

                    const position = f["Position"] || "";
                    const purpose = f["Purpose"] || "";

                    let channelNum = "";
                    if (headers.includes("Channel")) {
                        channelNum = f["Channel"] || "";
                    }

                    let universe = "";
                    let address = "";
                    if (headers.includes("Universe/Address")) {
                        const parts = getUniverseAddressParts(f);
                        universe = parts.universe || "";
                        address = parts.address || "";
                    } else {
                        if (headers.includes("Universe"))
                            universe = f["Universe"] || "";
                        if (headers.includes("Address"))
                            address = f["Address"] || "";
                    }

                    const wattage = f["Wattage"] || "";

                    const mult = headers.includes("Circuit Name")
                        ? computeCircuitNameForExport(f["Circuit Name"])
                        : "";

                    const circuit = headers.includes("Circuit Number")
                        ? f["Circuit Number"] || ""
                        : "";

                    const dimVal = "";

                    const row = [
                        instrument,
                        lens,
                        channelCount,
                        position,
                        purpose,
                        channelNum,
                        universe,
                        address,
                        wattage,
                        mult,
                        circuit,
                        dimVal,
                    ];

                    lines.push(row.map(toCSV).join(","));
                });

                const blob = new Blob([lines.join("\n")], {
                    type: "text/csv;charset=utf-8",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = buildExportFileName("Labels.csv");
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // ====== EXPORT LX PATCH PDF ======
            createPdfBtn.addEventListener("click", handleCreatePatchPDF);

            function handleCreatePatchPDF() {
                if (!fixtures.length) return;
                clearSelection();

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: "portrait",
                    unit: "in",
                    format: "letter",
                });

                // Universe/Circuit color code mappings (1-14)
                const resistorColors = {
                    1: { bg: [101, 67, 33], text: "white" }, // Brown
                    2: { bg: [255, 0, 0], text: "white" }, // Red
                    3: { bg: [255, 127, 0], text: "black" }, // Orange
                    4: { bg: [255, 255, 0], text: "black" }, // Yellow
                    5: { bg: [0, 255, 0], text: "black" }, // Green
                    6: { bg: [0, 0, 255], text: "white" }, // Blue
                    7: { bg: [148, 0, 211], text: "white" }, // Violet
                    8: { bg: [128, 128, 128], text: "white" }, // Gray
                    9: { bg: [255, 255, 255], text: "black" }, // White
                    10: { bg: [255, 192, 203], text: "black" }, // Pink
                    11: { bg: [64, 224, 208], text: "black" }, // Turquoise
                    12: { bg: [255, 215, 0], text: "black" }, // Gold
                    13: { bg: [218, 112, 214], text: "black" }, // Orchid
                    14: { bg: [127, 255, 212], text: "black" }, // Aquamarine
                };

                // Mult A-N color palette (14 distinct colors)
                const multColors = {
                    A: { bg: [255, 182, 193], text: "black" }, // Light Pink
                    B: { bg: [173, 216, 230], text: "black" }, // Light Blue
                    C: { bg: [144, 238, 144], text: "black" }, // Light Green
                    D: { bg: [255, 218, 185], text: "black" }, // Peach
                    E: { bg: [221, 160, 221], text: "black" }, // Plum
                    F: { bg: [255, 255, 224], text: "black" }, // Light Yellow
                    G: { bg: [175, 238, 238], text: "black" }, // Pale Turquoise
                    H: { bg: [255, 192, 203], text: "black" }, // Pink
                    I: { bg: [240, 230, 140], text: "black" }, // Khaki
                    J: { bg: [230, 230, 250], text: "black" }, // Lavender
                    K: { bg: [250, 250, 210], text: "black" }, // Light Goldenrod
                    L: { bg: [255, 228, 196], text: "black" }, // Bisque
                    M: { bg: [176, 224, 230], text: "black" }, // Powder Blue
                    N: { bg: [238, 232, 170], text: "black" }, // Pale Goldenrod
                };

                // Sort fixtures by Position (A-Z), then Channel (ascending)
                const sortedFixtures = fixtures
                    .filter((f) => !isCableRow(f))
                    .sort((a, b) => {
                        const posA = (a["Position"] || "").trim();
                        const posB = (b["Position"] || "").trim();
                        if (posA !== posB) return posA.localeCompare(posB);
                        const chA = parseIntSafe(a["Channel"]) || 0;
                        const chB = parseIntSafe(b["Channel"]) || 0;
                        return chA - chB;
                    });

                // Prepare table data with fixture mapping for 208V detection
                const tableData = [];
                const tableDataFixtureMap = []; // Maps tableData row index to fixture (null for blank rows)
                let lastPosition = null;

                sortedFixtures.forEach((f) => {
                    const position = (f["Position"] || "").trim();

                    // Add blank row between positions
                    if (lastPosition && lastPosition !== position) {
                        tableData.push(["", "", "", "", "", "", "", "", ""]);
                        tableDataFixtureMap.push(null); // Blank row has no fixture
                    }
                    lastPosition = position;

                    const instrument = f["Instrument Type"] || "";
                    const purpose = f["Purpose"] || "";
                    const footprint = f["DMX Footprint"] || "";
                    const wattage = f["Wattage"] || "";

                    const { universe, address } = getUniverseAddressParts(f);
                    const mult = f["Circuit Name"] || "";
                    const circuit = f["Circuit Number"] || "";

                    tableData.push([
                        instrument,
                        position,
                        purpose,
                        wattage,
                        footprint,
                        universe,
                        address,
                        mult,
                        circuit,
                    ]);
                    tableDataFixtureMap.push(f); // Map this row to the fixture
                });

                // Calculate if we should downscale to fit on one page
                // New rule: if total rows > 36 AND < 42, scale to fit on one page
                const totalRows = tableData.length;

                let fontSize = 8;
                let cellPadding = 0.04;

                if (totalRows > 36 && totalRows < 42) {
                    // Scale to fit on one page
                    const pageHeight = 11;
                    const marginTop = 0.5;
                    const marginBottom = 1.7; // Increased for larger legend
                    const headerHeight = 0.25;
                    const legendHeight = 1.5;

                    const availableHeight =
                        pageHeight -
                        marginTop -
                        marginBottom -
                        headerHeight -
                        legendHeight;
                    const estimatedTableHeight = totalRows * 0.15; // 0.15 is default row height
                    const scaleFactor = availableHeight / estimatedTableHeight;

                    fontSize = Math.max(6, fontSize * scaleFactor);
                    cellPadding = Math.max(0.02, cellPadding * scaleFactor);
                }

                // Generate PDF with autoTable
                doc.autoTable({
                    head: [
                        [
                            "Instrument",
                            "Position",
                            "Purpose",
                            "Wattage",
                            "Footprint",
                            "Uni",
                            "Address",
                            "Mult",
                            "Ckt",
                        ],
                    ],
                    body: tableData,
                    startY: 0.5,
                    margin: { left: 0.5, right: 0.5, top: 0.5, bottom: 1.7 },
                    styles: {
                        fontSize: fontSize,
                        cellPadding: cellPadding,
                        lineColor: [200, 200, 200],
                        lineWidth: 0.01,
                    },
                    headStyles: {
                        fillColor: [41, 128, 185],
                        textColor: [255, 255, 255],
                        fontStyle: "bold",
                        halign: "center",
                    },
                    columnStyles: {
                        0: { cellWidth: 1.6 }, // Instrument
                        1: { cellWidth: 0.7 }, // Position
                        2: { cellWidth: 1.3 }, // Purpose
                        3: { cellWidth: 0.5 }, // Wattage
                        4: { cellWidth: 0.6 }, // Footprint
                        5: { cellWidth: 0.5 }, // Uni
                        6: { cellWidth: 0.6 }, // Address
                        7: { cellWidth: 0.5 }, // Mult
                        8: { cellWidth: 0.5 }, // Ckt
                    },
                    alternateRowStyles: {
                        fillColor: [245, 245, 245],
                    },
                    didParseCell: function (data) {
                        // Apply universe colors to Universe column (now index 5)
                        if (
                            data.column.index === 5 &&
                            data.section === "body"
                        ) {
                            const uniNum = parseInt(data.cell.text.join(""));
                            if (!isNaN(uniNum) && resistorColors[uniNum]) {
                                const color = resistorColors[uniNum];
                                data.cell.styles.fillColor = color.bg;
                                data.cell.styles.textColor =
                                    color.text === "white"
                                        ? [255, 255, 255]
                                        : [0, 0, 0];
                                data.cell.styles.fontStyle = "bold";
                            }
                        }

                        // Apply resistor colors to Circuit column (now index 8)
                        if (
                            data.column.index === 8 &&
                            data.section === "body"
                        ) {
                            const cktNum = parseInt(data.cell.text[0]);
                            if (!isNaN(cktNum) && cktNum >= 1 && cktNum <= 6) {
                                const color = resistorColors[cktNum];
                                data.cell.styles.fillColor = color.bg;
                                data.cell.styles.textColor =
                                    color.text === "white"
                                        ? [255, 255, 255]
                                        : [0, 0, 0];
                                data.cell.styles.fontStyle = "bold";
                            }
                        }

                        // Apply Mult A-N colors (now index 7)
                        if (
                            data.column.index === 7 &&
                            data.section === "body"
                        ) {
                            const multLetter = (data.cell.text[0] || "")
                                .charAt(0)
                                .toUpperCase();
                            if (multColors[multLetter]) {
                                const color = multColors[multLetter];
                                data.cell.styles.fillColor = color.bg;
                                data.cell.styles.textColor = [0, 0, 0];
                                data.cell.styles.fontStyle = "bold";
                            }
                        }

                        // Add red border for 208V rows - use fixture map to handle blank rows
                        if (data.section === "body") {
                            const fixture = tableDataFixtureMap[data.row.index];
                            if (fixture) {
                                const multName = fixture["Circuit Name"] || "";
                                const is208 =
                                    mult208Overrides.get(multName) ??
                                    /\*?\s*208/i.test(multName);
                                if (is208) {
                                    data.cell.styles.lineColor = [255, 0, 0];
                                    data.cell.styles.lineWidth = 0.02;
                                }
                            }
                        }
                    },
                });

                // Add a new page for the Color Code Key legend
                doc.addPage();

                // Helper function to draw a pill
                const drawPill = (
                    x,
                    y,
                    text,
                    bgColor,
                    textColor,
                    width = 0.25,
                ) => {
                    doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
                    doc.roundedRect(x, y - 0.08, width, 0.12, 0.02, 0.02, "F");
                    doc.setTextColor(textColor[0], textColor[1], textColor[2]);
                    doc.setFontSize(6);
                    doc.setFont("helvetica", "bold");
                    doc.text(text, x + width / 2, y, { align: "center" });
                };

                // Draw Color Code Key on its own page
                let legendY = 1.0;

                doc.setFontSize(14);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(0, 0, 0);
                doc.text("Color Code Key", 0.5, legendY);
                legendY += 0.4;

                // MULT COLORS ROW
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text("Mult Colors:", 0.5, legendY);
                legendY += 0.3;

                let xPos = 0.5;
                [
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G",
                    "H",
                    "I",
                    "J",
                    "K",
                    "L",
                    "M",
                    "N",
                ].forEach((letter) => {
                    const color = multColors[letter];
                    drawPill(xPos, legendY, letter, color.bg, [0, 0, 0], 0.25);
                    xPos += 0.3;
                });
                legendY += 0.5;

                // CIRCUITS SECTION
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text("Circuits:", 0.5, legendY);
                legendY += 0.3;

                // CIRCUITS ROW - Line 1: 1,2 L1  3,4 L2
                xPos = 0.5;

                // Circuit 1
                drawPill(
                    xPos,
                    legendY,
                    "1",
                    resistorColors[1].bg,
                    resistorColors[1].text === "white"
                        ? [255, 255, 255]
                        : [0, 0, 0],
                    0.25,
                );
                xPos += 0.3;

                // Circuit 2
                drawPill(
                    xPos,
                    legendY,
                    "2",
                    resistorColors[2].bg,
                    resistorColors[2].text === "white"
                        ? [255, 255, 255]
                        : [0, 0, 0],
                    0.25,
                );
                xPos += 0.35;

                // L1 label
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(9);
                doc.text("L 1", xPos, legendY);
                xPos += 0.5;

                // Circuit 3
                drawPill(
                    xPos,
                    legendY,
                    "3",
                    resistorColors[3].bg,
                    resistorColors[3].text === "white"
                        ? [255, 255, 255]
                        : [0, 0, 0],
                    0.25,
                );
                xPos += 0.3;

                // Circuit 4
                drawPill(
                    xPos,
                    legendY,
                    "4",
                    resistorColors[4].bg,
                    resistorColors[4].text === "white"
                        ? [255, 255, 255]
                        : [0, 0, 0],
                    0.25,
                );
                xPos += 0.35;

                // L2 label
                doc.setTextColor(0, 0, 0);
                doc.text("L 2", xPos, legendY);

                legendY += 0.3;

                // CIRCUITS ROW - Line 2: 5,6 L3
                xPos = 0.5;

                // Circuit 5
                drawPill(
                    xPos,
                    legendY,
                    "5",
                    resistorColors[5].bg,
                    resistorColors[5].text === "white"
                        ? [255, 255, 255]
                        : [0, 0, 0],
                    0.25,
                );
                xPos += 0.3;

                // Circuit 6
                drawPill(
                    xPos,
                    legendY,
                    "6",
                    resistorColors[6].bg,
                    resistorColors[6].text === "white"
                        ? [255, 255, 255]
                        : [0, 0, 0],
                    0.25,
                );
                xPos += 0.35;

                // L3 label
                doc.setTextColor(0, 0, 0);
                doc.text("L 3", xPos, legendY);

                legendY += 0.5;

                // UNIVERSE/CIRCUIT SECTION
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text("Universe / Circuit:", 0.5, legendY);
                legendY += 0.3;

                // First row: 1-9
                xPos = 0.5;
                const universeLine1 = [
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                ];
                universeLine1.forEach((num) => {
                    const color = resistorColors[num];
                    drawPill(
                        xPos,
                        legendY,
                        num,
                        color.bg,
                        color.text === "white" ? [255, 255, 255] : [0, 0, 0],
                        0.25,
                    );
                    xPos += 0.3;
                });

                legendY += 0.3;

                // Second row: 10-14
                xPos = 0.5;
                const universeLine2 = ["10", "11", "12", "13", "14"];
                universeLine2.forEach((num) => {
                    const color = resistorColors[num];
                    drawPill(
                        xPos,
                        legendY,
                        num,
                        color.bg,
                        color.text === "white" ? [255, 255, 255] : [0, 0, 0],
                        0.3,
                    );
                    xPos += 0.35;
                });

                legendY += 0.5;

                // 208V INDICATOR SECTION
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text("208V Indicator:", 0.5, legendY);
                legendY += 0.3;

                xPos = 0.5;

                // Draw sample box with red border
                doc.setDrawColor(255, 0, 0);
                doc.setLineWidth(0.03);
                doc.setFillColor(255, 255, 255);
                doc.roundedRect(
                    xPos,
                    legendY - 0.12,
                    1.0,
                    0.2,
                    0.03,
                    0.03,
                    "FD",
                );
                doc.setTextColor(255, 0, 0);
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text("Red Border", xPos + 0.5, legendY, {
                    align: "center",
                });

                // Reset colors
                doc.setDrawColor(0, 0, 0);
                doc.setTextColor(0, 0, 0);
                doc.setLineWidth(0.01);

                // Save PDF with standardized naming
                doc.save(buildExportFileName("LX_Patch.pdf"));
            }

            createGearListPdfBtn.addEventListener(
                "click",
                handleCreateGearListPDF,
            );

            function handleCreateGearListPDF() {
                if (!fixtures.length) return;
                clearSelection();

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: "portrait",
                    unit: "in",
                    format: "letter",
                });

                // Count fixtures by Fixture Type (excluding cable rows)
                const fixtureTypeCounts = {};
                fixtures.forEach((f) => {
                    if (isCableRow(f)) return;
                    const fixtureType = (
                        f["Instrument Type"] || "Unknown"
                    ).trim();
                    if (fixtureType) {
                        fixtureTypeCounts[fixtureType] =
                            (fixtureTypeCounts[fixtureType] || 0) + 1;
                    }
                });

                // Sort fixture types alphabetically
                const sortedTypes = Object.keys(fixtureTypeCounts).sort(
                    (a, b) => a.localeCompare(b),
                );

                // Calculate spares for each fixture type
                const calculateSpares = (total) => {
                    if (total === 0) return 0;

                    let spares;
                    if (total < 20) {
                        // < 20: 10% rounded up, then rounded up to next even number
                        spares = Math.ceil(total * 0.1);
                        if (spares % 2 !== 0) spares++;
                    } else if (total >= 20 && total <= 30) {
                        // 20-30: capped at 2
                        spares = 2;
                    } else {
                        // > 30: 10% rounded up, then rounded up to next even number
                        spares = Math.ceil(total * 0.1);
                        if (spares % 2 !== 0) spares++;
                    }

                    // Minimum rule: if result is 0 but total > 0, use 2 spares
                    if (spares === 0 && total > 0) {
                        spares = 2;
                    }

                    return spares;
                };

                // Build table data
                const tableData = sortedTypes.map((fixtureType) => {
                    const count = fixtureTypeCounts[fixtureType];
                    const spares = calculateSpares(count);

                    let description = `(${count}) ${fixtureType}`;
                    if (spares > 0) {
                        description += ` [& (${spares}) Spare fixture${spares > 1 ? "s" : ""}]`;
                    }

                    return [description];
                });

                // Add title
                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(0, 0, 0);
                doc.text("Gear List", 0.5, 0.5);

                // Generate table
                doc.autoTable({
                    head: [["Fixture Type & Count"]],
                    body: tableData,
                    startY: 0.75,
                    margin: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.5 },
                    styles: {
                        fontSize: 10,
                        cellPadding: 0.08,
                        lineColor: [200, 200, 200],
                        lineWidth: 0.01,
                    },
                    headStyles: {
                        fillColor: [41, 128, 185],
                        textColor: [255, 255, 255],
                        fontStyle: "bold",
                        halign: "left",
                    },
                    columnStyles: {
                        0: { cellWidth: 7.0, halign: "left" },
                    },
                    alternateRowStyles: {
                        fillColor: [245, 245, 245],
                    },
                });

                // Save PDF
                doc.save(buildExportFileName("Gear_List.pdf"));
            }

            downloadLogBtn.addEventListener("click", handleDownloadLog);

            function handleDownloadLog() {
                clearSelection();
                if (!historyStack.length) {
                    customAlert("No Changes", "No changes have been made yet.");
                    return;
                }

                const lines = [];
                lines.push("Change Log");
                lines.push("==================");
                lines.push(`File: ${originalFileName}`);
                lines.push(`Entries: ${historyStack.length}`);
                lines.push("");

                historyStack.forEach((entry, i) => {
                    const line = `${i + 1}. ${entry.type.toUpperCase()} - Row ${entry.rowIndex + 1}, Column "${entry.colKey}"`;
                    const before = entry.before ?? "";
                    const after = entry.after ?? "";
                    lines.push(line);
                    lines.push(`   Before: ${before}`);
                    lines.push(`   After:  ${after}`);
                    lines.push("");
                });

                const blob = new Blob([lines.join("\n")], {
                    type: "text/plain;charset=utf-8",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                const base = (originalFileName || "patch").replace(
                    /\.[^.]+$/,
                    "",
                );
                a.download = `${base}.change_log.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            //exportHtmlBtn.addEventListener(
            //  "click",
            //  handleDownloadSelfContainedHTML,
            //);

            function handleDownloadSelfContainedHTML() {
                if (!fixtures.length) {
                    customAlert(
                        "No Fixtures Loaded",
                        "Load a .txt file before exporting a preloaded HTML."
                    );
                    return;
                }

                const scriptTag = document.createElement("script");
                scriptTag.type = "application/json";
                scriptTag.id = "preloaded-fixtures";
                scriptTag.textContent = JSON.stringify({
                    originalFileName,
                    headers,
                    fixtures,
                });

                const doc = document.documentElement.cloneNode(true);

                const existing = doc.querySelector("#preloaded-fixtures");
                if (existing) existing.remove();

                const body = doc.querySelector("body");
                if (!body) {
                    customAlert("Export Error", "Unexpected document structure; no &lt;body&gt; found.");
                    return;
                }

                const scripts = body.querySelectorAll("script");
                const lastScript = scripts.length
                    ? scripts[scripts.length - 1]
                    : null;

                if (lastScript) {
                    body.insertBefore(scriptTag, lastScript);
                } else {
                    body.appendChild(scriptTag);
                }

                const htmlContent = "<!DOCTYPE html>\n" + doc.outerHTML;
                const blob = new Blob([htmlContent], {
                    type: "text/html;charset=utf-8",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                const base = (originalFileName || "patch").replace(
                    /\.[^.]+$/,
                    "",
                );
                a.href = url;
                a.download = `${base}.viewer.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function toggleTheme(isDark) {
                if (isDark) {
                    document.body.classList.add("dark-theme");
                } else {
                    document.body.classList.remove("dark-theme");
                }
                localStorage.setItem(
                    "me_viewer_theme",
                    isDark ? "dark" : "light",
                );
            }

            function restoreThemePreference() {
                const saved = localStorage.getItem("me_viewer_theme");
                if (saved === "dark") {
                    themeToggle.checked = true;
                    toggleTheme(true);
                } else if (saved === "light") {
                    themeToggle.checked = false;
                    toggleTheme(false);
                } else {
                    const prefersDark =
                        window.matchMedia &&
                        window.matchMedia("(prefers-color-scheme: dark)")
                            .matches;
                    themeToggle.checked = prefersDark;
                    toggleTheme(prefersDark);
                }
            }

            themeToggle.addEventListener("change", (e) => {
                toggleTheme(e.target.checked);
            });

            function hydrateFromEmbeddedData() {
                const node = document.getElementById("preloaded-fixtures");
                if (!node) return;
                let data;
                try {
                    const raw = node.textContent || "";
                    if (!raw.trim()) return;
                    data = JSON.parse(raw);
                } catch (err) {
                    console.error(
                        "Failed to parse preloaded fixtures JSON",
                        err,
                    );
                    return;
                }
                if (
                    !data ||
                    !Array.isArray(data.fixtures) ||
                    !Array.isArray(data.headers)
                ) {
                    return;
                }

                originalFileName = data.originalFileName || "patch.txt";
                headers = data.headers.slice();

                fixtures = data.fixtures.map((row) => {
                    const f = {};
                    headers.forEach((h) => {
                        if (
                            row &&
                            Object.prototype.hasOwnProperty.call(row, h)
                        ) {
                            f[h] = row[h];
                        } else {
                            f[h] = "";
                        }
                    });
                    return f;
                });

                originalFixtures = fixtures.map(cloneRow);
                mult208Overrides.clear();

                detectDeviceTypeKey();
                indexDeviceTypes();
                renderDeviceTypePanel();
                discoverCustomMults();

                displayOrder = fixtures.map((_, idx) => idx);
                sortState = null;
                clearSelection();

                historyStack.length = 0;
                redoStack.length = 0;
                activeEdit = null;
                updateUndoButtons();

                renderTable();
                updateStats();

                const hasData = fixtures.length > 0;
                [
                    downloadBtn,
                    downloadBtnME,
                    downloadLogBtn,
                    revertBtn,
                    exportCsvBtn,
                    createPdfBtn,
                    createGearListPdfBtn,
                ].forEach((b) => (b.disabled = !hasData));

                fileStatus.textContent = hasData
                    ? `Preloaded: ${originalFileName} (${fixtures.length} rows)`
                    : "Preloaded viewer (no rows)";

                if (preloadBanner) {
                    preloadBanner.style.display = "block";
                    preloadBanner.textContent = hasData
                        ? `Hydrated from embedded data: ${originalFileName} (${fixtures.length} rows)`
                        : "Preloaded viewer (no rows)";
                }
            }

            function detectPreloadedData() {
                const node = document.getElementById("preloaded-fixtures");
                const has = !!(node && (node.textContent || "").trim());
                if (hydrateBtn) hydrateBtn.disabled = !has;
                if (preloadBanner) {
                    preloadBanner.style.display = has ? "inline-flex" : "none";
                    if (has && preloadBannerText) {
                        preloadBannerText.textContent =
                            "Preloaded data embedded in this HTML. Click ‚ÄúHydrate data‚Äù to load it.";
                    }
                }
                return has;
            }

            // if (hydrateBtn) {
            //   hydrateBtn.addEventListener("click", () => {
            //     hydrateFromEmbeddedData();
            //});
            //}

            restoreThemePreference();
            detectPreloadedData();
            hydrateFromEmbeddedData();
            updateStats();

            // Initialize multi-project system
            initializeProjectSystem();
        </script>
    </body>
</html>
